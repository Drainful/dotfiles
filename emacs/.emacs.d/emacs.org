TITLE: Emacs Configuration
#+CREATOR: Adrian Fullmer

* Table of contents                                                     :TOC:
- [[#startup][Startup]]
  - [[#lexical-scope][Lexical Scope]]
  - [[#garbage-collector-threshold][Garbage Collector Threshold]]
  - [[#filename-handlers][Filename Handlers]]
  - [[#load-secrets][Load secrets]]
  - [[#load-non-secret-environment-variables][Load non-secret environment variables]]
  - [[#constants][Constants]]
  - [[#load-path][Load Path]]
  - [[#straightel][Straight.el]]
- [[#load-helper-functions][Load helper functions]]
- [[#evil][Evil]]
  - [[#evil-collection][Evil collection]]
  - [[#evil-surround][Evil surround]]
  - [[#the-creation-of-text-objects][The creation of text objects]]
- [[#keybindings-and-commands][Keybindings and Commands]]
  - [[#generalel][General.el]]
  - [[#hydrael][Hydra.el]]
  - [[#conditional-key-translations][Conditional key translations]]
  - [[#all-modes][All modes]]
  - [[#normal-mode][Normal Mode]]
  - [[#visual-mode][Visual Mode]]
  - [[#insert-mode][Insert Mode]]
  - [[#leader][Leader]]
  - [[#shell-commands][Shell Commands]]
  - [[#other-commands][Other Commands]]
- [[#user-interface][User Interface]]
  - [[#startup-screen][Startup screen]]
  - [[#mode-line][Mode line]]
  - [[#helm][Helm]]
  - [[#hideshow][Hideshow]]
  - [[#prettify-symbols][Prettify Symbols]]
  - [[#unnecessary-ui-elements][Unnecessary UI elements]]
  - [[#files-and-backups][Files and backups]]
  - [[#line-and-column-numbers][Line and Column numbers]]
  - [[#tabs-and-indentation][Tabs and Indentation]]
  - [[#line-wrap][Line wrap]]
  - [[#start-frame-maximized][Start frame maximized]]
  - [[#confirmation][Confirmation]]
  - [[#adaptive-cursor-width][Adaptive Cursor Width]]
  - [[#delimiters][Delimiters]]
  - [[#ediff][Ediff]]
  - [[#which-key][Which-key]]
  - [[#help][Help]]
- [[#text-editing][Text editing]]
  - [[#iedit][Iedit]]
- [[#dired][Dired]]
  - [[#image-dired][Image Dired]]
  - [[#keybindings][Keybindings]]
  - [[#dired-fl][Dired FL]]
  - [[#dired-atool][Dired Atool]]
  - [[#dired-du][Dired Du]]
  - [[#dired-hacks][Dired Hacks]]
- [[#shell][Shell]]
  - [[#fishbash-completion][Fish/Bash Completion]]
  - [[#eshell][Eshell]]
  - [[#comint-mode][Comint Mode]]
  - [[#shell-1][Shell]]
  - [[#term-mode][Term mode]]
  - [[#multi-term][Multi-Term]]
- [[#tramp][Tramp]]
- [[#emacs-clientserver-settings][Emacs client/server settings]]
  - [[#daemon-management][Daemon Management]]
- [[#colors-themes-fonts-and-other-aesthetic-settings][Colors, Themes, Fonts, and other aesthetic settings]]
  - [[#theme][Theme]]
- [[#moving-around-buffers-windows-and-splits][Moving around, buffers, windows and splits]]
  - [[#winner-mode][Winner Mode]]
  - [[#helm-winconf][Helm winconf]]
  - [[#projects][Projects]]
  - [[#file-navigation][File navigation]]
- [[#programming-tools-and-settings][Programming tools and settings]]
  - [[#agressive-indent][Agressive Indent]]
  - [[#autocompletion][Autocompletion]]
  - [[#linting][Linting]]
  - [[#git-magit][Git (Magit)]]
  - [[#language-client-features][Language client features]]
  - [[#compilation][Compilation]]
- [[#language-specific-tools-and-settings][Language specific tools and settings]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs lisp]]
  - [[#common-lisp][Common Lisp]]
  - [[#clojure][Clojure]]
  - [[#scheme][Scheme]]
  - [[#python][Python]]
  - [[#lua][Lua]]
  - [[#shen][Shen]]
  - [[#prolog][Prolog]]
  - [[#cccppcppsepples][C/C++/CPP/Cpp/Sepples]]
  - [[#rust][Rust]]
  - [[#julia][Julia]]
  - [[#c-sharp][C Sharp]]
  - [[#haskell][Haskell]]
  - [[#javascript][Javascript]]
  - [[#html][HTML]]
  - [[#org][Org]]
  - [[#guix][Guix]]
  - [[#bash][Bash]]
- [[#external-tools][External tools]]
- [[#emacs-does-everything][Emacs does everything]]
  - [[#emacs-window-manager-exwm][Emacs window manager (EXWM)]]
  - [[#image-viewer][Image viewer]]
  - [[#emms][EMMS]]
  - [[#system-package-managment][System package managment]]
  - [[#irc][IRC]]
  - [[#weather][Weather]]
  - [[#bluetooth-interface][Bluetooth interface]]
- [[#helper-functions][Helper functions]]

* Startup
** Lexical Scope
I enable lexical scope. This not only improves execution time, but
also allows lexical techniques such as closures to be used.

#+PROPERTY: header-args:emacs-lisp :lexical t

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC

** Garbage Collector Threshold
In search of faster startup times, I took some advice from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom
Emacs]].
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1))

  (defun lex-p ()
    "Return t if lexical binding is in effect."
    (let (lex
      _lex-p)
      (let ((lex t))
        (setq _lex-p
          (lambda ()
            lex)))
      (funcall _lex-p)))
#+END_SRC

** Filename Handlers
Similarly to the garbage collector, startup time can be improved by
disabling the ~file-name-handler-alist~, as it will not be needed during
startup. This trick also comes from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]].
#+BEGIN_SRC emacs-lisp
(defvar temp-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

(add-hook 'emacs-startup-hook
  (setq file-name-handler-alist temp-file-name-handler-alist))
#+END_SRC

** Load secrets
Secrets are stored in ~~/.emacs.d/.secrets.el~.
#+BEGIN_SRC emacs-lisp
  (let ((secret.el (expand-file-name ".secrets.el" user-emacs-directory)))
    (when (file-exists-p secret.el)
      (load secret.el)))
#+END_SRC
** Load non-secret environment variables
#+BEGIN_SRC emacs-lisp
;; (require 'my-env)
#+END_SRC
** Constants
I create a few constants for later use
#+BEGIN_SRC emacs-lisp
  ;; Directory containing my dotfiles.
  (defconst me/dotfiles "~/dotfiles/")

  (defconst me/music-directory "~/Music/")

  (defconst me/guix-config-dir "~/.config/guix/system")
#+END_SRC

** Load Path
I extend the load path from my dotfiles directory for tentative
packages.
#+BEGIN_SRC emacs-lisp
  (push "~/.emacs.d/my-packages/" load-path)
#+END_SRC
** Straight.el
A functional alternative to package.el which promotes reusablility.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)

  (setq straight-use-package-by-default t)
#+END_SRC
* Load helper functions
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<helper-functions>>
#+END_SRC
* Evil
These are my settings for the Evil, the Vim emulator for Emacs.
#+BEGIN_SRC emacs-lisp
  ;; settings for evil-collection integration
  (setq evil-want-keybinding nil)
  (setq evil-want-integration t)
  (setq evil-want-minibuffer t)

  (use-package evil
    :straight t
    :config
    (evil-mode 1)
    ;; The undo tree sometimes deletes undo data, I prefer to just disable it.
    (global-undo-tree-mode -1)

    ;; highlight all search results
    (setq evil-search-module 'evil-search)

    ;; ex commands
    (eval-after-load 'evil-ex
      '(progn
         ;; Sometimes I don't release shift fast enough
         (evil-ex-define-cmd "W[rite]" 'evil-write)
         (evil-ex-define-cmd "Wa" 'evil-write-all)
         (evil-ex-define-cmd "Q[uit]" 'evil-quit)
         (evil-ex-define-cmd "Qa" 'evil-quit-all))))
#+END_SRC
** Evil collection
This provides ~evil~ friendly keybindings for a variety of modes.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :init
    (setq evil-want-keybinding nil)
    :after evil
    :config
    ;; (setq evil-collection-term-sync-state-and-mode-p nil)
    (evil-collection-init))
#+END_SRC
** COMMENT Evil easymotion
This package helps with the issue of not knowing how many times to
repeat an ~evil~ motion by providing a tag at the location of
each possible motion result.
#+BEGIN_SRC emacs-lisp
  (use-package evil-easymotion
    :straight t
    :config
    (evilem-default-keybindings "C-M-S-~"))
#+END_SRC
** Evil surround
This solves the tricky issue of surrounding a block of text with
delimiters when they automatically close.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+END_SRC
** COMMENT Evil snipe
At one point I used ~evil-snipe~, a tool for jumping to pairs of characters.
#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :after evil-easymotion
  :config
  (evilem-define (kbd "SPC s") 'evil-snipe-s))
#+END_SRC
** The creation of text objects
This macro was copied from [[https://stackoverflow.com/a/22418983/4921402][this]] Stackoverflow thread, and facilitates
the creation of simple ~evil~ text objects.
#+BEGIN_SRC emacs-lisp
  (defmacro define-and-bind-regex-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))

  (define-multi-macro simple-text-objects define-and-bind-regex-text-object 4)
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
  (simple-text-objects
   "pipe" "|" "|" "|"
   "slash" "/" "/" "/"
   "sexpr" "i" "(" ")")

#+END_SRC

More complex text objects are defined manually:
#+BEGIN_SRC emacs-lisp
  (evil-define-text-object evil-a-defun (count &optional beg end type)
    "Text object for a top level form (language agnostic)"
    (save-excursion
      (mark-defun)
      (list (point) (mark))))
  (define-key evil-outer-text-objects-map "f" #'evil-a-defun)

  (evil-define-text-object evil-entire-buffer (count &optional beg end type)
    "Text object for the entire buffer"
    (list 1 (1+ (buffer-size))))
  (define-key evil-outer-text-objects-map "a" #'evil-entire-buffer)
#+END_SRC
* Keybindings and Commands
** General.el
I mainly use the the package ~general~ to define keybindings and
commands. 
#+NAME: use-package-general
#+BEGIN_SRC emacs-lisp
(use-package general)
#+END_SRC
It integrates well with ~evil~.
#+BEGIN_SRC emacs-lisp
(general-evil-setup)
#+END_SRC
** Hydra.el
~hydra~ is useful to reduce repetitive keybindings.
#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC
** Conditional key translations

The equivalent of Vim noremaps are Emacs key translations. They apply
globally, so here are some macros to create key translations which apply
conditionally. They are inspired by [[https://www.emacswiki.org/emacs/Evil#toc14][this]].
#+BEGIN_SRC emacs-lisp
  ;; does not require lexical scope
  (defmacro make-conditional-key-translation (key-from key-to translate-keys-p)
    "Make a Key Translation such that if the translate-keys-p function returns true,
     key-from translates to key-to, else key-from translates to itself. "
    `(define-key key-translation-map (kbd ,key-from)
      (lambda (prompt)
        (if (,translate-keys-p) (kbd ,key-to) (kbd ,key-from)))))

  (define-multi-macro make-conditional-key-translations
                      make-conditional-key-translation
                      3)

  (defmacro inoremap-single (from to)
    `(make-conditional-key-translation ,from ,to evil-insert-state-p))
  (define-multi-macro inoremap inoremap-single 2)

  (defmacro noremap-single (from to)
    `(make-conditional-key-translation ,from ,to (lambda nil t)))
  (define-multi-macro noremap noremap-single 2)
#+END_SRC
** All modes
#+BEGIN_SRC emacs-lisp
  ;; (noremap "9" "("
  ;;            "0" ")"
  ;;            "(" "9"
  ;;            ")" "0")
#+END_SRC
** Normal Mode
These are normal mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
  (general-nmap
    "C-h" 'evil-window-left
    "C-j" 'evil-window-down
    "C-k" 'evil-window-up
    "C-l" 'evil-window-right
    "C--" 'helm-do-ag-project-root
    "C-=" 'helm-do-ag
    ;; Move a line of text using ALT+[jk]
    "M-j" 'move-line-down
    "M-k" 'move-line-up
    ;; "/" 'evil-ex-search-forward
    "t" 'evil-avy-goto-char-timer
    "q" 'evil-avy-goto-subword-1
    "g r" 'revert-buffer)

  (general-vmap
    "t" 'evil-avy-goto-char
    "q" 'evil-avy-goto-subword-1)
#+END_SRC
** Visual Mode
These are visual mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-vmap
  ;; Move a visual block of text using ALT+[jk]
  "M-k" (kbd ":move '< -2 RET `> my `< mz gv`yo`z"))
#+END_SRC
** Insert Mode
These are insert mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
  ;; (inoremap "." "-"
  ;;           "-" ".")
#+END_SRC
** Leader
The leader key is an old technique common among Vim users. A tree of
key commands are hidden behind a single key. For those who are
familiar with ~hydra~, this is a similar concept.
*** Definitions
First ~which-key~ must be loaded early
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<which-key>>
#+END_SRC

then I define the leader keys,
#+BEGIN_SRC emacs-lisp
  (cl-eval-when (compile load eval)
    (defconst leader-key ",")
    (defconst alt-leader-key "SPC"))

  (general-create-definer no-super-leader-key-def
    :prefix leader-key)

  (general-create-definer super-leader-key-def
    :prefix (concat "s-" leader-key))

  (defmacro leader-key-def (&rest args)
    `(progn
       (no-super-leader-key-def ,@args)
       (super-leader-key-def ,@args)
       ;; ,(when (featurep 'exwm)
       ;;    `(super-leader-key-def ,@args))
       ))

  (general-create-definer alt-leader-key-def
    :prefix alt-leader-key)
#+END_SRC

then some helper functions to create functions to create subleader
keybindings through ~general-create-definer~. Key-based replacements are
also generated for [[#which-key][ ~which-key~ ]].
#+BEGIN_SRC emacs-lisp
  (cl-defun leader-prefix (str &optional (prefix leader-key))
    "Append a leader key to the given string"
    (concat prefix " " str))

  (cl-defmacro define--subleader (key name general-definer-name &key (leader leader-key))
    "Both create a general definer, and a which-key replacement for the given subleader."
    (let ((no-super-name (intern (concat "no-super-"
                                         (symbol-name general-definer-name))))
          (super-name (intern (concat "super-"
                                      (symbol-name general-definer-name)))))
      `(progn
         (which-key-add-key-based-replacements
           (leader-prefix ,key ,leader) ,name)

         (which-key-add-key-based-replacements
           (leader-prefix ,key ,(concat "s-" leader)) ,name)

         (general-create-definer ,no-super-name
           :prefix (leader-prefix ,key ,leader))

         (general-create-definer ,super-name
           :prefix (leader-prefix ,key ,(concat "s-" leader)))

         (defmacro ,general-definer-name (&rest args)
           (let ((no-super-name ',no-super-name)
                 (super-name ',super-name))
             `(progn
                (,no-super-name ,@args)
                (,super-name ,@args)))))))


  ;; the format for the input of this function is inspired by general's
  ;; easy to use functions.
  (cl-defmacro define-subleader (&rest args &key (leader leader-key) &allow-other-keys)
    "Both create a general definer, and a which-key replacement for
  the given subleader. Accepts arguments in threes with no
  delimiter."
    `(progn ,@(mapcar (lambda (elt)
                        `(define--subleader ,@elt :leader ,leader))
                      (seq-partition (remove-keyword-args args) 3))))
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
  (define-subleader
    "e" "eval" eval-key-def
    "s" "start" start-key-def
    "x" "xpand" xpand-key-def
    "p" "project" project-key-def)
#+END_SRC
*** Normal Mode
#+BEGIN_SRC emacs-lisp
  (defun bury-evil-buffer ()
    (interactive)
    (bury-buffer)
    ;; (call-interactively #'evil-buffer)
    )

  (defun me/helm-buffer ()
    (interactive)
    (call-interactively #'helm-mini))

  (leader-key-def 'normal
                  "w" 'actually-kill-this-buffer    ; ",w" to kill buffer not window.
                  "q" 'evil-delete-buffer   ; ",q" to kill buffer and window. equivalent of :bd<cr>.
                  "a" #'bury-evil-buffer
                  "b" 'me/helm-buffer   ; ",b" to switch buffers.
                  "f" 'helm-find-files    ; ",f" to find file (replace :e)
                  "d" 'fzf-directory-from-home
                  "h" 'help
                  "O" 'helm-do-ag-this-file 
                  "o" 'helm-occur 
                  "i" 'helm-imenu
                  "8" 'helm-imenu-in-all-buffers
                  ";" 'eval-expression
                  "RET" (kbd ":noh"))
  (alt-leader-key-def 'normal
    "q" 'evil-record-macro
    "j" 'evil-avy-goto-line-below
    "k" 'evil-avy-goto-line-above)

  (alt-leader-key-def 'normal
    "q" 'evil-record-macro
    "j" 'evil-avy-goto-line-below
    "k" 'evil-avy-goto-line-above)
#+END_SRC
*** Visual Mode
#+BEGIN_SRC emacs-lisp
(leader-key-def 'visual
  "c" 'comment-or-uncomment-region
  "O" 'helm-do-ag-this-file 
  "o" 'helm-occur)
#+END_SRC
** Shell Commands
M-x commands for common shell commands such as reboot.
#+BEGIN_SRC emacs-lisp
  (defmacro define-shell-command (function-name &optional command)
    (let ((command (or command (symbol-name function-name))))
      `(defun ,function-name ()
         ,(format "Run shell command '%s'" command)
         (interactive)
         (shell-command ,command))))

  (define-multi-macro-clauses define-shell-commands define-shell-command)

  (define-shell-commands
    reboot
    (suspend "systemctl suspend"))
#+END_SRC
** Other Commands

A command to configure my operating system
#+BEGIN_SRC emacs-lisp
  (defun gconf ()
    (interactive)
    (or (find-file me/guix-config-dir)
        (find-file "/sudo::/etc/config.scm")
        (error "guix config not found")))

  ;; (defun guix-reconfigure ()
  ;;   (interactive)
  ;;   (start-process-shell-command "Guix Reconfigure"
  ;;                                (earmuffs "Guix Reconfigure")
  ;;                                "sudo guix system -L ~/.config/guix/system reconfigure ~/.config/guix/system/yoga.scm"))
#+END_SRC

A command to configure emacs
#+BEGIN_SRC emacs-lisp
  (defun econf () (interactive) (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

A command to create a new scratch buffer
#+BEGIN_SRC emacs-lisp
  (defun scratch ()
    (interactive)
    (let ((buffer (or (get-buffer "*scratch*")
                      (generate-new-buffer "*scratch*"))))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (funcall initial-major-mode))))
#+END_SRC
* User Interface
These are settings related to the user interface of Emacs.
** Startup screen
I disable the default startup screen and splash message.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t
        initial-scratch-message nil)
#+END_SRC
*** Scratch buffer
Set the initial mode in the scratch buffer to emacs.
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode #'lisp-interaction-mode)
#+END_SRC
** Mode line
The mode line is the line at the bottom of each buffer. It contains
useful information.
*** Delight
Delight is a package which is used to hide unnecessary mode-line
blurbs.
#+BEGIN_SRC emacs-lisp
  (use-package delight 
    :straight t
    :config
    (delight '((eldoc-mode nil "eldoc")
               (auto-revert-mode nil "autorevert")
               (org-src-mode nil "org-src")
               (org-indent-mode nil "org"))))
#+END_SRC
*** Format
#+BEGIN_SRC emacs-lisp
  (setq-default mode-line-format
                '("%e" mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "   " mode-line-position
                  evil-mode-line-tag
                  (vc-mode vc-mode)
                  "  " mode-line-modes
                  mode-line-end-spaces))
#+END_SRC
*** Shorten mode-line buffer names
This sets a limit of 70 characters for the display of buffern names in
the mode line.
#+BEGIN_SRC emacs-lisp
(setq-default mode-line-buffer-identification (list -70 (propertized-buffer-identification "%12b")))
#+END_SRC
*** Minibuffer line
Package to use the minibuffer in the manner of the mode line.
#+begin_src emacs-lisp
(use-package minibuffer-line
  :config
  (setq minibuffer-line-format
        '("%e" mode-line-misc-info mode-line-end-spaces))
  (setq minibuffer-line-refresh-interval 0.5)
  (setq display-time-format " %R %d %b")
  (setq display-time-default-load-average nil)
  (display-time-mode)
  (setq battery-mode-line-format " | %p%% %B %t")
  (display-battery-mode)
  (minibuffer-line-mode))
#+end_src
** Helm
~helm~ is a framework for incremental narrowing searching interfaces
which integrates well across Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    ;; :straight t
    :delight
    :bind (("M-x" . helm-M-x))
    :config
    (helm-mode t)

    (setq helm-buffer-max-length 120
          helm-display-buffer-default-height nil
          helm-show-completion-display-function #'helm-show-completion-default-display-function
          helm-follow-mode-persistent nil
          helm-window-prefer-horizontal-split t
          helm-window-show-buffers-function 'helm-window-mosaic-fn
          helm-split-window-default-side 'same)


    (defun me/helm-fix-insert-state-keys ()
      (setq evil-insert-state-local-map (make-keymap))
      (define-key evil-insert-state-local-map (kbd "C-n") #'helm-next-line)
      (define-key evil-insert-state-local-map (kbd "C-p") #'helm-previous-line))
    ;; (setq-local evil-insert-state-map (make-keymap ))

    (add-hook 'helm--minor-mode-hook
              #'me/helm-fix-insert-state-keys)

    ;; Refresh helm-top
    (helm-top-poll-mode 1)

    ;; redefine helm-persistent-action-display-window to split right by
    ;; default instead of left. (not configurable, sadly.)
    (cl-defun helm-persistent-action-display-window (&key split)
      "Return the window that will be used for persistent action.
  If SPLIT is `t' window is split in persistent action, if it has the
  special symbol `never' don't split, if it is `nil' normally don't
  split but this may happen in case of dedicated-windows or unsuitable
  window to display persistent action buffer."
      (with-helm-window
        (let (prev-win cur-win)
          (setq helm-persistent-action-display-window
                (cond ((and (window-live-p helm-persistent-action-display-window)
                            (not (member helm-persistent-action-display-window
                                         (get-buffer-window-list helm-buffer))))
                       helm-persistent-action-display-window)
                      ((and helm--buffer-in-new-frame-p helm-initial-frame)
                       (with-selected-frame helm-initial-frame (selected-window)))
                      ((and split (not (eq split 'never))) (split-window nil nil 'right))
                      ;; Fix Issue #2050 with dedicated window.
                      ((and (window-dedicated-p
                             (setq prev-win (previous-window (selected-window) 1)))
                            (not (eq split 'never)))
                       (with-helm-after-update-hook
                         (and (window-live-p helm-persistent-action-display-window)
                              (delete-window helm-persistent-action-display-window)))
                       ;; If next-window is usable use it, otherwise split
                       ;; the helm window.
                       (let ((nw (next-window (selected-window) 1)))
                         (if (eql nw prev-win) (split-window nil nil 'right) nw)))
                      ((window-dedicated-p
                        (setq cur-win (get-buffer-window helm-current-buffer)))
                       (previous-window (selected-window) 1))
                      (cur-win)
                      (t prev-win)))))))
#+END_SRC
*** Helm ag
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :config
    (setq helm-ag-insert-at-point 'symbol)
    (setq helm-ag-base-command "ag --nocolor --nogroup"))
#+END_SRC
*** Extending helm-highight-buffers
*** COMMENT Helper functions
#+BEGIN_SRC emacs-lisp
  (defun helm-rec-find-directory-old (&optional starting-directory)
    (interactive)
    (let ((default-directory (or starting-directory default-directory)))
      (find-file
       (helm :sources (helm-build-sync-source "directories"
                        :candidates (lambda ()
                                      (split-string
                                        (shell-command-to-string "find . -type d -not -path '*/\.*'") "\n" t))
                        :fuzzy-match t)
             :prompt "Open directory: "
             :buffer "*helm find directory*"))))

  (defun rec-find-directory (&optional starting-directory)
    (interactive)
    (let ((default-directory (or starting-directory default-directory)))
      (find-file
       (completing-read "Open directory: "
                        (split-string (shell-command-to-string "find . -type d") "\n" t)))))

  (defun helm-rec-find-directory ()
    (interactive)
    (helm-find (list "-type d -not -path '*/\.*'")))
#+END_SRC
** Hideshow
~hideshow~ mode provides vim-like folds (but not as good).
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'hs-minor-mode)
(delight 'hs-minor-mode nil "hideshow")
#+END_SRC
** Prettify Symbols
This changes the appearance of certain strings in the buffer.
#+BEGIN_SRC emacs-lisp
  (setq prettify-symbols-alist
        '(("lambda" . 955) ; λ
          ))
  (global-prettify-symbols-mode 1)
#+END_SRC
** Unnecessary UI elements
Emacs comes with such useless features as a tool bar. I like to turn them off.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
(add-to-list 'default-frame-alist
             '(vertical-scroll-bars . nil))
#+END_SRC
** Files and backups
Don't make backups.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC
Save cursor position in a file between sessions.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
** Line and Column numbers
Display them both in the mode line, and show line number on the side
of the screen in ~prog-mode~.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)

  (leader-key-def 'normal ; a keybinding to toggle line numbers
    "l" #'display-line-numbers-mode)

  (setq column-number-mode t)
#+END_SRC
** Tabs and Indentation
I use 4 space indentation by default.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              indent-tabs-mode nil)
#+END_SRC
** Line wrap
Do not truncate lines.
#+BEGIN_SRC emacs-lisp
  (setq truncate-lines nil)
#+END_SRC
** Start frame maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC
** Confirmation
Type =y= or =n=, not =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Adaptive Cursor Width
Makes the cursor the full width of the current character.
#+BEGIN_SRC emacs-lisp
  (setq x-stretch-cursor t)
#+END_SRC
** COMMENT Clipboard
Enable vim-like clipboard. This puts text copied from programs other
than emacs into the "+" register.
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard nil)
#+END_SRC
** Delimiters
*** Electric pair mode
Close delimiters automatically as I write.
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t) 

  (defun local-disable-electric-pair-mode ()
    (electric-pair-local-mode -1))
#+END_SRC
*** Matching parens
Highlight the parentheis whose pair is under the point.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-delay 0
        show-paren-style 'parenthesis)
#+END_SRC
*** Highlight parentheses
Highlight the nearest outer parentheses. Thanks to [[https://stackoverflow.com/questions/34846531/show-parentheses-when-inside-them-emacs][this]] thread.
#+BEGIN_SRC emacs-lisp
  (define-advice show-paren-function (:around (fn) fix)
    "Highlight enclosing parens."
    (cond ((looking-at-p "\\s(") (funcall fn))
          (t (save-excursion
               (ignore-errors (backward-up-list))
               (funcall fn)))))
#+END_SRC
** Ediff
Don't make a new frame for ediff.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
** Which-key
This plugin shows the available keys after a partially completed
key command. ~which-key~ key replacements are generated [[#leader][here]].
#+NAME: which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight
    :config
    (which-key-mode t))
#+END_SRC
*** Prefix command completion
From [[https://with-emacs.com/posts/prefix-command-completion/][this blog post]], offer compltion of key prefix candidates via the
prefix-help-command.
#+BEGIN_SRC emacs-lisp
  (defun which-key-M-x-prefix+ (&optional _)
    "Completing read and execute command from current prefix map.

  This command can be used as `prefix-help-command'.

  The optional argument is ignored and only for compatability with
  `which-key-C-h-dispatch' so this command can be bound in
  `which-key-C-h-map', too."
    (interactive)
    (let* ((evs (if (which-key--current-prefix)
                    (which-key--current-key-list)
                  (butlast (append (this-command-keys-vector) nil))))
           (key (apply #'vector evs))
           (map (key-binding key)))
      (which-key--execute-binding+ map (key-description key))))

  (defun which-key--execute-binding+ (map &optional prefix)
    "Completing read command from MAP and execute it.

  If PREFIX is given it should be a key description which will be
  included in the prompt."
    (let ((cmd (which-key--completing-read-cmd+ map prefix)))
      (when (commandp cmd)
        (which-key--execute-cmd+ cmd))))

  (defun which-key--completing-read-cmd+ (map &optional prefix)
    "Completing read command from MAP.

  Include PREFIX in prompt if given."
    (which-key--hide-popup-ignore-command)
    (let* ((desc
            (completing-read
             (if prefix
                 (format "Execute (%s): " prefix)
               "Execute: ")
             (mapcar #'which-key--completing-read-format+
                     (which-key--get-keymap-bindings map 'all)))))
      (intern (car (split-string desc)))))

  (defun which-key--execute-cmd+ (cmd)
    "Execute command CMD as if invoked by key sequence."
    (setq prefix-arg current-prefix-arg)
    (setq this-command cmd)
    (setq real-this-command cmd)
    (command-execute cmd 'record))

  (defun which-key--completing-read-format+ (bnd)
    "Format binding BND for `completing-read'."
    (let* ((key (car bnd))
           (cmd (cdr bnd))
           (desc (format "%s (%s)" cmd
                         (propertize key 'face 'which-key-key-face))))
      (let ((which-key-show-docstrings t))
        (which-key--maybe-add-docstring
         (format "%-50s" desc) cmd))))

  (setq prefix-help-command
        #'which-key-C-h-dispatch)

  ;; (add-to-list 'helm-completing-read-handlers-alist
  ;;              nil)

  ;; (setq prefix-help-command #'which-key-M-x-prefix+)
  (general-def which-key-C-h-map
    "C-h" #'which-key-M-x-prefix+)
#+END_SRC
** Help
#+BEGIN_SRC emacs-lisp
  (general-nmap help-mode-map ; keybindings for help mode
    "H" #'help-go-back
    "L" #'help-go-forward)
#+END_SRC
** COMMENT Beacon
Highlight the cursor when switching buffers.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :delight
    :config
    (beacon-mode 1))
#+END_SRC
* Text editing
** Iedit
Iedit is a package for interactive refactoring.
#+BEGIN_SRC emacs-lisp
  (use-package iedit)

  (use-package evil-iedit-state
    :straight t
    :config
    (defun me/evil-iedit-toggle ()
      (interactive)
      (if (evil-iedit-state-p)
          (evil-iedit-state/quit-iedit-mode)
        (evil-iedit-state/iedit-mode)))

    (general-def global-map
      "C-;" #'me/evil-iedit-toggle))
#+END_SRC
* Dired
Dired is the file manager built into Emacs. here is some configuration.
#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")

  (defun me/dired-sort ()
    (interactive)
    (dired-sort-other
     (let ((alist '(("name" . "-Al")
                    ("date" .  "-Al -t")
                    ("size" . "-Al -S"))))
       (cdr (assoc (ido-completing-read "Sort by:" alist)
                   alist)))))
#+END_SRC
** Image Dired
~image-dired~ is a built-in image thumbnail viewer for dired.
#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)

  (setq image-dired-thumb-size 400
        image-dired-thumb-width 400
        image-dired-thumb-height 400
        image-dired-thumb-margin 6
        image-dired-thumb-relief 6
        image-dired-show-all-from-dir-max-files 300)

  (defun image-dired-select-advice (arg)
    (call-interactively #'evil-force-normal-state)
    (me/image-dired-display-thumbnail-original-image))

  (advice-add 'image-dired-mouse-select-thumbnail
              :after
              #'image-dired-select-advice)

  (defvar me/image-dired-display-image-buffer nil)

  (defun me/image-dired-display-thumbnail-original-image (&optional arg)
    "Display current thumbnail's original image in display buffer.
  See documentation for `image-dired-display-image' for more information.
  With prefix argument ARG, display image in its original size."
    (interactive "P")
    (let ((file (image-dired-original-file-name)))
      (if (not (string-equal major-mode "image-dired-thumbnail-mode"))
          (message "Not in image-dired-thumbnail-mode")
        (if (not (image-dired-image-at-point-p))
            (message "No thumbnail at point")
          (if (not file)
              (message "No original file name found")
            (save-selected-window
              (when (and me/image-dired-display-image-buffer
                         (get-buffer me/image-dired-display-image-buffer))
                (kill-buffer me/image-dired-display-image-buffer))
              (find-file-other-window file)
              (setq me/image-dired-display-image-buffer (current-buffer))
              (rename-buffer (concat "*image-dired: " (buffer-name) "*"))))))))

  (general-def normal image-dired-thumbnail-mode-map
    "=" #'image-increase-size
    "RET" #'me/image-dired-display-thumbnail-original-image)
#+END_SRC
** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def normal dired-mode-map
                  "i" (lambda nil (interactive)
                        (image-dired default-directory)))

  (general-def normal dired-mode-map
    "s" #'me/dired-sort)
#+END_SRC
** Dired FL
Add additional font lock rules for dired
#+BEGIN_SRC emacs-lisp
  (use-package diredfl
    :straight t
    :config
    (diredfl-global-mode 1))
#+END_SRC
** Dired Atool
Use atool for compression and extraction
#+BEGIN_SRC emacs-lisp
(use-package dired-atool
  :straight t
  :config
  (leader-key-def normal dired-mode-map
                  "z" #'dired-atool-do-unpack
                  "Z" #'dired-atool-do-pack))
#+END_SRC
** Dired Du
Use du to list folder sizes
#+BEGIN_SRC emacs-lisp
  (use-package dired-du
    :config
    (setq dired-du-size-format t)
    (leader-key-def 'normal dired-mode-map
                    "d" #'dired-du-mode))
#+END_SRC
** Dired Hacks
[[https://github.com/Fuco1/dired-hacks#dired-rainbow][Various packages]] providing dired features
*** Dired AVFS
This allows seamless archive browsing
#+BEGIN_SRC emacs-lisp
  (use-package dired-avfs)
#+END_SRC

*** Dired Subtree
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :config
    (defun me/dired-subtree-toggle ()
      "Insert subtree at point or remove it if it was not present."
      (interactive)
      (if (dired-subtree--dired-line-is-directory-or-link-p)
          (progn
            (if (dired-subtree--is-expanded-p)
                (progn
                  (dired-next-line 1)
                  (dired-subtree-remove))
              (save-excursion (dired-subtree-insert)))
            t)
        (if (> (line-number-at-pos) 5)
            (let ((prev-point (point)))
              (dired-previous-line 1)
              (unless (me/dired-subtree-toggle)
                ;; (set-window-point nil prev-point)
                ))
          nil)))

    (general-def 'normal dired-mode-map
      "z a" #'dired-subtree-toggle))
#+END_SRC
*** Dired Ranger
Multi-stage copy/paste
#+BEGIN_SRC emacs-lisp
  (use-package dired-ranger
    :config
    (general-def normal dired-mode-map
      "c" #'dired-ranger-copy
      "p" #'dired-ranger-paste)
    (leader-key-def normal dired-mode-map
                    "v" #'dired-ranger-move))
#+END_SRC
*** Dired Narrow
Interactively narrow/filter a dired buffer. Usually I just use
helm-find-file, but sometimes it's nice to narrow for a Dired
selection.
#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :config
    (leader-key-def normal dired-mode-map
                    "n" #'dired-narrow))
#+END_SRC
* Shell
** Fish/Bash Completion
Get completion hints from bash and fish.
#+BEGIN_SRC emacs-lisp
  (use-package bash-completion
    :config
    (add-hook 'shell-dynamic-complete-functions
              #'bash-completion-dynamic-complete))

  (use-package fish-completion
    :after bash-completion
    :config
    (global-fish-completion-mode 0)
    (setq fish-completion-fallback-on-bash-p t))
#+END_SRC
** Eshell
~eshell~ is a shell that operates entirely within emacs. It is my
primary shell.
#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-smart)
#+END_SRC
*** Configuration
#+BEGIN_SRC emacs-lisp
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
  ;;(add-to-list 'eshell-visual-commands "rlwrap")

  ;; (fmakunbound 'eshell/cp)

  ;; Eshell modules
  (require 'esh-module)
  (add-to-list 'eshell-modules-list 'eshell-tramp)
  ;; (setq password-cache t) ; enable password caching
  ;; (setq password-cache-expiry 3600) ; for one hour (time in secs)

  (setq eshell-prompt-function
        (lambda ()
          (let ((pwd (concat "[" (abbreviate-file-name (eshell/pwd)) "]")))
            (concat pwd
                    (when (< 0.5 (/ (* 1.0 (length pwd))
                                    (window-width))) "
  ")
                    " " (if (= (user-uid) 0) "Λ" "λ") " "))))

  (setq eshell-prompt-regexp  "^[^#$\n]* [Λλ] ")

  (defun eshell-buffer-name-function (&optional directory)
    (concat "*eshell at "
            (abbreviate-file-name (or directory
                                      default-directory))
            "*"))

  (defun eshell-new ()
    "Open a new instance of eshell."
    (interactive)
    (let ((eshell-buffer-name (eshell-buffer-name-function)))
      (eshell 'N)))

  (defun eshell-singular ()
    "Open or switch to eshell"
    (interactive)
    (let ((eshell-buffer-name (eshell-buffer-name-function)))
      (eshell)))

  (defun eshell-at (directory)
    "Open a new instance of eshell in a new directory."
    (interactive (list (read-file-name "Eshell at: ")))
    (let ((default-directory directory))
      (eshell-new)))

  (defun eshell-at-or-switch (directory)
    (interactive (list (read-file-name "Eshell at: ")))
    (let ((buffer (get-buffer (eshell-buffer-name-function directory))))
      (if buffer
          (switch-to-buffer buffer)
        (eshell-at directory))))

  (defun eshell-here ()
    (interactive)
    (if eshell-mode
        (eshell-at default-directory)
      (eshell-at-or-switch default-directory)))

  (defun eshell-rename-buffer ()
    (let ((name (eshell-buffer-name-function)))
      (if (get-buffer name)
          (cl-labels ((recur (number)
                             (let ((new-name (set-buffer-number name number)))
                               (if (not (get-buffer new-name))
                                   (rename-buffer new-name)
                                 (recur (1+ number))))))
            (recur 1))
        (rename-buffer name))))

  (add-hook 'eshell-directory-change-hook 'eshell-rename-buffer)
#+END_SRC
*** Commands
~eshell~ commands
#+BEGIN_SRC emacs-lisp
  (defun eshell/e (&rest args)
    "Open the given files"
    (dolist (file args) (if (listp file)
                            (dolist (file file)
                              (find-file file t))                          
                          (find-file file t))))

  (defun eshell/fd (&optional from-directory)
    "Run fzf to open a directory in dired"
    (fzf-directory-from (or from-directory
                            default-directory)))

  (defun eshell/fh ()
    (eshell/fd "~"))

  (defun eshell/econf () (econf))
  (defun eshell/gconf () (gconf))

  (if (executable-find "du")
      (fmakunbound 'eshell/du)) ; for speed
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key [f1] 'eshell)
  (global-set-key [f2] 'eshell-temp)

  (defun comint-style-insert-line (count)
    "insert line at the comint prompt"
    (interactive "p")
    (evil-goto-line)
    (evil-insert-line count))

  (defun comint-style-append-line (count)
    "append line at the comint prompt"
    (interactive "p")
    (evil-goto-line)
    (evil-append-line count))

  (defun eshell-properly-send-input ()
    "Go to end of buffer and send eshell input"
    (interactive)
    (evil-goto-line)
    (eshell-send-input))

  (defun me/eshell-prev ()
    (interactive)
    (evil-append 0)
    (call-interactively
     #'eshell-previous-matching-input-from-input)
    ;; (evil-force-normal-state)
    )

  (defun me/eshell-next ()
    (interactive)
    (evil-append 0)
    (call-interactively
     #'eshell-next-matching-input-from-input)
    ;; (evil-force-normal-state)
    )

  (defun eshell-previous-matching-input-from-input (arg)
    "Search backwards through input history for match for current input.
  \(Previous history elements are earlier commands.)
  With prefix argument N, search for Nth previous match.
  If N is negative, search forwards for the -Nth following match."
    (interactive "p")
    (if (not (memq last-command '(eshell-previous-matching-input-from-input
                                  eshell-next-matching-input-from-input)))
        ;; Starting a new search
        (setq eshell-matching-input-from-input-string
              (buffer-substring (save-excursion (eshell-bol) (point))
                                (save-excursion (end-of-line) (point)))
              eshell-history-index nil))
    (eshell-previous-matching-input
     (concat "^" (regexp-quote eshell-matching-input-from-input-string))
     arg))

  (defun eshell-previous-matching-input (regexp arg)
    "Search backwards through input history for match for REGEXP.
  \(Previous history elements are earlier commands.)
  With prefix argument N, search for Nth previous match.
  If N is negative, find the next or Nth next match."
    (interactive (eshell-regexp-arg "Previous input matching (regexp): "))
    (setq arg (eshell-search-arg arg))
    (if (> eshell-last-output-end (point))
        (error "Point not located after prompt"))
    (let ((pos (eshell-previous-matching-input-string-position regexp arg)))
      ;; Has a match been found?
      (if (null pos)
          (error "Not found")
        (setq eshell-history-index pos)
        (unless (minibuffer-window-active-p (selected-window))
          (message "History item: %d" (- (ring-length eshell-history-ring) pos)))
        ;; Can't use kill-region as it sets this-command
        (delete-region eshell-last-output-end (save-excursion (end-of-line)
                                                              (point)))
        (insert-and-inherit (eshell-get-history pos)))))

  (defun eshell-next-matching-input-from-input (arg)
    "Search forwards through input history for match for current input.
  \(Following history elements are more recent commands.)
  With prefix argument N, search for Nth following match.
  If N is negative, search backwards for the -Nth previous match."
    (interactive "p")
    (eshell-previous-matching-input-from-input (- arg)))

  (defun set-eshell-keybinds ()
    (general-def :states 'normal :keymaps 'eshell-mode-map
      ;; Let me use C-j/k
      "C-j" #'evil-window-down
      "C-k" #'evil-window-up

      "M-p" #'eshell-previous-matching-input-from-input
      "M-n" #'eshell-next-matching-input-from-input

      "I" #'comint-style-insert-line
      "A" #'comint-style-append-line
      "M-<tab>" #'helm-winconf-swap
      "<return>" #'eshell-properly-send-input)
    (leader-key-def normal eshell-mode-map
                    "e" #'helm-eshell-history))

  (add-hook 'eshell-mode-hook ; needs to be in a hook because eshell is dumb/stupid
            #'set-eshell-keybinds)

#+END_SRC
*** Helm support
~helm~ can be used for ~eshell~ completions with the following code.
#+BEGIN_SRC emacs-lisp
  (defun setup-eshell-helm-completion ()
    (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete))

  (add-hook 'eshell-mode-hook
            #'setup-eshell-helm-completion)
#+END_SRC
*** Disable Company
While company mode is widely useful, helm does better for eshell.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda () (company-mode -1)))
#+END_SRC
#+END_SRC
*** Properly Protect Prompt
~eshell~ doesn't play with ~evil~ with commands such as ~dd~ which target
the whole line. This code (inspired by spacemacs shell layer) solves
that problem.
#+BEGIN_SRC emacs-lisp
  (defun protect-eshell-prompt ()
    (let ((inhibit-field-text-motion t)
          (inhibit-read-only t))
      (add-text-properties
       (point-at-bol)
       (point)
       '(rear-nonsticky t
                        inhibit-line-move-fiold-capture t
                        field output
                        read-only t
                        front-sticky (field inhibit-line-move-field-capture)))))

  (add-hook 'eshell-after-prompt-hook 'protect-eshell-prompt)
#+END_SRC
*** COMMENT Attempted prompt fixes
This code is the sum of failed attempts to get the above feature working.
#+BEGIN_SRC emacs-lisp
  (defun eshell/clear ()
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer))
    (eshell-send-input))

  (defun restrict-bol (string)
    (propertize string
                'inhibit-line-move-field-capture t
                'rear-nonsticky t
                'field 'output
                'read-only t
                'front-sticky '(field inhibit-line-move-field-capture)))
  (defun protected-eshell-prompt (old-eshell-prompt &rest args)
    (restrict-bol (apply old-eshell-prompt args)))
  (advice-add 'eshell-prompt-functio)



  (setq eshell-prompt-regexp (regexp-quote "^\b$")
        eshell-prompt-function
        (lambda nil ""))

  (setq old-eshell-prompt-function (lambda nil (eshell-prompt-function)))
  (setq old-eshell-prompt-function (symbol-value 'eshell-prompt-function))
  (setq eshell-prompt-function
        (lambda nil
          (restrict-bol (old-eshell-prompt-function))))
  (setq eshell-prompt-function
        (lambda nil
          (restrict-bol (concat
                     (eshell/pwd)
                     " $ "))))
#+END_SRC

** Comint Mode
~comint mode~ is a generalized mode for repl-like interfaces.
#+BEGIN_SRC emacs-lisp
  (setq comint-prompt-read-only t ; Don't let me delete the comint prompt duh
        comint-move-point-for-output nil  ; reduce frequent redisplays
        comint-scroll-show-maximum-output nil)

  (general-def
   :states 'normal
   :keymaps 'comint-mode-map
   ;; was overridden
   "C-j" #'evil-window-down
   "C-k" #'evil-window-up
   ;; go to prompt before append or insert line in comint mode
   "I" #'comint-style-insert-line
   "A" #'comint-style-append-line)
#+END_SRC

** Shell
Shell mode is a comint-based mode for bash and other external shells.
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal :keymaps 'shell-mode-map
     "C-j" 'evil-window-down
     "C-k" 'evil-window-up)
#+END_SRC
I prefer ~shell-mode~ to open its buffers in the same window (like eshell does)
#+BEGIN_SRC emacs-lisp
  (push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)
#+END_SRC
** Term mode
Because terminal text cannot be edited with emacs ~evil mode~, bind ~C-g~
to evil normal mode, and ~<escape>~ to escape within the terminal.
#+BEGIN_SRC emacs-lisp
  (general-def :states 'insert
    :keymaps 'term-raw-map
    "<escape>" 'term-send-esc
    "C-g" 'evil-force-normal-state)


  ;; https://emacs.stackexchange.com/questions/17005/killing-ansi-term-says-has-a-running-process
  (defun set-no-process-query-on-exit ()
    (let ((proc (get-buffer-process (current-buffer))))
      (when (processp proc)
        (set-process-query-on-exit-flag proc nil))))

  (add-hook 'term-exec-hook 'set-no-process-query-on-exit)

  ;; stop paste from entering commands.
  (setq term-suppress-hard-newline t)
#+END_SRC
*** COMMENT Protect Prompt
This code was the restult of a bad misunderstanding of the function of ~ansi-term~.
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook (lambda () (setq-local term-prompt-regexp "\\[.*\\]\\$ [\n]*")))

  (defun protect-term-prompt ()
    (interactive)
    (save-match-data
      (when (string-match (condition-case nil 
                              (symbol-value 'term-prompt-regexp) 
                            (void-variable "")) 
                          (thing-at-point 'line t))
        (let ((inhibit-field-text-motion t)
              (inhibit-read-only t))
          (add-text-properties
           (point-at-bol)
           (point-at-eol)
           '(rear-nonsticky t
                            inhibit-line-move-fiold-capture t
                            field output
                            read-only t
                            front-sticky (field inhibit-line-move-field-capture)))))))

  (advice-add 'term-send-input #'protect-term-prompt)
#+END_SRC

** Multi-Term
Allows multiple term buffers to be created.
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :config
  ;; (global-set-key [f1] 'multi-term)
  ;; access shift arrow keys
  (define-key global-map "\eO2D" (kbd "S-<left>"))
  (define-key global-map "\eO2C" (kbd "S-<right>"))
  ;; term movement
  (general-def
   :states 'normal
   :keymaps 'term-mode-map
   "S-<right>" 'multi-term-next
   "S-<left>" 'multi-term-prev
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC

* Tramp
~tramp~ is a truly one of the great gems of Emacs. It allows me to
access remote files as if they were part of my filesystem within
Emacs.
#+BEGIN_SRC emacs-lisp
  (require 'tramp)

  ;; try ftp passive mode
  (setq ange-ftp-try-passive-mode t)

  ;; Some quick functions
  (defun me/~club ()
    (interactive)
    (find-file "/ssh:ipkcle@tilde.club:/home/ipkcle"))
#+END_SRC
* Emacs client/server settings
#+BEGIN_SRC emacs-lisp
  ;; run emacs server
  ;; (server-start)

  ;; easily restart emacs daemon
  (use-package restart-emacs :straight t)

  ;; focus any new frames
  (add-to-list 'after-make-frame-functions 'select-frame-set-input-focus)
#+END_SRC
** Daemon Management
I wrote this code to help manage daemons. It is usually fine to
operate within a single daemon, but when I need to have more than one
it's nice to be able to manage them as inferior processes.
#+BEGIN_SRC emacs-lisp
  (cl-defun make-daemon-frame (socket-name &rest args)
    "Make a new emacs frame for the daemon with the given socket name."
    (interactive "M" "Socket name: ")
    (apply 'start-process
           (concat socket-name "-frame")
           nil
           "emacsclient" "--create-frame" (concat "--socket-name=" socket-name)
           args))

  (cl-defun make-daemon (socket-name &key (create-buffer t) before after (theme 'doom-nord-light))
    "Make a new emacs daemon with the given socket name."
    (interactive "M" "Socket name: ")
    (message "Loading inferior emacs")
    (let ((daemon-name (concat socket-name "-daemon")))
      (start-process-shell-command
       daemon-name (when create-buffer daemon-name)
       (concat before
               "emacs --daemon=" socket-name
               ;; "--execute \"(load-theme '"
               ;; (symbol-name theme)
               ;; " t)\""
               ";"
               after))))
#+END_SRC

I wrote some other ugly but useful functions to spawn daemons within a
given Nix environment.
#+BEGIN_SRC emacs-lisp
  (cl-defun nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; nix-shell starts daemosn in /run/user/
    (interactive)
    (let ((running? (file-exists-p (concat "/run/user/1000/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun non-nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was NOT started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; daemons started outside of nix-shell exist in /tmp/
    (interactive)
    (let ((running? (file-exists-p (concat "/tmp/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun nix-daemon (&optional (theme 'doom-nord-light))
    "Start a daemon and frame in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let* ((default-directory (file-name-directory (nix-current-sandbox)))
               (socket-name (file-name-directory default-directory))
               (daemon-name (concat socket-name "-daemon")))
          (if (nix-daemon-running-p socket-name) 
              (nix-daemon-frame)
            (message "Loading inferior nix emacs")
            (start-process-shell-command
             daemon-name daemon-name
             (concat "nix-shell --command \""
                       "emacs --daemon=" socket-name
                       " --execute \\\"
                         (load-theme '"
                         (symbol-name theme)
                         " t)\\\""
                       "; "
                       "emacsclient --create-frame "
                       (concat "--socket-name=" socket-name)
                     "; "
                     "return"
                     "\""))))
      (error "No nix environment was found")))

  (defun nix-daemon-frame ()
    "Start a frame from the relevant nix Emacs daemon in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let ((default-directory (file-name-directory (nix-current-sandbox)))
              (socket-name (elt (nreverse (split-string default-directory "/")) 1)))
          (unless (nix-daemon-running-p socket-name)
            (error "The daemon is not active"))
          (start-process-shell-command
           (concat socket-name "-frame") nil
           (concat "nix-shell --command "
                   (concat "\"emacsclient --create-frame --socket-name=" socket-name "\""))))
      (error "No nix environment was found")))
#+END_SRC

* Colors, Themes, Fonts, and other aesthetic settings
** Theme
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :config
    ;; flash mode line when emacs bell rings
    (doom-themes-visual-bell-config))

  ;; (use-package poet-theme)

  ;; (use-package chocolate-theme)

  ;; (use-package spacemacs-theme)

  ;; (use-package cyberpunk-theme)

  (defun disable-all-themes ()
    (interactive)
    (mapcar #'disable-theme custom-enabled-themes))

  (switch-theme 'doom-molokai)
#+END_SRC
*** COMMENT time-based theme
The theme loaded depends upon time of day. Causes slight face issues.
#+BEGIN_SRC emacs-lisp
  (use-package theme-changer
    :after doom-themes
    :config
    (setq calendar-location-name me/calendar-location-name)
    (setq calendar-latitude me/calendar-latitude)
    (setq calendar-longitude me/calendar-longitude)
    (change-theme 'doom-one-light 'doom-one))
#+END_SRC

* Moving around, buffers, windows and splits
** Winner Mode
~winner-mode~ lets me switch between window configurations with emacs-like undo capabilities.
I abbreviate the command with ~hydra~.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)

  (defhydra hydra-winner (global-map "C-c" :timeout 2)
    "Window configuration history"
    ("u" winner-undo)
    ("r" winner-redo))
#+END_SRC
** Helm winconf
I wrote a small and simple package for managing named window configurations.
#+BEGIN_SRC emacs-lisp
  (require 'helm-winconf)

  (general-def "M-<tab>" #'helm-winconf-swap)

  (unless (featurep 'exwm)
    (alt-leader-key-def 'normal
      "RET" #'helm-winconf))
#+END_SRC
*** COMMENT Alt tab style winconf switching
And an alt-tab hydra for it. Doomed to fail.
#+BEGIN_SRC emacs-lisp
  (lexical-let (winconf-list length)

    (defun helm-winconf-history-delta (delta)
      (assert (or (= delta 1)
                  (= delta -1)))
      (setq winconf-list (cd*r (if (minusp delta)
                                   (+ length delta)
                                 delta)
                               winconf-list))
      (set-window-configuration (cdar winconf-list)))

    (defun helm-winconf-update-history ()
      (cl-flet ((helm-winconf--rassoc (conf)
                                      (car (rassoc conf helm-winconf--names-alist)))))
      (helm-winconf--new (helm-winconf--current))
      (let ((conf (current-window-configuration))
            (name-and-conf (cons (helm-winconf--rassoc conf)
                                 conf)))
        (setq helm-winconf--names-alist (cons name-and-conf
                                              (remove name-and-conf
                                                      helm-winconf--names-alist)))))

    (general-def
     "M-<tab>" (lambda ()
                 (interactive)
                 (setq length (length helm-winconf--names-alist))
                 (setq winconf-list (circular helm-winconf--names-alist))
                 (helm-winconf-history-delta 1)
                 (hydra-winconf-history/body)))

    (defhydra hydra-winconf-history (:timeout 2
                                              :post (helm-winconf-update-history))
      "Winconf history: "
      ("M-<tab>" (helm-winconf-history-delta 1))
      ("M-<S-iso-lefttab>" (helm-winconf-history-delta -1))))
#+END_SRC
** COMMENT Persp-mode
~persp-mode~ is a package for managing window configurations. I prefer
this to managing frames.
#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :config


    (persp-mode)

    ;; I just want to use `persp-mode' as a layout saver, so I remove
    ;; all inter-persp buffer restrictions
    (setq persp-disable-buffer-restriction-once t)
    (setq persp-kill-foreign-buffer-behaviour 'just-kill)

    (general-def :keymap 'persp-mode-map
                        "M-<tab>" #'persp-next
                        "<M-iso-lefttab>" #'persp-prev))
#+END_SRC
** Projects
*** Projectile
~projectile~ is a powerful package which facilitates navigation within a
project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :delight ""
    :after general
    :config
    (general-def
      :states 'normal
      :keymaps 'projectile-mode-map
      "C-p" 'helm-projectile-find-file)
    (project-key-def 'normal 'projectile-mode-map
                     "p" 'projectile-switch-project
                     "e" 'projectile-run-eshell)
    (projectile-mode +1))

  ;; use helm for projectile
  (use-package helm-projectile
    :config
    (helm-projectile-on))
#+END_SRC
*** Skeletor
~skeletor~ is a project skeleton package which helps me get off the ground faster.
#+BEGIN_SRC emacs-lisp
  (use-package skeletor
    :config
    (setq skeletor-project-directory "~/code/") ; by default, put the
                                          ; project in the ~/code
                                          ; directory.
    (setq skeletor-user-directory (dotfiles "emacs/.emacs.d/skeletor/"))

    (defun skeletor-create-project-here ()
      "Create a skeletor project in the current directory."
      (interactive)
      (let ((skeletor-project-directory default-directory))
        (call-interactively 'skeletor-create-project)))

    ;; global substitutions
    (add-to-list 'skeletor-global-substitutions
                 '("__AUTHOR__" . "Adrian Fullmer"))

    (defun setup--lorri (dir)
      (let ((default-directory dir))
        (skeletor-shell-command "direnv allow")
        (projectile-lorri-watch)))

    ;; I don't like the default skeletons.
    (setq skeletor--project-types nil)

    ;; Custom project skeletons
    (skeletor-define-template "generic"
      :title "Generic Project"
      :substitutions
      '(("__PACKAGES__" . (lambda () (read-string "Packages to use: "))))
      :after-creation (lambda (dir) (setup--lorri dir)))
                                          ; a lambda is used to avoid a
                                          ; failed assertation where the
                                          ; function itself would
                                          ; do. maybe report the bug.

    (skeletor-define-template "common-lisp"
      :title "Common Lisp Project"
      :substitutions
      '(("__DESCRIPTION__" . (lambda () (read-string "Description: "))))
      :after-creation (lambda (dir) (setup--lorri dir)))

    (skeletor-define-template "python"
      :title "Python Project"
      :substitutions
      '(("__PACKAGES__" . (lambda () (read-string "Packages: "))))
      :after-creation (lambda (dir) (setup--lorri dir)))

    (skeletor-define-template "haskell"
      :title "Haskell Project"
      :substitutions
      '(("__HASKELL-PACKAGES__" . (lambda () (read-string "Haskell packages: ")))
        ("__PACKAGES__" . (lambda () (read-string "Other packages: "))))
      :after-creation (lambda (dir) (setup--lorri dir)))

    (skeletor-define-template "clojurescript"
      :title "Clojurescript Project"
      :after-creation (lambda (dir) (setup--lorri dir)))

    ;; Extending built-in project types seems hard.

    ;;keybindings
    (project-key-def 'normal
      "s" 'skeletor-create-project-here))
#+END_SRC
** COMMENT FZF
As powerful as ~projectile~ is, ~fzf~ still takes the cake on
speed of recursive search.
#+BEGIN_SRC emacs-lisp
  (use-package fzf)
#+END_SRC

This function opens a directory using ~fzf/start~.
#+BEGIN_SRC emacs-lisp
  (defun fzf-directory-from-home () (interactive)
         (fzf/start "~/" "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null"))

  (defun fzf-directory-from (directory) (interactive "D")
         (fzf/start directory "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null"))
#+END_SRC
** File navigation
I prefer to follow symbolic links under version control.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC
*** COMMENT Alt-tab buffer navigation
While emacs is missing key raised events, alt-tab style behavior can
still be replicated with a hydra with a timeout
(broken)
#+BEGIN_SRC emacs-lisp
  (lexical-let (blist length-blist)

    (defun buffer-switchable (buffer)
      (with-current-buffer buffer
        (not (or (minibufferp) ; dont switch to minibuffer
                 (get-buffer-window) ; or a buffer which is already visible
                 exwm--floating-frame ; or an exwm floating buffer
                 (and exwm--id ; if this is an exwm buffer
                      ;; don't switch if we are neither allowed to
                      ;; switch to exwm buffers in other frames, nor can
                      ;; see exwm buffers in other frames, unless the
                      ;; exwm buffer's frame is the current one.
                      (not (or (and exwm-workspace-show-all-buffers
                                    exwm-layout-show-all-buffers)
                               (eq (selected-frame) exwm--frame))))))))

    (defun buffer-history-delta (delta)
      (assert (or (= delta 1)
                  (= delta -1)))
      (setq blist (cd*r (if (minusp delta)
                            (+ length-blist delta)
                          delta)
                        blist))
      (if (buffer-switchable (car blist))
          ;(display-buffer-same-window (car blist) (list))
          (switch-to-buffer (car blist) t t)
        (buffer-history-delta delta)))

    (defun update-buffer-history ()
      (switch-to-buffer (current-buffer)))

    (general-def
     "M-<tab>" (lambda ()
                 (interactive)
                 (setq length-blist (length (buffer-list)))
                 (setq blist (circular (buffer-list)))
                 (buffer-history-delta 1)
                 (hydra-buffer-history/body)))

    (defhydra hydra-buffer-history (:timeout 2
                                             :post (update-buffer-history))
      "Buffer history: "
      ("M-<tab>" (buffer-history-delta 1))
      ("M-<S-iso-lefttab>" (buffer-history-delta -1))))
#+END_SRC


*** COMMENT Helm Alt-tab buffer navigation
While emacs is missing key raised events, alt-tab style behavior can
still be replicated with a hydra with a timeout
(broken)
#+BEGIN_SRC emacs-lisp
  (general-def
   "C-M-`" (lambda ()
             (interactive)
             (helm-mini)
             (hydra-helm-mini/body)))

  (defhydra hydra-helm-mini (:timeout 2
                                      :post (helm-execute-selection-action))
    "Buffer history: "
    ("M-<tab>" (helm-next-line))
    ("M-<S-iso-lefttab>" (helm-previous-line)))
#+END_SRC
*** COMMENT Buffer rotating
I bind tab and shift-tab to functions which switch to the previous and
next buffer with content respectively.
#+BEGIN_SRC emacs-lisp
  (defun content-buffer-p (buffer))
(general-def :states 'normal :keymaps 'override
                    "<tab>" 'previous-buffer
                    "<backtab>" 'next-buffer)
#+END_SRC
*** COMMENT Buffer toggling
This is a keybinding for toggling between 2
buffers. Faster than ~,-b\r~.
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal ; :keymaps 'override
                      "<tab>" 'evil-buffer)
#+END_SRC
* Programming tools and settings
** Agressive Indent
~agressive-indent-mode~ maintaints indentation as code is reformatted
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :delight
    :config
    (global-aggressive-indent-mode 1)
    (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
    (add-to-list
     'aggressive-indent-dont-indent-if
     '(and (or (derived-mode-p 'c-mode) (derived-mode-p 'c++-mode))
           (null (string-match-p "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                                 (thing-at-point 'line))))))
#+END_SRC
** Autocompletion
I use the ~Company~ package for autocompletion.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :config
    (add-to-list 'company-frontends 'company-tng-frontend) ; test this vs evil collection
    (add-to-list 'company-backends 'company-files) ; test this vs evil collection
    (add-to-list 'completion-styles 'initials t)
    ;;(add-to-list 'completion-styles 'substring t)
    (define-key company-active-map (kbd "M-.") 'company-show-location)
    (define-key company-active-map (kbd "\C-d") 'company-show-doc-buffer)
    ;;(setq company-dabbrev-downcase 0)

    (setq company-minimum-prefix-length 2)
    (setq company-idle-delay 0)
    ;; (remove-hook 'sly-mode-hook (lambda () (progn (setq company-idle-delay 0.1)
    ;;                                               (setq company-minimum-prefix-length 2))))

    (global-company-mode nil))
#+END_SRC
*** Smart Tab
#+BEGIN_SRC emacs-lisp
  (use-package smart-tab)
#+END_SRC
*** COMMENT Company Box
#+BEGIN_SRC emacs-lisp
  (use-package company-box
    :delight
    :hook (company-mode . company-box-mode))
#+END_SRC
*** COMMENT Autocomplete
I have ~auto-complete~ installed for cases where a company package does not exist.
#+BEGIN_SRC emacs-lisp
  (use-package fuzzy)
  (use-package auto-complete
    :after fuzzy
    :config)
#+END_SRC
** Linting
I use the ~flycheck~ package for linting.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (setq flycheck-global-modes '(not c-mode c++-mode)))
#+END_SRC
** Git (Magit)
I use ~magit~, a very nice Git interface.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
With ~evil~ friendly keybindings.
#+BEGIN_SRC emacs-lisp
(use-package evil-magit)
#+END_SRC
and a leader shortcut.
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal
  "m" 'magit)
#+END_SRC
*** COMMENT Magit Forge
A package to interact with Git forges like Gitlab.
#+BEGIN_SRC emacs-lisp
  (use-package forge)
#+END_SRC
** COMMENT Snippets
~yasnippet~ allows the creation of snippets to automate repetitive typing.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    :config
    (yas-global-mode t)
    ;; (setq yas/root-directory
    ;;       nil
    ;;       ;; (list (dotfiles "emacs/.emacs.d/snippets")
    ;;       ;;       yas/root-directory)
    ;;       )
    ;; (ys-reload-all)
    )
#+END_SRC
A large collection of snippets is found in the ~yasnippet-snippets~ package.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets)
#+END_SRC
~yasnippet~ can be used as a backend for ~company~.
#+BEGIN_SRC emacs-lisp
  ;; https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")

  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC
** Language client features
The language server protocol can provide IDE-like features for many
languages. ~lsp-mode~ also serves as a backend for ~company~ and ~flycheck~ / ~flymake~.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :config
    (setq lsp-prefer-flymake t))

  (use-package lsp-ui :commands lsp-ui-mode) ; adds flycheck support
  (use-package company-lsp :commands company-lsp) ; links with company
  (use-package helm-lsp :commands helm-lsp-workspace-symbol)
  ;; optionally if you want to use debugger
  ;; (use-package dap-mode)

  (leader-key-def 'normal 'lsp-mode-map
                  "e" #'lsp-execute-code-action)
#+END_SRC
** Compilation
I wrote this function to run ~make~ on a recursive upward
search. Inspired by [[https://emacs.stackexchange.com/questions/7475/recursively-go-up-to-find-makefile-and-compile][this]].
#+BEGIN_SRC emacs-lisp
(cl-defun compile-rec (&key (filename "Makefile") (command "make -k"))
  "Traveling up the path, find a Makefile and `compile'."
  (interactive)
  (let ((makefile-dir (locate-dominating-file default-directory filename)))
    (when makefile-dir
      (with-temp-buffer
        (cd makefile-dir)
        (compile command)))))
#+END_SRC
** COMMENT Direnv and Lorri
Direnv allows Emacs to automatically set environment variables on a
per-buffer basis. Direnv integrates with Nix sandboxes through Lorri.
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :delight
    :after projectile          ; I integrate projectile with direnv here
    :config
    (direnv-mode 1)

    ;; Keybindings to direnv refresh and lorri watch

    (cl-defun projectile-lorri-watch (&optional (project-directory (projectile-project-root)))
      "Begin an inferior process to watch the current projectile
  project with lorri."
      (interactive)
      (let* ((project-name (file-name-directory project-directory))
             (process-name (concat "Lorri [" project-name "]"))
             (default-directory project-directory))
        (if (file-exists-p "shell.nix")
            (if (not (get-process process-name))
                (progn
                  ;; (start-process-shell-command
                  ;;  (concat "direnv-" process-name) nil
                  ;;  "direnv-allow")
                  (start-process-shell-command
                   process-name (earmuffs process-name)
                   "lorri watch")
                  (message (concat "Lorri watching " project-name)))
              (error (concat "Lorri is already watching " project-name)))
          (error (concat "There is no shell.nix for " project-name)))))

    (project-key-def 'normal
                     "d" 'direnv-update-directory-environment
                     "l" 'projectile-lorri-watch)

    ;; Lorri watch the given project when switching to a new project.
    (add-hook 'projectile-after-switch-project-hook
              (lambda () (ignore-errors (projectile-lorri-watch))))

    ;; Advice to run emacsHook
    (defun run-emacs-hook ()
      (if (getenv "emacsHook")
          (eval (car (read-from-string
                      (format "(progn %s)"
                              (getenv "emacsHook")))))))

    ;; (advice-add 'direnv-update-directory-environment
    ;;             :after
    ;;             #'run-emacs-hook)

    (defvar to-add-to-ld-library-path "")

    (defun add-to-ld-library-path ()
      (let ((new-to-add (or (getenv "emacsAddLdLibraryPath")
                            "")))
        (remove-from-path to-add-to-ld-library-path "LD_LIBRARY_PATH" ":")
        (setq to-add-to-ld-library-path new-to-add)
        (add-to-path to-add-to-ld-library-path "LD_LIBRARY_PATH" ":")))

    ;; (advice-add 'direnv-update-directory-environment
    ;;             :after
    ;;             #'add-to-ld-library-path)

    ;; Non-file modes which should also be synched with direnv
    (defmacro add-direnv-non-file-modes (&rest body)
      `(mapcar (lambda (mode) (add-to-list 'direnv-non-file-modes mode)) (list ,@body)))

    (add-direnv-non-file-modes
     'sly-mode
     'slime-mode
     'eshell-mode
     'comint-mode
     'term-mode
     'prolog-mode
     'inferior-python-mode
     'haskell-mode))
#+END_SRC
** COMMENT Polymode
This is a very cool package that provides support for multiple major
modes in the same buffer. It seems to crash sometimes when editing org
files.
#+BEGIN_SRC emacs-lisp
(use-package polymode)
(use-package poly-org)
#+END_SRC
* Language specific tools and settings
** Lisps
#+BEGIN_SRC emacs-lisp
  (defvar me/lisp-modes
    '(emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode slime-mode-map sly-mode-map
                      scheme-mode))

  (cl-defun me/lisp-mode-p (&optional (mode major-mode))
    (find mode me/lisp-modes))
#+END_SRC
*** Lispy/ville
~lispy~ is my S-expr editing tool of choice. It integrates with ~evil~
through ~lispyville~ minor mode.
#+BEGIN_SRC emacs-lisp
  (use-package lispyville
    :delight
    :hook ((scheme-mode emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode) . lispyville-mode)
    :config
    (lispyville-set-key-theme
     '(operators
       ;; atom-motions
       prettify
       wrap
       slurp-cp
       barf-cp
       c-w
       (escape insert)
       (additional-movement normal visual motion))))
#+END_SRC

*** Lisp keybindings
Lispy is my de-facto mode for lisp languages, so lisp-specific
functionality can be bound to that mode.
#+BEGIN_SRC emacs-lisp
  (general-def :states 'insert
    :keymaps 'lispyville-mode-map
    "M-l" (lambda () (interactive)
            (insert "lambda"))
    "M-k" #'lispy-slurp-or-barf-right
    "M-j" #'lispy-slurp-or-barf-left)

  (general-def :states 'normal
    :keymaps 'lispyville-mode-map
    "M-k" #'lispy-slurp-or-barf-right
    "M-j" #'lispy-slurp-or-barf-left
    "[" #'lispyville-beginning-of-defun
    "]" #'lispyville-beginning-of-next-defun)
#+END_SRC
*** Rainbow delimiters
While ~rainbow-delimeters-mode~ is active each depth of delimiter is
given a different color. I leave it off by default.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :delight)
#+END_SRC
** Emacs lisp
*** Nameless
This uses font-lock to hide namespace prefixes automatically.
#+BEGIN_SRC emacs-lisp
  (use-package nameless
    :straight t
    :delight
    :config
    (add-hook 'emacs-lisp-mode-hook #'nameless-mode)
    (general-def :states 'insert
                        :keymaps 'emacs-lisp-mode-map
                        "C-:" 'nameless-insert-name)
    (setq nameless-global-aliases '(("fl" . "font-lock")
                                    ("s" . "seq")
                                    ("me" . "macroexp")
                                    ("c" . "cider")
                                    ("q" . "queue")
                                    ("xn" . "exwm-named-workspace"))))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def 'normal 'emacs-lisp-mode-map
    "M-." #'find-function-or-variable-at-point)

  (eval-key-def 'normal emacs-lisp-mode-map
                "b" #'eval-buffer
                "f" #'eval-defun)
  (eval-key-def 'visual emacs-lisp-mode-map
                "r" #'eval-region)

  (general-def 'normal 'lisp-interaction-mode-map
    "M-." #'find-function-or-variable-at-point)
  (eval-key-def 'normal lisp-interaction-mode-map
                "b" #'eval-buffer
                "f" #'eval-defun)
  (eval-key-def 'visual lisp-interaction-mode-map
                "r" #'eval-region)

  (general-def 'normal lisp-interaction-mode-map
    "C-j" #'eval-print-last-sexp)
#+END_SRC
** Common Lisp
*** Slime
~slime~ is a Common Lisp IDE for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :after evil
    :config

    (setq slime-contribs '(slime-fancy))
    (add-to-list 'smart-tab-completion-functions-alist
                 '(lisp-mode . helm-slime-complete))
    (add-to-list 'smart-tab-completion-functions-alist
                 '(slime-repl-mode . helm-slime-complete))

    (defmacro define-slime-lisp (name command)
      `(defun ,name () (interactive) (slime ,command)))

    (defmacro define-slime-lisp-defun (name fn)
      `(defun ,name () (interactive) (slime (funcall ,fn))))

    ;;(define-slime-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
    (define-slime-lisp sbcl "sbcl")
    (define-slime-lisp ecl "ecl --load ~/quicklisp/setup.lisp")
    (define-slime-lisp ccl "ccl")
    (define-slime-lisp clisp "clisp")

    (setq inferior-lisp-program "sbcl")
    ;; ;; Open slime debug buffers in emacs state, rather than evil state.
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(slime-read-symbol-name . nil))
    ;; ;; Avoid using helm when bugget at slime-read-symbol-name functions
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(slime-describe-symbol . nil)
    ;;              '(slime-describe-function . nil))

    ;; (defun helm-slime-completion-at-point-function ()
    ;;   #'helm-slime-complete)

    (defun slime-mode-hook-fn ()
      (company-mode -1)
      (smart-tab-mode 1))

    (add-hook 'slime-mode-hook #'slime-mode-hook-fn)

    (add-hook 'slime-repl-mode-hook
              #'slime-mode-hook-fn)

    (add-hook 'slime-repl-mode-hook
              #'local-disable-electric-pair-mode))


  ;; (use-package slime-company)

  (use-package helm-slime
    :config
    (setq helm-slime-complete-sources
          ;; '(helm-slime-fuzzy-complete-source)
          '(helm-slime-simple-complete-source helm-slime-fuzzy-complete-source helm-slime-compound-complete-source))
    (global-helm-slime-mode 1))
#+END_SRC
**** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal :keymaps 'slime-mode-map
    "K" 'slime-describe-symbol
    "M-." #'slime-edit-definition)

  (general-def :states 'normal :keymaps 'slime-repl-mode-map
    "<return>" #'slime-repl-return

    "I" #'comint-style-insert-line
    "A" #'comint-style-append-line
    "M-." #'slime-edit-definition)

  (leader-key-def 'normal slime-mode-map
                  "z" 'slime-switch-to-output-buffer
                  "c" 'slime-compile-file
                  "l" 'slime-load-file)

  (start-key-def 'normal slime-mode-map
                 "s" 'slime
                 "c" 'slime-connect)

  (eval-key-def 'normal slime-mode-map
    "b" 'slime-eval-buffer
    "f" 'slime-eval-defun)
  (eval-key-def 'visual 'slime-mode-map
                "r" 'slime-eval-region)
#+END_SRC

*** COMMENT Sly
~sly~ is a fork of ~slime~.
#+BEGIN_SRC emacs-lisp
  (use-package sly
    :after evil
    :config

    (add-to-list 'sly-contribs 'slynk-retro)

    ;; make functions for using specific lisp implementations.
    (defmacro define-sly-lisp (name command)
      `(defun ,name ()  (interactive)  (sly ,command)))

    (defmacro define-sly-lisp-defun (name fn)
      `(defun ,name ()  (interactive)  (sly (funcall ,fn))))

    ;;(define-sly-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
    (define-sly-lisp sbcl "sbcl")
    (define-sly-lisp ecl "ecl --load ~/quicklisp/setup.lisp")
    (define-sly-lisp ccl "ccl")
    (define-sly-lisp clisp "clisp")

    (setq inferior-lisp-program "sbcl")
    ;; ;; Open sly debug buffers in emacs state, rather than evil state.
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(sly-read-symbol-name . nil))
    ;; ;; Avoid using helm when bugget at sly-read-symbol-name functions
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(sly-describe-symbol . nil)
    ;;              '(sly-describe-function . nil))
    (general-def
      :states 'normal
      :keymaps 'sly-mrepl-mode-map
      "<return>" #'sly-mrepl-return

      "I" #'comint-style-insert-line
      "A" #'comint-style-append-line))
#+END_SRC

**** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal :keymaps 'sly-mode-map
    "K" 'sly-describe-symbol
    "M-." #'sly-edit-definition)

  (leader-key-def 'normal sly-mode-map
    "z" 'sly-switch-to-output-buffer
    "c" 'sly-compile-file
    "l" 'sly-load-file)

  (start-key-def 'normal sly-mode-map
    "s" 'sly
    "c" 'sly-connect)

  (eval-key-def 'normal sly-mode-map
    "b" 'sly-eval-buffer
    "f" 'sly-eval-defun)
  (eval-key-def 'visual 'sly-mode-map
    "r" 'sly-eval-region)
#+END_SRC
** Clojure
A popular lisp on the JVM.
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC
*** Cider
It's like ~slime~ for Clojure! Kinda.
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :config
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
    (setq cider-shadow-cljs-command "shadow-cljs"))

  ;; some visual flare
  (use-package spinner)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal clojure-mode-map
  "s" 'cider-jack-in
  "z" 'cider-switch-to-repl-buffer
  "a" 'cider-close-ancillary-buffers)

(eval-key-def 'normal clojure-mode-map
  "b" 'cider-eval-buffer
  "f" 'cider-eval-defun-at-point)
#+END_SRC
** Scheme
*** Geiser
It's like ~slime~ for Scheme. Kinda.
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config

    (setq geiser-active-implementations '(guile))

    ;; (with-eval-after-load 'geiser-guile
    ;;   (add-to-list 'geiser-guile-load-path "~/Code/guix"))

    (setq geiser-guile-load-path nil)
    (with-eval-after-load 'geiser-guile
      (if (symbol-function 'guix-eval) 
          (mapcar (lambda (path)
                    (add-to-list 'geiser-guile-load-path path))
                  (read (car (guix-eval "%load-path"))))))

    (defun geiser-add-company-file-backend ()
      (setq company-backends
            (remove-if (lambda (backend) (eq backend 'company-files))
                       company-backends))
      (add-to-list 'company-backends 'company-files))

    (add-hook 'geiser-mode-hook
              #'geiser-add-company-file-backend)

    (add-hook 'geiser-repl-mode-hook
              #'geiser-add-company-file-backend)

    (add-hook 'geiser-repl-mode-hook
              #'local-disable-electric-pair-mode)

    ;; (defun geiser-repl--connection* ()
    ;;   (let ((buffer (if guix-devel-mode
    ;;                     (guix-get-repl-buffer t)
    ;;                   (geiser-repl--set-up-repl geiser-impl--implementation))))
    ;;     (and (buffer-live-p buffer)
    ;;          (get-buffer-process buffer)
    ;;          (with-current-buffer buffer geiser-repl--connection))))

    ;; geiser keybindings
    (leader-key-def 'normal geiser-mode-map
                    "z" 'geiser-mode-switch-to-repl
                    "c" 'geiser-compile-file
                    "l" 'geiser-load-file)

    ;; (defun geiser-connect-guix ()
    ;;   (interactive)
    ;;   (aif (guix-repl-socket-file-name)
    ;;        (geiser-connect-local 'guile (concat it
    ;;                                             "/repl-socket"))
    ;;        (error "Guix repl not active.")))

    (start-key-def 'normal geiser-mode-map
                   "s" 'geiser
                   "c" 'geiser-connect
                   )

    (eval-key-def 'normal geiser-mode-map
                  "b" 'geiser-eval-buffer
                  "f" 'geiser-eval-definition)
    (eval-key-def 'visual 'geiser-mode-map
                  "r" 'geiser-eval-region)
    (general-def
      :states 'normal
      :keymaps 'geiser-repl-mode-map
      ;; was overridden
      "C-j" 'evil-window-down
      "C-k" 'evil-window-up))
#+END_SRC
** Python
*** COMMENT Linting
Python support is built in to ~flycheck~.
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'python-mode-hook #'flycheck-mode)
#+END_SRC
*** Language Server
Python support is built in to ~lsp-mode~.
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'python-mode-hook #'lsp)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal python-mode-map
    "z" 'python-shell-switch-to-shell)

  (start-key-def 'normal python-mode-map
    "s" 'run-python)

  (eval-key-def 'normal python-mode-map
    "b" 'python-shell-send-buffer
    "f" 'python-shell-send-defun)

  (eval-key-def 'visual 'python-mode-map
    "r" 'python-shell-send-region)
#+END_SRC
** Lua
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
    ;; Don't always switch to lua repl after sending code.
    (setq lua-always-show nil))

  (start-key-def 'normal lua-mode-map
    "s" 'run-lua
    "l" (lambda () (interactive)
          (let ((exwm-manage-force-tiling t))
            (run-lua "love" "love" nil "."))))

  (eval-key-def 'normal lua-mode-map
    "b" 'lua-send-buffer
    "f" 'lua-send-defun
    "s" 'lua-send-string
    "l" 'lua-send-current-line
    "y" (lambda () (interactive)
          (lua-send-string "repl.y()")))

  (eval-key-def 'visual lua-mode-map
    "r" 'lua-send-region)
#+END_SRC
*** COMMENT Love
#+BEGIN_SRC emacs-lisp
  (use-package love-minor-mode
    :config
    ;(setq love-local-documentation-path "~/Documents/programming/documentation/lua-love-wiki/")
    )
#+END_SRC
*** COMMENT Autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete-lua
    :straight t (:host github :repo "rolpereira/auto-complete-lua")
    :config
    (add-hook 'lua-mode-hook '(lambda ()
                                (setq ac-sources '(ac-source-lua))
                                (auto-complete-mode 1))))

  (use-package auto-complete-love
    :after auto-complete-lua
    :straight t (:host github :repo "rolpereira/auto-complete-love")
    :config
    (add-hook 'lua-mode-hook '(lambda ()
                                (setq ac-sources '(ac-source-love))
                                (push ac-source-lua ac-sources)
                                (auto-complete-mode 1))))
#+END_SRC
*** Lank
#+BEGIN_SRC emacs-lisp
  (make-variable-buffer-local
   (defvar lua-send-string-signals nil
     "A list of integers or strings representing the signals to send
    to the lua process before sending a string."))

  (make-variable-buffer-local
   (defvar lua-send-string-post ""
     "This string is sent to the lua process after any string is sent"))

  (defun lua-send-string (str)
    "Send STR plus a newline to the Lua process.
  If `lua-process' is nil or dead, start a new process first."
    (unless (string-equal (substring str -1) "\n")
      (setq str (concat str "\n")))
    (let ((process (lua-get-create-process)))
      (dolist (sig lua-send-string-signals)
        (signal-process process sig))
      (process-send-string process str)
      (process-send-string process lua-send-string-post)))

  (make-variable-buffer-local
   (defvar lank-mode-running nil))

  (define-minor-mode lank-mode
    "Use signals to automatically send code to a running lua
  process."
    :lighter " Lank"
    (if lank-mode-running
        (progn
          (setq lank-mode-running nil)
          (setq lua-send-string-signals nil)
          (setq lua-send-string-post ""))
      (progn
        (setq lank-mode-running t)
        (setq lua-send-string-signals
              (list 'SIGUSR1))
        (setq lua-send-string-post
              (format "loadstring(%s);\n"
                      (lua-make-lua-string "coroutine.yield()"))))))
#+END_SRC
** Shen
#+BEGIN_SRC emacs-lisp
(use-package shen-mode :straight t)

(leader-key-def 'normal shen-mode-map
  "z" 'switch-to-shen
  "c" 'shen-compile-file
  "l" 'shen-load-file)

(start-key-def 'normal shen-mode-map
  "s" 'run-shen)

(eval-key-def 'normal shen-mode-map
  "b" 'shen-eval-buffer
  "f" 'shen-eval-defun)

(eval-key-def 'visual 'shen-mode-map
  "r" 'shen-eval-region)
#+END_SRC
** Prolog
I use the built-in prolog mode.
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal prolog-mode-map
    "z" 'switch-to-prolog
    "c" 'prolog-compile-buffer)

  (start-key-def 'normal prolog-mode-map
    "s" 'run-swi-prolog)

  (eval-key-def 'normal prolog-mode-map
    "b" 'prolog-consult-buffer
    "f" 'prolog-consult-predicate)

  (eval-key-def 'visual 'prolog-mode-map
    "r" 'prolog-consult-region)
#+END_SRC
*** Helper functions
#+BEGIN_SRC emacs-lisp
  (defun run-swi-prolog ()
    (interactive)
    (let ((prolog-program-name "swipl"))
      (call-interactively 'run-prolog)))
#+END_SRC
** C/C++/CPP/Cpp/Sepples
*** COMMENT CQuery
A language server back end for C/++
#+BEGIN_SRC emacs-lisp
(use-package cquery
  :after projectile
  :init
  (add-hook 'c-mode-hook #'cquery//enable)
  (add-hook 'c++-mode-hook #'cquery//enable)
  :config
  (defun cquery//enable ()
    (condition-case nil
        (lsp)
      (user-error nil)))
  (setq cquery-executable "cquery")
  (setq cquery-extra-init-params '(:cacheFormat "msgpack"))
  (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".cquery")
                projectile-project-root-files-top-down-recurring)))
#+END_SRC
*** COMMENT Font lock
Corrects font lock for modern C++.
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :config
    (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))
#+END_SRC
*** Linting
Enable ~flycheck~
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'flycheck-mode)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal c-mode-base-map
    "s" 'projectile-find-other-file
    "c" 'compile-rec
    "r" '(lambda () (interactive) (compile-rec :command "make run")))
#+END_SRC
*** Style
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4
              c-default-style "linux")
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
  (add-hook 'rust-mode-hook #'lsp)
#+END_SRC
** Julia
#+BEGIN_SRC emacs-lisp
(use-package julia-repl
  :straight t
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))
#+END_SRC
** C Sharp
#+BEGIN_SRC emacs-lisp
  (use-package omnisharp
    :straight t
    :after company
    :config
    (add-hook 'csharp-mode-hook 'omnisharp-mode)
    (add-to-list 'company-backends 'company-omnisharp)
    (add-hook 'csharp-mode-hook #'flycheck-mode)

    (defun omnisharp--resolve-omnisharp-server-executable-path ()
      (executable-find "omnisharp"))
  
    (leader-key-def :states 'normal :keymaps 'omnisharp-mode-map
                    "e" #'recompile
                    "r" #'omnisharp-run-code-action-refactoring))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :config
  ;; allows capf and dabbrev backends while using haskell
  (add-hook 'haskell-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   (append '((company-capf company-dabbrev-code))
                           company-backends)))))
#+END_SRC
** COMMENT ATS
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path  "~/code/ats/ATS-Postiats/utils/emacs")
  (require 'ats-mode "ats2-mode")
  (require 'ats2-flymake "flymake-ats2")
  ;; (setenv "ATSHOME" "~/code/ats/ATS-Postiats/")
#+END_SRC
** COMMENT Elm
#+BEGIN_SRC emacs-lisp
(use-package flycheck-elm
  :config
  (add-hook 'flycheck-mode-hook 'flycheck-elm-setup))
  
(use-package elm-mode)
#+END_SRC
** Javascript
#+BEGIN_SRC emacs-lisp
  (use-package indium
    :straight t
    :config
    (defun me/indium-local-advice (old-fun &rest args)
      (let ((indium-client-executable (aif (projectile-project-root)
                                           (concat it "node_modules/.bin/indium")
                                           indium-client-executable)))
        (apply old-fun args)))
    (advice-add 'indium-client-start :around
                #'me/indium-local-advice)

    (defun me/region-for-defun-at-point (&optional pos)
      "Return a list (START END) for the positions of defun at POS.
  POS defaults to point"
      (save-excursion
        (save-match-data
          (goto-char (or pos (point)))
          (end-of-defun)
          (let ((end (point)))
            (beginning-of-defun)
            (list (point) end)))))

    (defun me/indium-eval-toplevel-form ()
      (interactive)
      (indium-eval (save-excursion
                     (save-match-data
                       (apply #'buffer-substring-no-properties
                              (me/region-for-defun-at-point))))
                   (lambda (value)
                     (indium-interaction--handle-eval-result value))))

    (eval-key-def 'normal 'js-mode-map
                  "b" #'indium-eval-buffer
                  "f" #'me/indium-eval-toplevel-form
                  "i" #'indium-eval-defun)

    (eval-key-def 'visual 'js-mode-map
                  "r" #'indium-eval-region)

    (add-hook 'js-mode-hook
              #'indium-interaction-mode))

  (use-package js2-mode
    :config
    (add-to-list 'auto-mode-alist
                 '("\\.jsm?\\'" . js2-mode)))
#+END_SRC
** HTML
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))

  (use-package emmet-mode
    :config
    ;; (add-to-list 'auto-mode-alist '("\\.html?\\'" . emmet-mode))
    (add-hook 'web-mode #'emmet-mode))

#+END_SRC
** Org
~org-mode~ is a markup mode with many features which include creating
literate source files like this one.
#+BEGIN_SRC emacs-lisp
  (setq header-line-format " ")
  ;;(add-hook 'org-mode-hook '(load-theme-buffer-local 'tsdh-light (current-buffer)))
  ;; (lambda () (progn
  ;;              (setq left-margin-width 2)
  ;;              (setq right-margin-width 2)
  ;;              (set-window-buffer nil (current-buffer))))
  ;;(setq line-spacing 0.1)
  (setq org-startup-indented t
        ;;org-bullets-bullet-list '(" ") ;; no bullets, needs org-bullets package
        ;;org-ellipsis "  " ;; folding symbol
        org-pretty-entities t
        org-hide-emphasis-markers t
        ;; show actually italicized text instead of /italicized text/
  ;;;org-agenda-block-separator ""
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t
        org-src-ask-before-returning-to-edit-buffer nil
        org-src-window-setup 'current-window)
  (general-def :states 'normal :keymaps 'org-mode-map
    "C-`" 'org-edit-special)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((lisp . t)
     (python . t)))
  (setq org-babel-lisp-eval-fn #'sly-eval)
  (setq org-babel-python-eval-fn #'python-send-string)

  (add-hook 'org-mode-hook #'auto-fill-mode)
  (require 'delight)
  (delight 'auto-fill-function "" t)
  (delight 'org-indent-mode "" t)

  ;; "C-j" 'evil-window-down
  ;; "C-k" 'evil-window-up
  ;; (define-key org-mode-map (kbd "<C-j>") nil)
  ;; (define-key org-mode-map (kbd "<C-k>") nil)
  (leader-key-def 'normal org-src-mode-map
                  "q" 'org-edit-src-exit)

  (add-hook 'org-mode-hook (lambda ()
                             (general-def :states 'normal :keymaps 'org-mode-map
                               "C-j" 'evil-window-down
                               "C-k" 'evil-window-up)))
#+END_SRC
A hydra to jump between org-babel source blocks:
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-org-babel-source-block-jump (org-mode-map "C-c C-v")
      "Jump between org babel source blocks"
      ("n" org-babel-next-src-block)
      ("p" org-babel-previous-src-block))
#+END_SRC
Create a table of contents without exporting.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :straight t
  :config
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC
** Guix
Tools for Guix, a package manager and operating system.
#+BEGIN_SRC emacs-lisp
  (use-package guix
    :config
    (add-to-path "~/.guix-profile/bin/")

    (setq guix-load-path me/guix-config-dir)

    (setq guix-guile-program
          '("/run/current-system/profile/bin/guile" "--no-auto-compile" "--listen=37146"))

    ;; avoid error when deleting and re-starting guix repl
    (defun geiser-repl--narrow-to-prompt ()
      "Narrow to active prompt region and return t, otherwise returns nil."
      (let* ((proc (get-buffer-process (current-buffer)))
             (pmark (and proc (process-mark proc)))
             (intxt (and pmark
                         (when (>= (point) (marker-position pmark))
                           (save-excursion
                             (if comint-eol-on-send
                                 (if comint-use-prompt-regexp
                                     (end-of-line)
                                   (goto-char (field-end))))
                             (buffer-substring pmark (point))))))
             (prompt-beg (and pmark (marker-position pmark)))
             (prompt-end (and prompt-beg (+ prompt-beg (length intxt)))))
        (when (> (length intxt) 0)
          (and prompt-end (narrow-to-region prompt-beg prompt-end))
          t))))
#+END_SRC
** COMMENT Nix
Tools for Nix, a package manager and operating system.
*** COMMENT Sandbox
Features for dealing with nix-shell in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package nix-sandbox)
#+END_SRC
*** Nix language support
#+BEGIN_SRC emacs-lisp
  ;; (use-package company-nixos-options
  ;;   :hook (nix-mode-hook . (lambda () (add-to-list 'company-backends 'company-nixos-options))))

  (use-package nix-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
    (add-hook 'nix-mode-hook
              (lambda ()
                (setq tab-always-indent nil)
                (setq indent-tabs-mode t))))

#+END_SRC
*** COMMENT Updating Nix hashes
#+BEGIN_SRC emacs-lisp
  (use-package nix-update)
#+END_SRC
*** COMMENT Nixos options search
#+BEGIN_SRC emacs-lisp
  (use-package nixos-options)
  (use-package helm-nixos-options)
#+END_SRC
** Bash
#+BEGIN_SRC emacs-lisp
  (auto-mode-add 'sh-mode ; set shell mode for configuration files as they appear in this repository.
                 "\\(/\\|\\`\\)\\(bash_\\(aliases\\|profile\\|history\\|log\\(in\\|out\\)\\)\\|z?log\\(in\\|out\\)\\)\\'"
                 "\\(/\\|\\`\\)\\(shrc\\|zshrc\\|m?kshrc\\|bashrc\\|inputrc\\|t?cshrc\\|esrc\\)\\'"
                 "\\(/\\|\\`\\)\\([kz]shenv\\|xinitrc\\|startxrc\\|xsession\\)\\'")
#+END_SRC
*** Auto Mode
Enter ~common-lisp-mode~ in the following files
#+BEGIN_SRC emacs-lisp
  (auto-mode-add 'common-lisp-mode
       ".sbclrc\\'"
       ".lisprc\\'"
       ".otherlisprc\\'")
#+END_SRC

* External tools
#+BEGIN_SRC emacs-lisp
  ;; startup programs
  (define-multi-macro startup-programs start-process-shell-command 3)

  ;; (when (featurep 'exwm)
  ;;     (startup-programs
  ;;      "networkmanager applet" nil "nm-applet"
  ;;      "compton" nil "compton --config ~/comptonconfig.txt"
  ;;      "avfs" nil "mountavfs"
  ;;      "restart redshift" nil "systemctl --user restart redshift.service"))

  ;; (use-package prodigy)

  (use-package openwith
    :straight t
    :config
    ;; from https://emacs.stackexchange.com/questions/17095/how-supress-dired-confirmation-of-large-file-for-specific-extensions?rq=1
    (defvar my-ok-large-file-types
      "\\.\\(?:mpe?g\\|mkv\\|mp4\\|mp3\\|avi\\|flv\\|mov\\|gif?\\|webm\\)$"
      "Regexp matching filenames which are definitely ok to visit,
  even when the file is larger than `large-file-warning-threshold'.")

    (defun abort-if-file-too-large-whitelist (old-fun &rest args)
      (unless (string-match-p my-ok-large-file-types (third args))
        (apply old-fun args)))

    (advice-add #'abort-if-file-too-large
                :around
                'abort-if-file-too-large-whitelist)

    ;; (defadvice abort-if-file-too-large (around my-check-ok-large-file-types)
    ;;   "If FILENAME matches `my-ok-large-file-types', do not abort."
    ;;   (unless (string-match-p my-ok-large-file-types (ad-get-arg 2))
    ;;     ad-do-it))
    ;; (ad-deactivate 'abort-if-file-too-large)

    (setq openwith-associations
          '(("\\.\\(?:mpe?g\\|mp4\\|mp3\\|avi\\|flv\\|mov\\|gif?\\|webm\\)$"
             "mpv" ("--loop" file))
            ("\\.\\(?:mkv\\)$"
             "mpv" (file))))
    (openwith-mode +1))
#+END_SRC
* Emacs does everything
** COMMENT Spotify
Control spotify running on any device from Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package spot4e :load-path "~/code/elisp/spot4e"
    :after general
    :requires helm url json
    :config
    (setq spot4e-refresh-token me/spotify-refresh-token)
    (run-with-timer 0 (* 60 59) 'spot4e-refresh))

  (define-subleader :leader alt-leader
    "s" "spotify" spotify-key-def)

  (spotify-key-def 'normal emacs-lisp-mode-map
    "b" 'spot4e-helm-search-user-tracks
    "a" 'spot4e-helm-search-albums
    "s" 'spot4e-player-pause
    "p" 'spot4e-player-play
    "n" 'spot4e-player-next
    "N" 'spot4e-player-previous)

  (defun spot4e-player-volume (volume)
    "Set the volume on Spotify active device."
    (interactive "nVolume: ")
    (if (or (> volume 100) (< volume 0))
        (error "Volume must be between 1 and 100"))
    (spot4e-request "PUT"
                    (concat spot4e-player-url "volume")
                    (concat "?volume_percent=" (number-to-string volume))
                    nil
                    `(("Authorization" . ,(concat "Bearer " spot4e-access-token )))))

    ;; (spot4e-player-do-action "PUT" (concat "/volume?volume_percent=" (number-to-string volume)))
#+END_SRC
** Emacs window manager (EXWM)
*** Main Package
Call emacsclient with ~-f exwm-enable~ in order to start exwm.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (setq mouse-autoselect-window nil
        focus-follows-mouse nil)

  (use-package exwm
    :delight
    :config

    (defvar clear-minibuffer-delay "2 sec")

    (let (timer)
      (defun clear-minibuffer ()
        (message nil))

      (defun clear-minibuffer-delayed ()
        (when (current-message)
          (when (find timer timer-list)
            (cancel-timer timer))
          (setq timer
                (run-with-timer clear-minibuffer-delay nil
                                #'clear-minibuffer)) )))


    (defun set-clear-minibuffer-delayed ()
      (interactive)
      (add-hook 'post-command-hook
                #'clear-minibuffer-delayed
                nil t))

    (defun unset-clear-minibuffer-delayed ()
      (interactive)
      (remove-hook 'post-command-hook
                   #'clear-minibuffer-delayed t))

    (fringe-mode 1)
    (require 'exwm-config)
    (setq exwm-mode-hook nil)
    (add-hook 'exwm-mode-hook (lambda ()
                                (setq mode-line-format
                                      (list
                                       ;; buffer
                                       " " mode-line-buffer-identification " "
                                       mode-line-modes
                                       ;; mode-line-misc-info
                                       ))))

    (add-hook 'exwm-mode-hook #'set-clear-minibuffer-delayed)
                                          ; Make sure minibuffer-line is
                                          ; visible after a command.

    (add-hook 'exwm-update-class-hook
              (lambda ()
                (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-title))))

    ;; (general-def :keymaps 'exwm-mode-map
    ;;   "C-c C-f" 'exwm-layout-toggle-fullscreen
    ;;   "C-c C-l" 'exwm-floating-toggle-floating)

    (setq exwm-input-global-keys
          `(;; Bind "s-r" to exit char-mode and fullscreen mode.
            ([?\s-r] . exwm-reset)

            ;; Bind f11 to toggle full screen
            ([f11] . exwm-layout-toggle-fullscreen)

            ;; Bind "s-!" to launch exteral commands with READ-SHELL-COMMAND
            ([?\s-!] . (lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

            ([?\s-`] . helm-next)
            ([?\s-1] . eshell-here)
            ([?\s-2] . helm-find-files)
            ([?\s-3] . multi-term)

            ;; ,@(mapcar (lambda (n)
            ;;             `(,(kbd (format "s-%d" n)) .
            ;;               (lambda ()
            ;;                 (interactive)
            ;;                 (eshell ,n))))
            ;;           (number-sequence 1 3))


            (,(kbd "<XF86MonBrightnessUp>"). desktop-brightness-increment-large)
            (,(kbd "<XF86MonBrightnessDown>" ). desktop-brightness-decrement-large)
            (,(kbd "<S-XF86MonBrightnessUp>" ). desktop-brightness-increment-normal)
            (,(kbd "<S-XF86MonBrightnessDown>" ) . desktop-brightness-decrement-normal)
            (,(kbd "<C-XF86MonBrightnessUp>" ). desktop-brightness-increment-small)
            (,(kbd "<C-XF86MonBrightnessDown>" ) . desktop-brightness-decrement-small)

            (,(kbd "<XF86AudioRaiseVolume>") . desktop-volume-increment-large)
            (,(kbd "<XF86AudioLowerVolume>") . desktop-volume-decrement-large)
            (,(kbd "S-<XF86AudioRaiseVolume>") . desktop-volume-increment-normal)
            (,(kbd "S-<XF86AudioLowerVolume>") . desktop-volume-decrement-normal)
            (,(kbd "C-<XF86AudioRaiseVolume>") . desktop-volume-increment-small)
            (,(kbd "C-<XF86AudioLowerVolume>") . desktop-volume-decrement-small)
            (,(kbd "<XF86AudioMute>") . pulseaudio-control-toggle-current-sink-mute)


            ;; Bind "s- " to launch external commands through my launcher.
            ([?\s- ] . exlaunch)

            ;; Winconf
            ([s-return] . helm-winconf)

            ;; bind "s-[direction] to switch windows"
            ([?\s-h] . windmove-left)
            ([?\s-j] . windmove-down)
            ([?\s-k] . windmove-up)
            ([?\s-l] . windmove-right)

            ;; bind "s-arrow" to move, "maximize" or "minimize" a window
            ([s-right] . windows-right)
            ([s-down] . evil-quit)
            ([s-up] . delete-other-windows)
            ([s-left] . windows-left)

            ;; lock screen
            ([?\s-o] . desktop-environment-lock-screen)

            ;; symon mode toggle
            ([?\s-\\] . symon-mode)

            ;; toggle window floating
            ([?\s-/] . exwm-floating-toggle-floating)

            ;; switch between buffers
            ([s-tab] . evil-buffer)

            ;; switch to scratch winconf and scratch buffer
            ([?\s-0] . (lambda ()
                         (interactive)
                         (helm-winconf-switch "scratch")
                         (scratch)))

            ;; bind "s-[v and s] to split vertical and horizontal"
            ([?\s-v] . evil-window-vsplit)
            ([?\s-s] . evil-window-split)
            ([?\s-c] . hydra-winner/body)
            ;; ([?\s-c ?\u] . hydra-winner/winner-undo)
            ;; ([?\s-c ?\r] . hydra-winner/winner-redo)
            ;; ([?\s-c ?\l] . exwm-floating-toggle-floating)
            ;; bind "s-z" to M-x
            ([?\s-z] . helm-M-x)
            ;; bind "s-;" to ex mode
            ([?\s-\;] . evil-ex)
            ;; bind "s-b" to buffer switching
            ([?\s-b] . me/helm-buffer)
            ;; bind "s-f" to file switching
            ([?\s-f] . helm-find-files)
            ;; bind "s-q" to kill this buffer, closing the current
            ;; program, and "s-w" to kill the current buffer AND window
            ([?\s-w] . actually-kill-this-buffer)
            ([?\s-q] . evil-delete-buffer)
            ([?\s-a] . bury-evil-buffer)
            ([?\s-a] . bury-evil-buffer)
            ([?\s-A] . (lambda ()
                         (interactive)
                         (bury-evil-buffer)
                         (evil-quit)))
            ([?\s-g] . guix)
            ;; bind "s-g" to keyboard-quit
            ([?\s-G] . keyboard-quit)))

    ;; do not start in char mode by default
    ;; (setq exwm-manage-configurations '((t char-mode t)))

    ;; sys tray
    (require 'exwm-systemtray)
    (setq exwm-systemtray-height 34)
    (exwm-systemtray-enable)

    ;; set prefix keys
    (setq exwm-input-prefix-keys (list
                                  ?\s-,
                                  ?\s-m
                                  (elt (kbd "M-<tab>") 0)
                                  (elt (kbd "<XF86AudioPause>") 0)
                                  (elt (kbd "<M-iso-lefttab>") 0)
                                  (elt (kbd "s-<tab>") 0)
                                  (elt (kbd "<s-iso-lefttab>") 0)))

    ;; Allow pulling a window between workspaces by switching to its buffer
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    ;; Redefine function to fix global-display-line-numbers-mode bug
    ;; regarding the exwm "frame" not having the 'client parameter
    (defun display-line-numbers--turn-on ()
      "Turn on `display-line-numbers-mode'."
      (unless (or (minibufferp)
                  ;; taken from linum.el
                  nil
                  ;; (and (daemonp) (null (frame-parameter nil 'client)))
                  )
        (display-line-numbers-mode 1))))
#+END_SRC
*** COMMENT Named Workspaces
I wrote a small package to replace the numbered workspaces of exwm
with named ones. This includes creation, deletion, and switching by
narrowing name.
#+BEGIN_SRC emacs-lisp
  (require 'exwm-named-workspace)

  ;; ; (exwm-named-workspace-make "scratch")
#+END_SRC

This is a hydra to switch between workspaces in the classic "Alt-tab"
style

#+BEGIN_SRC emacs-lisp
  (lexical-let ((history-element 0))
    (defun workspace-history-delta (delta)
      (exwm-named-workspace-history (+ history-element delta) t)
      (incf history-element delta))

    (general-def
     "M-<tab>" (lambda ()
                 (interactive)
                 (workspace-history-delta 1)
                 (hydra-workspace-history/body)))

    (defhydra hydra-workspace-history (:timeout 2
                                       :post (progn
                                               (setq history-element 0)
                                               (exwm-named-workspace-update-history)))
      "Workspace history: "
      ("M-<tab>" (workspace-history-delta 1))
      ;; ("s-<S-iso-lefttab>" (workspace-history-delta -1))
      ("<M-iso-lefttab>" (workspace-history-delta -1))))
#+END_SRC
*** Exlaunch
I wrote a package to launch programs which integrates with ~exwm~ and
~exwm-named-workspaces~.
#+BEGIN_SRC emacs-lisp
  (require 'exlaunch)

  (define-multi-macro-clauses exlaunch-shortcuts exlaunch-shortcut
    "Define functions to launch programs. ")

  (exlaunch-shortcuts
   multimc
   (next :switch-to nil)
   krita
   gimp)
#+END_SRC
*** Symon system monitor
#+BEGIN_SRC emacs-lisp
  (use-package symon)
#+END_SRC
*** Helm EXWM
~Helm-EXWM~ defines helm sources for exwm buffers
#+BEGIN_SRC emacs-lisp
  (use-package helm-exwm
    :config
    (setq helm-exwm-buffer-max-length 120)

    ;; preview buffer when switching
    (add-to-list 'helm-source-names-using-follow "EXWM buffers")

    (general-def :keymaps 'helm-exwm-map
      "M-d" #'helm-buffer-run-kill-persistent
      "S-<return>" #'helm-buffer-switch-buffers-other-window)

    (require 'helm-next)

    ;; ;; Separate EXWM and qutebrowser buffers in helm-mini
    ;; (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
    ;; (setq helm-exwm-source (helm-next-build-exwm-source))
    ;; (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
    ;;                                   helm-exwm-source
    ;;                                   helm-next--buffers-source
    ;;                                   helm-source-recentf))
    (setq helm-mini-default-sources `(helm-source-buffers-list
                                      helm-source-recentf
                                      helm-source-buffer-not-found)))
#+END_SRC
**** Helm qutebrowser
A helm source to switch between qutebrowser tabs (as windows) or to
search for url if a matching tab is not found.
#+BEGIN_SRC emacs-lisp
  (require 'helm-next)
#+END_SRC
*** Desktop Environment
#+BEGIN_SRC emacs-lisp
  (use-package pulseaudio-control
    :config
    (setq pulseaudio-control-use-default-sink t))

  (defmacro define-increment-functions (type
                                        get-command
                                        get-regex
                                        set-command
                                        argument-large-increment
                                        argument-normal-increment
                                        argument-small-increment
                                        argument-large-decrement
                                        argument-normal-decrement
                                        argument-small-decrement)
    (let ((getter-fn-name (intern (concat "desktop-" type "-get"))))
      `(progn
         ,(when get-command
            `(defun ,getter-fn-name ()
               (let ((output ,(if (stringp get-command)
                                  `(shell-command-to-string ,get-command)
                                `(funcall ,get-command))))
                 (save-match-data
                   (string-match ,get-regex output)
                   (match-string 1 output)))))
         ,@(mapcar
            (lambda (l)
              `(defun ,(intern (concat "desktop-" type (car l))) ()
                 (interactive)
                 ,(if (stringp set-command)
                      `(shell-command-to-string ,(format set-command (cadr l)))
                    `(funcall ,set-command ,(cadr l)))
                 ,(when get-command `(message ,(concat type ": %s") (,getter-fn-name)))))
            `(("-increment-large" ,argument-large-increment)
              ("-increment-normal" ,argument-normal-increment)
              ("-increment-small" ,argument-small-increment)
              ("-decrement-large" ,argument-large-decrement)
              ("-decrement-normal" ,argument-normal-decrement)
              ("-decrement-small" ,argument-small-decrement))))))

  (define-increment-functions
    "brightness"
    "brightnessctl" "\\([0-9]+%\\)"
    "brightnessctl set %s"
    "10%+" "5%+" "1%+" "10%-" "5%-" "1%-")

  (defun pulseaudio-set-volume (percent)
    (let ((pulseaudio-control-volume-step (format "%d%%" (abs percent))))
      (if (minusp percent)
          (pulseaudio-control-decrease-volume)
        (pulseaudio-control-increase-volume))))

  (define-increment-functions
    "volume"
    nil nil
    #'pulseaudio-set-volume
    10 5 1 -10 -5 -1)

  (general-def
    "<XF86MonBrightnessUp>" #'desktop-brightness-increment-large
    "<XF86MonBrightnessDown>" #'desktop-brightness-decrement-large
    "<S-XF86MonBrightnessUp>" #'desktop-brightness-increment-normal
    "<S-XF86MonBrightnessDown>" #'desktop-brightness-decrement-normal
    "<C-XF86MonBrightnessUp>" #'desktop-brightness-increment-small
    "<C-XF86MonBrightnessDown>" #'desktop-brightness-decrement-small)

  (general-def
    "<XF86AudioRaiseVolume>" #'desktop-volume-increment-large
    "<XF86AudioLowerVolume>" #'desktop-volume-decrement-large
    "S-<XF86AudioRaiseVolume>" #'desktop-volume-increment-normal
    "S-<XF86AudioLowerVolume>" #'desktop-volume-decrement-normal
    "C-<XF86AudioRaiseVolume>" #'desktop-volume-increment-small
    "C-<XF86AudioLowerVolume>" #'desktop-volume-decrement-small
    "<XF86AudioMute>" #'pulseaudio-control-toggle-current-sink-mute)
#+END_SRC
*** COMMENT Desktop Environment
~desktop-environment~ is a package which provides keybindings for tasks such as changing volume.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :delight
    :config

    (general-def 'desktop-environment-mode-map
      "s-l" #'windmove-right)

    (desktop-environment-mode 1)

    (defun desktop-environment-volume-set (value)
      (error value)
      (error "test")
      (pulseaudio-control-set-volume value))

    (defun desktop-environment-lock-screen ()
      "Lock the screen, preventing anyone without a password from using the system."
      (interactive)
      (start-process-shell-command "slock" nil desktop-environment-screenlock-command))

    (defcustom desktop-environment-brightness-tiny-increment "1%+"
      "Tiny brightness increment value."
      :type 'string)

    (defcustom desktop-environment-brightness-tiny-decrement "1%-"
      "Tiny brightness decrement value."
      :type 'string)

    (defun desktop-environment-brightness-increment-very-slowly ()
      "Increment brightness by `desktop-environment-brightness-tiny-increment'."
      (interactive)
      (desktop-environment-brightness-set desktop-environment-brightness-tiny-increment))

    (defun desktop-environment-brightness-decrement-very-slowly ()
      "Decrement brightness by `desktop-environment-brightness-tiny-decrement'."
      (interactive)
      (desktop-environment-brightness-set desktop-environment-brightness-tiny-decrement))

    (general-def ; :keymaps 'dekstop-environment-mode-map
      "<C-XF86MonBrightnessUp>" #'desktop-environment-brightness-increment-very-slowly
      "<C-XF86MonBrightnessDown>" #'desktop-environment-brightness-decrement-very-slowly)


    ;; run brightness and volume changes in home directory
    (defun desktop-environment-brightness-get ()
      "Return a string representing current brightness level."
      (let ((default-directory "~/")
            (output (shell-command-to-string desktop-environment-brightness-get-command)))
        (save-match-data
          (string-match desktop-environment-brightness-get-regexp output)
          (match-string 1 output))))

    (defun desktop-environment-brightness-set (value)
      "Set brightness to VALUE."
      (let ((default-directory "~/"))
        (shell-command-to-string (format desktop-environment-brightness-set-command value))
        (message "New brightness value: %s" (desktop-environment-brightness-get))))

    
  ;;; Helper functions - volume

    (defun desktop-environment-volume-get ()
      "Return a string representing current volume level."
      (let ((default-directory "~/")
            (output (shell-command-to-string desktop-environment-volume-get-command)))
        (save-match-data
          (string-match desktop-environment-volume-get-regexp output)
          (match-string 1 output))))

    (defun desktop-environment-volume-set (value)
      "Set volume to VALUE."
      (let ((default-directory "~/"))
        (shell-command-to-string (format desktop-environment-volume-set-command value))
        (message "New volume value: %s" (desktop-environment-volume-get))))


    ;; better mute function (single line output)
    (defun desktop-environment-toggle-mute ()
      "Toggle between muted and un-muted."
      (interactive)
      (let ((default-directory "~/"))
        (message "%s"
                 (if (find "off" (split-string (shell-command-to-string desktop-environment-volume-toggle-command)
                                               (rx (or "[" "]")))
                           :test #'string=)
                     "Sound Off"
                   "Sound On")))))
#+END_SRC
*** Next Browser
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function #'browse-url-generic)
  (setq browse-url-generic-program "next")

  (require 'slime)

  (defvar next-browser-connection nil)

  (defun get-next-browser-connection ()
    (if (and next-browser-connection
             (find next-browser-connection slime-net-processes))
        next-browser-connection
      (aif (ignore-errors
             (slime-net-connect "localhost"
                                "4006"))
           (setq next-browser-connection it))))

  (defun next-browser-eval (sexp)
    (aif (get-next-browser-connection)
         (let ((slime-dispatching-connection it))
           (slime-eval sexp))
         (error "Next browser has not been started.")))
#+END_SRC
*** COMMENT Qutebrowser
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function #'browse-url-generic)
  (setq browse-url-generic-program "qutebrowser")
#+END_SRC
*** COMMENT EXWM firefox
#+BEGIN_SRC emacs-lisp
  (use-package exwm-firefox-core)

  (use-package exwm-firefox-evil)

  (setq browse-url-generic-program "firefox")
#+END_SRC
*** Helpful commands
#+BEGIN_SRC emacs-lisp
  ;; logout function
  (defun logout ()
    (interactive)
    (recentf-save-list)
    (save-some-buffers)
    (start-process-shell-command "logout" nil "lxsession-logout"))
#+END_SRC
**** COMMENT Old launchers
#+BEGIN_SRC emacs-lisp

  (defun bluetooth ()
    (interactive)
    (split-window-vertically)
    (other-window 1)
    (start-process-shell-command "blueman-manager" nil "blueman-manager"))

  (defmacro define-start-process-shell-function (name command)
    `(defun ,name ()
       (interactive)
       (start-process-shell-command ,(symbol-name name)
                                    nil
                                    ,command)))

  (define-multi-macro define-start-process-shell-functions define-start-process-shell-function 2)

  (define-start-process-shell-functions 
    wifi "cool-retro-term -e nmtui"
    spotify "spotify --force-device-scale-factor=2")
#+END_SRC
*** Other config
#+BEGIN_SRC emacs-lisp
  ;; Rename exwm buffers to window title
  (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)

  ;;; Allow non-floating resizing with mouse.
  (setq window-divider-default-bottom-width 0
        window-divider-default-right-width 6)
  (window-divider-mode 1)


#+END_SRC
*** COMMENT autominimize
#+BEGIN_SRC emacs-lisp
  (defvar autominimize-list (list "love"))

  (defun autominimize ()
    (when (find-if (lambda (class) (string= exwm-class-name class))
                   autominimize-list)
      (winner-undo)))

  (remove-hook 'exwm-manage-finish-hook
            #'autominimize)
#+END_SRC
*** COMMENT floating toggle
#+BEGIN_SRC emacs-lisp
  (defconst floating-toggle-list (list "love" "firefox"))

  (defun enforce-floating-toggle-list ()
    (mapcar (lambda (class)
              (when (string= exwm-class-name class)
                (exwm-floating--unset-floating exwm--id)))
            floating-toggle-list))

  (add-hook 'exwm-manage-finish-hook
            #'enforce-floating-toggle-list)
#+END_SRC
** COMMENT Document viewer

~pdf-tools~ is a document viewer for emacs
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :config
    (pdf-loader-install))
#+END_SRC
** Image viewer
Emacs has an inbuilt image viewer ~image-mode~.
#+BEGIN_SRC emacs-lisp
  (require 'image-dimensions-minor-mode)

  (setq imagemagick-render-type 1 ; increase image scaling speed
        ;; exclude .gif files because I prefer to handle them with external programs
        image-file-name-extensions '("webp" "png" "jpeg" "jpg" "tiff" "tif" "xbm" "xpm" "pbm" "pgm" "ppm" "pnm" "svg"))

  (setq image-transform-resize nil)

  (defun image-transform-fit-to-width-or-height (&rest _)
    "Fit the current image to the shortest of width or height of
  the current window. This command has no effect unless Emacs is
  compiled with ImageMagick support."
    (interactive)
    (let ((image-transform-resize
           (let* ((size (image-size (image-get-display-property))))
             (if (> (/ (car size) (cdr size))
                    (/ (* 1.0 (window-width))
                       (* 1.0 (window-height))))
                 'fit-width
               'fit-height))))
      (image-toggle-display-image)))

  (defun me/image-transform-fit-to-height ()
    "Fit the current image to the height of the current window.
  This command has no effect unless Emacs is compiled with
  ImageMagick support."
    (interactive)
    (let ((image-transform-resize 'fit-height))
      (image-toggle-display-image)))

  (defun me/image-transform-fit-to-width ()
    "Fit the current image to the width of the current window.
  This command has no effect unless Emacs is compiled with
  ImageMagick support."
    (interactive)
    (let ((image-transform-resize 'fit-width))
      (image-toggle-display-image)))


  (general-def normal image-mode-map

    "R" #'image-transform-reset

    "W" #'me/image-transform-fit-to-height
    "w" #'me/image-transform-fit-to-width
    "o" #'image-transform-fit-to-width-or-height

    "p" #'image-previous-file
    "N" #'image-previous-file
    "n" #'image-next-file)

  (general-def normal '(image-mode-map image-dired-display-image-mode-map)
    "-" #'image-decrease-size
    "+" #'image-increase-size
    "=" #'image-increase-size

    "C-j" (lambda nil (interactive)
            (image-next-line 1))
    "C-k" (lambda nil (interactive)
            (image-previous-line 1))
    "j" (lambda nil (interactive)
          (image-next-line 10))
    "k" (lambda nil (interactive)
          (image-previous-line 10))
    "J" (lambda nil (interactive)
          (image-next-line 50))
    "K" (lambda nil (interactive)
          (image-previous-line 50))

    "C-h" (lambda nil (interactive)
            (image-backward-hscroll 1))
    "C-l" (lambda nil (interactive)
            (image-forward-hscroll 1))
    "h" (lambda nil (interactive)
          (image-backward-hscroll 20))
    "l" (lambda nil (interactive)
          (image-forward-hscroll 20))
    "H" (lambda nil (interactive)
          (image-backward-hscroll 100))
    "L" (lambda nil (interactive)
          (image-forward-hscroll 100)))
#+END_SRC
** EMMS
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :config
    (require 'emms-setup)
    ;; (require 'emms-player-mpd)
    (require 'emms-player-mpv)

    ;; (emms-default-players)
    (emms-all)
    (require 'emms-volume)
    (require 'emms-streams)
    (require 'emms-stream-info)
    (setq emms-player-seek-seconds 5
          emms-source-file-default-directory "~/Music/"
          emms-player-list '(emms-player-mpv)
          ;; emms-player-mpd-music-directory "~/Music"
          emms-info-functions '(emms-info-mp3info
                                emms-info-cueinfo
                                emms-info-opusinfo)
          emms-volume-change-function #'emms-volume-pulse-change
          emms-volume-change-amount 5
          emms-mode-line-format " | %s"
          emms-mode-line-mode-line-function #'emms-mode-line-playlist-current
          emms-stream-info-backend 'mplayer)

    (general-create-definer emms-key-def
      :prefix "s-m")

    (general-def 
      "<XF86AudioPrev>" 'emms-previous
      "<XF86AudioNext>" 'emms-next
      "<XF86AudioPlay>" 'emms-pause
      "<XF86AudioPause>" 'emms-pause
      "<XF86AudioStop>" 'emms-stop)

    (emms-key-def 'normal 
      "s-m" 'emms-pause
      "m" 'emms
      "b" 'emms-browse-by-album
      "r" 'emms-player-mpd-update-all-reset-cache))
#+END_SRC
*** Uncle Dave's Commands
Stolen from [[https://github.com/daedreth/UncleDavesEmacs#emms-with-mpd][UncleDavesEmacs]]
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connects to it and syncs the metadata cache."
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD Started!"))

  (defun mpd/kill-music-daemon ()
    "Stops playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed!"))

  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated!"))

  (emms-key-def 'normal
    "s" 'mpd/start-music-daemon
    "k" 'mpd/kill-music-daemon
    "u" 'mpd/update-database)
#+END_SRC
*** Other commands 
#+BEGIN_SRC emacs-lisp
  ;; from https://www.emacswiki.org/emacs/EMMS#toc36
  (defun my-emms-playlist-total-time-below-point ()
    "Calculates the total time taken for all the tracks currently in playlist and below point"
    (interactive)
    (let ((move-forward t)
          (total-playlist-time 0))
      (save-excursion 		
        (while move-forward
          (setq total-playlist-time (+ total-playlist-time (or (emms-track-get (emms-playlist-track-at (point)) 'info-playing-time) 0)))
          (forward-line 1)
          (setq move-forward (next-single-property-change (point) 'emms-track))))
      (setq total-hour-only (/ total-playlist-time 3600)
            total-minutes-only (/ (% total-playlist-time 3600) 60)
            total-seconds-only (% total-playlist-time 60))
      (message "Total time is %dh:%dm:%ds" total-hour-only total-minutes-only total-seconds-only)))

  (leader-key-def normal emms-playlist-mode-map
    "i" #'my-emms-playlist-total-time-below-point)
#+END_SRC
*** Helm EMMS
#+BEGIN_SRC emacs-lisp
  (use-package helm-emms
    :config
    ;; (setq helm-emms-dired-directories `(,me/music-directory))
    ;; (setq helm-emms-dired-directories nil)
    (defun helm-emms-sans-dired ()
      (interactive)
      (helm :sources '(helm-source-emms-files
                       helm-source-emms-streams)
            :buffer "*Helm Emms*"))

    (emms-key-def 'normal
      "," 'helm-emms))
#+END_SRC
** System package managment
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :straight t
    :config
    (setf (cdr
           (assoc
            'search
            (cdr
             (assoc
              'guix system-packages-supported-package-managers))))
          "~/.emacs.d/guix-search-full.sh"))

  (use-package helm-system-packages) ;; can manage packages across tramp
#+END_SRC
** IRC
*** ERC
#+BEGIN_SRC emacs-lisp
  (setq erc-track-position-in-mode-line 'after-modes
        ;;erc-mode-line-format "%S %a"
        erc-hide-list '("JOIN" "PART" "QUIT"))

  (general-def
    :states 'normal
    :keymaps 'erc-mode-map
    ;; go to prompt before append or insert line in comint mode
    "RET" #'erc-send-current-line
    "I" #'comint-style-insert-line
    "A" #'comint-style-append-line)

  ;; Bouncer
  (use-package znc
    :config
    (setq znc-servers `(("znc.fullmer.info" 5000 t
                         ((irc\.freenode\.net ,me/freenode-nick ,(me/znc-password)))))))
#+END_SRC
*** COMMENT Circe
#+BEGIN_SRC emacs-lisp
  (use-package circe
    :config
    (setq circe-format-self-say "<{nick}> {body}")

    (setq
     lui-time-stamp-position 'right-margin
     lui-time-stamp-format "%H:%M"
     lui-fill-type nil
     lui-track-bar-behavior 'before-switch-to-buffer)

    (enable-lui-track-bar)

    (add-hook 'lui-mode-hook 'my-lui-setup)
    (defun my-lui-setup ()
      (setq
       fringes-outside-margins t
       right-margin-width 5
       word-wrap t
       wrap-prefix "    "))


    (setq circe-network-options
          `(("Freenode"
             :tls nil
             :nick ,me/freenode-nick
             :nickserv-password me/nickserv-password))))
#+END_SRC
** Weather
Interface to wttr.in
#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :config
    (setq wttrin-default-cities '("Evanston")))
#+END_SRC
** Bluetooth interface
#+BEGIN_SRC emacs-lisp
  (use-package bluetooth
    :config
    (leader-key-def normal
                    "1" #'bluetooth-list-devices)
    (general-def normal bluetooth-mode-map
      "s" #'bluetooth-show-device-info
      "d" #'bluetooth-start-discovery
      "D" #'bluetooth-stop-discovery
      "R" #'bluetooth-remove-device
      "t" #'bluetooth-toggle-trusted
      "p" #'bluetooth-pair
      "c" #'bluetooth-connect
      "x" #'bluetooth-disconnect))
#+END_SRC
** COMMENT Bitwarden
Emacs interface to ~bitwarden-cli~ 
#+BEGIN_SRC emacs-lisp
  (use-package bitwarden
    :straight t (:host github :repo "seanfarley/emacs-bitwarden")
    :config
    (setq bitwarden-automatic-unlock (lambda ()
                                       (read-passwd "Password: "))))
#+END_SRC
* Helper functions
Various small functions which are evaluated before anything else in the file.
#+NAME: helper-functions
#+BEGIN_SRC emacs-lisp
  (require 'seq)

  (defun find-function-or-variable-at-point ()
    (interactive)
    (let ((sym (symbol-at-point)))
      (if (fboundp sym)
          (find-function-at-point)
        (find-variable-at-point))))

  (defvar buffer-number-regex (rx "<" (* (not (any "<"))) ">" string-end)
    "A regex to match that angle-bracketed number at the end of a
    buffer name that represents that it is a duplicate of another
    buffer.")

  (defun get-buffer-number (buffer-name)
    "Gets the number in angle brackets from the name of a buffer"
    (save-match-data
      (when (string-match buffer-number-regex buffer-name)
        (let ((val (match-string 0 buffer-name)))
          (string-to-number (substring val 1 (1- (length val))))))))

  (defun set-buffer-number (buffer-name new-number)
    "Return a new string with a different number in angle brackets at the end."
    (let ((new-number-string (concat "<" (number-to-string new-number) ">")))
      (save-match-data
        (if (string-match buffer-number-regex buffer-name)
            (replace-match new-number-string t t buffer-name)
          (concat buffer-name new-number-string)))))

  (defun auto-mode-add (mode &rest filenames)
    "Add a number of file name patterns to the given mode in
    auto-mode-alist"
    (mapcar (lambda (name)
              (add-to-list 'auto-mode-alist
                           `(,name . ,mode)))
            filenames))

  (defun remove-keyword-args (list)
    "Remove keyword arguments from the given list"
    (car (general--remove-keyword-args list)))

  (defun earmuffs (string)
    "Add *earmuffs* to the given string. This represents the name
      of a buffer which is not associated with a file."
    (concat "*" string "*"))

  (defun reload-init-file ()
    "Load all elisp from 'user-init-file'."
    (interactive)
    (load-file user-init-file))

  (defun dotfiles (path)
    "Return path relative to the dotfiles directory"
    (concat me/dotfiles path))

  (defun actually-kill-this-buffer ()
    "Kills the current buffer, unlike ~kill-this-buffer~ 
  which does not always do that."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun windows-right ()
    (interactive)
    (if (> (length (window-list)) 1)
        (evil-window-move-far-right)
      (progn
        (split-window-right)
        (evil-window-move-far-right)
        (other-window 1)
        (next-buffer)
        (other-window 1))))

  (defun windows-left ()
    (interactive)
    (if (> (length (window-list)) 1)
        (funcall-interactively
         #'evil-window-move-far-left)
      (progn
        (split-window-right)
        (other-window 1)
        (next-buffer)
        (other-window 1))))

  (defun move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (defun move-line-up ()
    "Move the current line up."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move the current line down."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (defun disable-most-recent-theme ()
    (interactive)
    (disable-theme (car custom-enabled-themes)))

  (defun switch-theme (theme)
    "load a theme interactively while disabling the current one."
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapcar 'symbol-name
                                       (custom-available-themes))))))
    (disable-most-recent-theme)
    (load-theme theme t))

  (defun string-represents-integer-p (string)
    "Truthy if string is a representation of an integer (leading
  zeroes allowed), nil otherwise."
    (string-match-p "\\`[0-9][0-9]*\\'" string))

  (defun string-to-integer-or-nil (string)
    "If the string represents an integer, return that integer,
  otherwise return nil."
    (when (string-represents-integer-p string)
      (string-to-number string)))

  (defun circular (list)
    "Return a copy of the given list where the last element points
  to the first, rather than to nil."
    (when list
      (let ((new-list (copy-list list)))
         (setf (cdr (last new-list))
                  new-list))))

  (defun cd*r (n list)
    "n cdrs of list. recursive."
    (if (<= n 0)
        list
      (cd*r (1- n) (cdr list))))

  (defun add-to-env (env val)
    (setenv env (concat (getenv env) val)))

  (cl-defun add-to-path (paths &optional (env "PATH") (seperator ":"))
    (dolist (path (split-string paths seperator))
      (unless (find-if (lambda (s)
                         (string= s path))
                       (split-string (getenv env) seperator))
        (add-to-env env (concat seperator paths)))))

  (cl-defun remove-from-path (paths &optional (env "PATH") (seperator ":"))
    (let ((new-path (getenv env)))
      (dolist (path (split-string paths seperator))
        (setq new-path (reduce (lambda (a b)
                                 (if a (if b (concat a seperator b) a)
                                   (if b b "")))
                               (mapcar (lambda (s)
                                         (if (string= s path) nil s))
                                       (split-string new-path seperator)))))
      (setenv env new-path)))

  (defun lua-path+ (val)
    (add-to-path val
                 "LUA_PATH"
                 ";"))

  (defun lua-cpath+ (val)
    (add-to-path val
                 "LUA_CPATH"
                 ";"))

  ;;;; Macrology

  (defmacro aif (cond then &rest else)
    `(let ((it ,cond))
       (if it
           ,then
         ,@else)))

  (defmacro dobody (spec &rest body)
    "A tool for creating domain specific languages.

  Return a progn which contains the collected results of
  evaluating BODY with VAR bound to each car from LIST, in turn.

  \(fn (VAR LIST) BODY...)"
    (unless (consp spec)
      (signal 'wrong-type-argument (list 'consp spec)))
    (unless (= 2 (length spec))
      (signal 'wrong-number-of-arguments (list '(2 . 2) (length spec))))
    (list 'backquote
          (list 'progn
                (list backquote-splice-symbol
                      `(mapcar (lambda (,(cl-first spec))
                                 (progn ,@body))
                               ,(cl-second spec))))))

  ;; todo: add support for kwargs which act as uniform values for the
  ;; entire multi-macro call.
  (defmacro define-multi-macro (name macro num-parameters &optional documentation)
    `(defmacro ,name (&rest args)
       ,(concat documentation
                (format "For each %d arguments, call `%s' with those arguments."
                        num-parameters macro))
       (dobody (elt (seq-partition args ,num-parameters))
               `(,',macro ,@elt))))

  (defmacro define-multi-macro-clauses (name macro &optional documentation)
    `(defmacro ,name (&rest clauses)
       ,(concat documentation
                (format "\n\nFor clause syntax, look at the documentation of `%s'.

  Example clauses:

  (ARG1 ARG2 :KEYWORD1 VAL1 :KEYWORD2 VAL2)

  (ARG BODY1
       BODY2)

  The clause \"(ARG)\" can be written as \"ARG\".
  " macro))
       (dobody (clause clauses)
               `(,',macro ,@(if (consp clause)
                                clause
                              (list clause))))))
#+END_SRC
