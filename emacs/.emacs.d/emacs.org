#+TITLE: Adrian's Emacs Configuration
#+AUTHOR: Adrian Fullmer

* Startup
** Enable Lexical Scope
#+PROPERTY: header-args:emacs-lisp :lexical t
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC

** Garbage Collector Threshold
 took some advice from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]] for faster startup times. 
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1))

  (defun lex-p ()
    "Return t if lexical binding is in effect."
    (let (lex
      _lex-p)
      (let ((lex t))
        (setq _lex-p
          (lambda ()
            lex)))
      (funcall _lex-p)))
#+END_SRC

** Filename Handlers
Startup time can also be improved by disabling the
~file-name-handler-alist~, as it will not be needed during startup.
#+BEGIN_SRC emacs-lisp
(defvar temp-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

(add-hook 'emacs-startup-hook
  (setq file-name-handler-alist temp-file-name-handler-alist))
#+END_SRC

** Load secrets
#+BEGIN_SRC emacs-lisp
  (let ((secret.el (expand-file-name ".secrets.el" user-emacs-directory)))
    (when (file-exists-p secret.el)
      (load secret.el)))
#+END_SRC
** COMMENT Load non-secret environment variables
#+BEGIN_SRC emacs-lisp
;; (require 'my-env)
#+END_SRC
** Constants
#+BEGIN_SRC emacs-lisp
  ;; Directory containing my dotfiles.
  (defconst me/dotfiles "~/dotfiles/")

  (defconst me/project-directory "~/Code/")

  (defconst me/music-directory "~/Music/")

  (defconst me/guix-config-dir "~/.config/guix/system")
#+END_SRC

** Load Path
I extend the load path from my dotfiles directory for tentative
packages.
#+BEGIN_SRC emacs-lisp
  (push "~/.emacs.d/my-packages/" load-path)
  (push "~/.emacs.d/emacs-wiki/" load-path)
  (push "~/Code/elisp/load/" load-path)
#+END_SRC
** Packages

#+BEGIN_SRC emacs-lisp
  ;;(require 'subr-x)
  (require 'package)

  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

  (defun which-linux-distribution ()
    "from lsb_release"
    (interactive)
    (when (eq system-type 'gnu/linux)
      (string-trim (shell-command-to-string "lsb_release -si"))))

  (when (string-equal "Ubuntu" (which-linux-distribution))
    (setq use-package-always-ensure t))
#+END_SRC
** COMMENT Straight.el
Straight.el A functional alternative to package.el.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)

  (setq straight-use-package-by-default t)
#+END_SRC
* Load Utilities
#+BEGIN_SRC emacs-lisp :noweb tangle
<<utilities>>
#+END_SRC
* Evil
These are my settings for the Evil, the Vim emulator.
#+BEGIN_SRC emacs-lisp
  ;; settings for evil-collection integration
  (setq evil-want-keybinding nil)
  (setq evil-want-integration t)
  (setq evil-want-minibuffer t)

  (use-package evil
    :config
    (evil-mode 1)
    ;; The undo tree sometimes deletes undo data, I prefer to just disable it.
    (require 'undo-tree)
    (global-undo-tree-mode -1)

    ;; (setq evil-search-module 'isearch)

    ;; ex commands
    (eval-after-load 'evil-ex
      '(progn
         ;; Sometimes I don't release shift fast enough
         (evil-ex-define-cmd "W[rite]" 'evil-write)
         (evil-ex-define-cmd "Wa" 'evil-write-all)
         (evil-ex-define-cmd "Q[uit]" 'evil-quit)
         (evil-ex-define-cmd "Qa" 'evil-quit-all))))
#+END_SRC
** Evil space

#+BEGIN_SRC emacs-lisp
  (use-package evil-space
    :ensure t
    :config
    (setq evil-space-next-key (kbd ";"))
    (evil-space-mode +1))
#+END_SRC
** Evil commentary
#+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :config
    (add-hook 'prog-mode-hook #'evil-commentary-mode)
    (define-key evil-outer-text-objects-map "f" #'evil-a-defun)
    (with-eval-after-load 'general
      (general-def 'evil-commentary-mode-map
        "s-/" nil)
      (general-def '(visual normal) 'evil-commentary-mode-map
        "gc" #'evil-commentary)))
#+END_SRC
** Evil collection
This provides ~evil~ friendly keybindings for a variety of modes.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :ensure t ;; TODO
    :init
    (setq evil-want-keybinding nil)
    :after evil
    :custom (evil-collection-company-use-tng nil)
    :config
    ;; (setq evil-collection-term-sync-state-and-mode-p nil)
    (evil-collection-init))
#+END_SRC
** COMMENT Evil easymotion
This package helps with the issue of not knowing how many times to
repeat an ~evil~ motion by providing a tag at the location of
each possible motion result.
#+BEGIN_SRC emacs-lisp
  (use-package evil-easymotion
    :ensure t
    :config
    (evilem-default-keybindings "C-M-S-~"))
#+END_SRC
** Evil surround
This provides action to surround a region with delimiters 
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+END_SRC
** COMMENT Evil snipe
At one point I used ~evil-snipe~, a tool for jumping to pairs of characters.
#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :ensure t
  :after evil-easymotion
  :config
  (evilem-define (kbd "SPC s") 'evil-snipe-s))
#+END_SRC
** The creation of text objects
This macro was copied from [[https://stackoverflow.com/a/22418983/4921402][this]] Stackoverflow thread, and facilitates
the creation of simple ~evil~ text objects.
#+BEGIN_SRC emacs-lisp
  (defmacro define-and-bind-regex-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))

  (define-multi-macro simple-text-objects define-and-bind-regex-text-object 4)
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
  (simple-text-objects
   "pipe" "|" "|" "|"
   "slash" "/" "/" "/"
   "sexpr" "i" "(" ")")

#+END_SRC

More complex text objects are defined manually:
#+BEGIN_SRC emacs-lisp
  (evil-define-text-object evil-a-defun (count &optional beg end type)
    "Text object for a top level form (language agnostic)"
    (save-excursion
      (mark-defun)
      (list (point) (mark))))
  (define-key evil-outer-text-objects-map "f" #'evil-a-defun)

  (evil-define-text-object evil-entire-buffer (count &optional beg end type)
    "Text object for the entire buffer"
    (list 1 (1+ (buffer-size))))
  (define-key evil-outer-text-objects-map "a" #'evil-entire-buffer)
#+END_SRC
* Keybindings and Commands
** General.el
I mainly use the the package ~general~ to define keybindings and
commands. 
#+BEGIN_SRC emacs-lisp
  (use-package general)
#+END_SRC
It integrates well with ~evil~.
#+BEGIN_SRC emacs-lisp
  (general-evil-setup)
#+END_SRC
** God mode
An alternative modal editing style which provides a compliment to ~evil-mode~. 

#+BEGIN_SRC emacs-lisp
  (use-package god-mode
    :config
    (general-def 'normal
      "," #'god-execute-with-current-bindings)
    (with-eval-after-load 'exwm
      (general-def exwm-mode-map
        "s-," #'god-execute-with-current-bindings)))
#+END_SRC
** Hydra.el
~hydra~ creates miniature modes to reduce repetitive keybindings.
#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC
** Conditional key translations
The equivalent of Vim noremaps are Emacs key translations. They apply
globally, so I created some macros to make key translations which apply
conditionally. They are inspired by [[https://www.emacswiki.org/emacs/Evil#toc14][this]].
#+BEGIN_SRC emacs-lisp
  ;; does not require lexical scope
  (defmacro make-conditional-key-translation (key-from key-to translate-keys-p)
    "Make a Key Translation such that if the translate-keys-p function returns true,
     key-from translates to key-to, else key-from translates to itself. "
    `(define-key key-translation-map (kbd ,key-from)
      (lambda (prompt)
        (if (,translate-keys-p) (kbd ,key-to) (kbd ,key-from)))))

  (define-multi-macro make-conditional-key-translations
                      make-conditional-key-translation
                      3)

  (defmacro inoremap-single (from to)
    `(make-conditional-key-translation ,from ,to evil-insert-state-p))
  (define-multi-macro inoremap inoremap-single 2)

  (defmacro noremap-single (from to)
    `(make-conditional-key-translation ,from ,to (lambda nil t)))
  (define-multi-macro noremap noremap-single 2)
#+END_SRC
** COMMENT All modes
#+BEGIN_SRC emacs-lisp
  ;; (noremap "9" "("
  ;;            "0" ")"
  ;;            "(" "9"
  ;;            ")" "0")
#+END_SRC
** Normal Mode
These are normal mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
  (general-nmap ; 'override
    ;; "C-u" 'evil-scroll-up

    "C--" 'helm-do-ag-project-root
    "C-=" 'helm-do-ag
    ;; Move a line of text using ALT+[jk]
    "M-j" 'move-line-down
    "M-k" 'move-line-up
    ;; "/" 'evil-ex-search-forward
    ;; "t" nil
    ;; "q" nil
    "g r" 'revert-buffer)


#+END_SRC
** Visual Mode
These are visual mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
  (general-vmap 'override
    ;; Move a visual block of text using ALT+[jk]
    "M-k" (kbd ":move '< -2 RET `> my `< mz gv`yo`z")
    "t" 'evil-avy-goto-char
    "q" 'evil-avy-goto-subword-1)
#+END_SRC
** Visual line mode macro

#+BEGIN_SRC emacs-lisp
  (defmacro my-visual-line-mode-rebind (mode)
    `(general-def '(normal visual) ,mode
       ;; Make evil-mode up/down operate in screen lines instead of logical lines
       "j" #'evil-next-visual-line
       "k" #'evil-previous-visual-line
       "0" #'evil-beginning-of-visual-line
       "$" #'evil-end-of-visual-line
       "." #'evil-repeat-visual-line
       "^" #'evil-first-non-blank-of-visual-line

       "g j" #'evil-next-line
       "g k" #'evil-previous-line
       "g 0" #'evil-beginning-of-line
       "g $" #'evil-end-of-line
       "g ^" #'evil-first-non-blank))
#+END_SRC
** COMMENT Insert Mode
These are insert mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
  ;; (inoremap "." "-"
  ;;           "-" ".")
#+END_SRC
** Leader
These are functions for defining a tree of keybindings behind a single
leader key.
*** Definitions
First ~which-key~ must be loaded early
#+BEGIN_SRC emacs-lisp :noweb tangle
<<which-key>>
#+END_SRC

then I define the leader keys,
#+BEGIN_SRC emacs-lisp
  (cl-eval-when (compile load eval)
    (defconst leader-key "SPC")
    (defconst alt-leader-key "SPC SPC"))

  (general-create-definer no-super-leader-key-def
    :prefix leader-key)

  (general-create-definer super-leader-key-def
    :prefix (concat "s-" leader-key))

  (defmacro leader-key-def (&rest args)
    `(progn
       (no-super-leader-key-def ,@args)
       (super-leader-key-def ,@args)
       ;; ,(when (featurep 'exwm)
       ;;    `(super-leader-key-def ,@args))
       ))

  (general-create-definer alt-leader-key-def
    :prefix alt-leader-key)
#+END_SRC

then some helper functions to create functions to create subleader
keybindings through ~general-create-definer~. Key-based replacements are
also generated for [[#which-key][ ~which-key~ ]].
#+BEGIN_SRC emacs-lisp
  (cl-defun leader-prefix (str &optional (prefix leader-key))
    "Append a leader key to the given string"
    (concat prefix " " str))

  (cl-defmacro define--subleader (key name general-definer-name &key (leader leader-key))
    "Both create a general definer, and a which-key replacement for the given subleader."
    (let ((no-super-name (intern (concat "no-super-"
                                         (symbol-name general-definer-name))))
          (super-name (intern (concat "super-"
                                      (symbol-name general-definer-name)))))
      `(progn
         (which-key-add-key-based-replacements
           (leader-prefix ,key ,leader) ,name)

         (which-key-add-key-based-replacements
           (leader-prefix ,key ,(concat "s-" leader)) ,name)

         (general-create-definer ,no-super-name
           :prefix (leader-prefix ,key ,leader))

         (general-create-definer ,super-name
           :prefix (leader-prefix ,key ,(concat "s-" leader)))

         (defmacro ,general-definer-name (&rest args)
           (let ((no-super-name ',no-super-name)
                 (super-name ',super-name))
             `(progn
                (,no-super-name ,@args)
                (,super-name ,@args)))))))


  ;; the format for the input of this function is inspired by general's
  ;; easy to use functions.
  (cl-defmacro define-subleader (&rest args &key (leader leader-key) &allow-other-keys)
    "Both create a general definer, and a which-key replacement for
  the given subleader. Accepts arguments in threes with no
  delimiter."
    `(progn ,@(mapcar (lambda (elt)
                        `(define--subleader ,@elt :leader ,leader))
                      (seq-partition (remove-keyword-args args) 3))))
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
  (define-subleader
    "e" "eval" eval-key-def
    "s" "start" start-key-def
    "x" "xpand" xpand-key-def
    "p" "project" project-key-def)
#+END_SRC
*** Normal Mode Leader Bindings
#+BEGIN_SRC emacs-lisp
  (defun bury-evil-buffer ()
    (interactive)
    (bury-buffer)
    ;; (call-interactively #'evil-buffer)
    )

  (defun me/helm-buffer ()
    (interactive)
    (call-interactively #'helm-mini))

  (leader-key-def 'normal 'override
                  "u" 'universal-argument
                  "w" 'actually-kill-this-buffer    ; ",w" to kill buffer not window.
                  "q" 'evil-delete-buffer   ; ",q" to kill buffer and window. equivalent of :bd<cr>.
                  "a" #'bury-evil-buffer
                  "b" 'me/helm-buffer   ; ",b" to switch buffers.
                  "f" 'helm-find-files    ; ",f" to find file (replace :e)
                  "h" 'help
                  "O" 'helm-do-ag-this-file 
                  "o" 'helm-occur 
                  "8" 'helm-imenu-in-all-buffers
                  ";" 'eval-expression
                  "r" 'evil-surround-edit
                  "R" 'evil-Surround-edit
                  ;; "RET" (kbd ":noh")
                  )

  (leader-key-def 'normal
                  "i" 'helm-imenu)
#+END_SRC
*** Visual Mode Leader Bindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'visual 'override
                  "O" 'helm-do-ag-this-file
                  "o" 'helm-occur)
#+END_SRC
** Shell Commands
These are M-x commands for common shell commands such as reboot.
#+BEGIN_SRC emacs-lisp
  (defmacro define-shell-command (function-name &optional command)
    (let ((command (or command (symbol-name function-name))))
      `(defun ,function-name ()
         ,(format "Run shell command '%s'" command)
         (interactive)
         (shell-command ,command))))

  (define-multi-macro-clauses define-shell-commands define-shell-command)

  ;; (define-shell-commands
  ;;   reboot
  ;;   (suspend "systemctl suspend"))


  ;; (fmakunbound 'reboot)
#+END_SRC
** Other Commands
This is A command to configure my operating system
#+BEGIN_SRC emacs-lisp
  (defun gconf ()
    (interactive)
    (or (find-file me/guix-config-dir)
        (find-file "/sudo::/etc/config.scm")
        (error "guix config not found")))
#+END_SRC

This is a command to configure emacs
#+BEGIN_SRC emacs-lisp
  (defun econf () (interactive) (find-file "~/.emacs.d/emacs.org"))
#+END_SRC

This is a command to create a new scratch buffer
#+BEGIN_SRC emacs-lisp
  (defun scratch ()
    (interactive)
    (let* ((default-directory "~/")
           (buffer (generate-new-buffer "*scratch*")
                   ;; (or (get-buffer "*scratch*")
                   ;;     (generate-new-buffer "*scratch*"))
                   ))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (funcall initial-major-mode))))
#+END_SRC
* User Interface
** Splash screen
I disable the splash screen and message.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t
        initial-scratch-message nil)
#+END_SRC
*** Scratch buffer
Set the initial mode in the scratch buffer to emacs.
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode #'lisp-interaction-mode)
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp
  (defvar my-default-font-pixelsize (* 29 (/ (get-dpi) 276)))
  ;; (add-to-list 'default-frame-alist
  ;; 	     `(font . ,(format
  ;; 			"DejaVu Sans Mono:pixelsize=%d:foundry=PfEd:weight=normal:slant=normal:width=normal:scalable=true"
  ;; 			my-default-font-pixelsize)))
  ;; (add-to-list 'default-frame-alist `(font . "Iosevka"))

  ;; (use-package unicode-fonts
  ;;   :ensure t
  ;;   :config
  ;;   (unicode-fonts-setup))
#+END_SRC
** Mode line
*** Delight
Delight is a package which is used to hide unnecessary mode-line
blurbs.
#+BEGIN_SRC emacs-lisp
  (use-package delight 
    :config
    (delight '((eldoc-mode nil "eldoc")
               (auto-revert-mode nil "autorevert")
               (org-src-mode nil "org-src")
               (org-indent-mode nil "org"))))
#+END_SRC
*** Mode Line Format
#+BEGIN_SRC emacs-lisp
  (setq-default mode-line-format
                '("%e" mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  mode-line-buffer-identification
                  "   " mode-line-position
                  evil-mode-line-tag
                  (vc-mode vc-mode)
                  "  " mode-line-modes
                  mode-line-end-spaces))

  (with-eval-after-load 'exwm
    (defvar me/exwm-mode-line-format nil)
    (setq me/exwm-mode-line-format 
          '("%e"
            mode-line-front-space
            mode-line-frame-identification
            mode-line-buffer-identification
            "  "
            mode-line-end-spaces))

    (defun exwm-mode-line-init ()
      (setq mode-line-buffer-identification (propertized-buffer-identification "%12b"))
      (setq mode-line-format me/exwm-mode-line-format))

    (add-hook 'exwm-mode-hook #'exwm-mode-line-init))

#+END_SRC
*** Shorten mode-line buffer names
This sets a limit of 70 characters for the display of buffern names in
the mode line. 
#+BEGIN_SRC emacs-lisp
  (setq-default mode-line-buffer-identification (list -70 (propertized-buffer-identification "%12b")))
#+END_SRC
*** Minibuffer line
Package to use the minibuffer in the manner of the mode line.
#+begin_src emacs-lisp
  (use-package minibuffer-line
    :after erc
    :config
    ;; (defvar minibuffer-line-separator " | ")
    ;; (defun minibuffer-line--update ()
    ;;   (with-current-buffer minibuffer-line--buffer
    ;;     (erase-buffer)
    ;;     (insert (format-mode-line minibuffer-line-format 'mode-line-inactive))))
    (setq minibuffer-line-format '("%e " display-time-string
                                   battery-mode-line-string emms-mode-line-string
                                   emms-playing-time-string " "))
    ;; (setq global-mode-string '("" display-time-string
    ;;                            battery-mode-line-string emms-mode-line-string
    ;;                            emms-playing-time-string erc-modified-channels-object))
    (setq minibuffer-line-refresh-interval 0.5)
    (setq erc-mode-line-format " | ERC: %S %a")
    (setq display-time-format "%R %d %b")
    (setq display-time-default-load-average nil)
    (display-time-mode +1)
    (setq battery-load-critical 25)
    (setq battery-load-low 40)
    (setq battery-mode-line-format " | %p%% %B %t")
    (display-battery-mode +1)
    (minibuffer-line-mode +1)


    (defun erc-modified-channels-label-advice (fn &rest args)
      (concat " | ERC:" (apply fn args)))

    (advice-add 'erc-modified-channels-object
                :around
                'erc-modified-channels-label-advice))
#+end_src
** Helm
~helm~ is a framework for incremental narrowing searching interfaces
which integrates well across Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :delight
    :bind (("M-x" . helm-M-x))
    :config
    (helm-mode t)

    (setq helm-buffer-max-length 120
          helm-display-buffer-default-height nil
          helm-show-completion-display-function #'helm-show-completion-default-display-function
          helm-follow-mode-persistent nil
          helm-window-prefer-horizontal-split t
          helm-window-show-buffers-function 'helm-window-mosaic-fn
          helm-split-window-default-side 'same
          helm-ff-cache-mode nil)

    (defun me/helm-fix-insert-state-keys ()
      (setq evil-insert-state-local-map (make-keymap))
      (define-key evil-insert-state-local-map (kbd "C-n") #'helm-next-line)
      (define-key evil-insert-state-local-map (kbd "C-p") #'helm-previous-line))
    ;; (setq-local evil-insert-state-map (make-keymap ))

    (add-hook 'helm--minor-mode-hook
              #'me/helm-fix-insert-state-keys)

    ;; Refresh helm-top
    (helm-top-poll-mode 1)

    ;; redefine helm-persistent-action-display-window to split right by
    ;; default instead of left. (not configurable, sadly.)
    (cl-defun helm-persistent-action-display-window (&key split)
      "Return the window that will be used for persistent action.
  If SPLIT is `t' window is split in persistent action, if it has the
  special symbol `never' don't split, if it is `nil' normally don't
  split but this may happen in case of dedicated-windows or unsuitable
  window to display persistent action buffer."
      (with-helm-window
        (let (prev-win cur-win)
          (setq helm-persistent-action-display-window
                (cond ((and (window-live-p helm-persistent-action-display-window)
                            (not (member helm-persistent-action-display-window
                                         (get-buffer-window-list helm-buffer))))
                       helm-persistent-action-display-window)
                      ((and helm--buffer-in-new-frame-p helm-initial-frame)
                       (with-selected-frame helm-initial-frame (selected-window)))
                      ((and split (not (eq split 'never))) (split-window nil nil 'right))
                      ;; Fix Issue #2050 with dedicated window.
                      ((and (window-dedicated-p
                             (setq prev-win (previous-window (selected-window) 1)))
                            (not (eq split 'never)))
                       (with-helm-after-update-hook
                         (and (window-live-p helm-persistent-action-display-window)
                              (delete-window helm-persistent-action-display-window)))
                       ;; If next-window is usable use it, otherwise split
                       ;; the helm window.
                       (let ((nw (next-window (selected-window) 1)))
                         (if (eql nw prev-win) (split-window nil nil 'right) nw)))
                      ((window-dedicated-p
                        (setq cur-win (get-buffer-window helm-current-buffer)))
                       (previous-window (selected-window) 1))
                      (cur-win)
                      (t prev-win)))))))
#+END_SRC
*** Helm ag
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :config
    (setq helm-ag-insert-at-point 'symbol)
    (setq helm-ag-base-command "ag --nocolor --nogroup"))
#+END_SRC
*** COMMENT Extending helm-highight-buffers
*** COMMENT Helper functions
#+BEGIN_SRC emacs-lisp
  (defun helm-rec-find-directory-old (&optional starting-directory)
    (interactive)
    (let ((default-directory (or starting-directory default-directory)))
      (find-file
       (helm :sources (helm-build-sync-source "directories"
                        :candidates (lambda ()
                                      (split-string
                                        (shell-command-to-string "find . -type d -not -path '*/\.*'") "\n" t))
                        :fuzzy-match t)
             :prompt "Open directory: "
             :buffer "*helm find directory*"))))

  (defun rec-find-directory (&optional starting-directory)
    (interactive)
    (let ((default-directory (or starting-directory default-directory)))
      (find-file
       (completing-read "Open directory: "
                        (split-string (shell-command-to-string "find . -type d") "\n" t)))))

  (defun helm-rec-find-directory ()
    (interactive)
    (helm-find (list "-type d -not -path '*/\.*'")))
#+END_SRC
** Hideshow
~hideshow~ mode provides vim-like folds.
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'hs-minor-mode)
(delight 'hs-minor-mode nil "hideshow")
#+END_SRC
** Prettify Symbols
This changes the appearance of certain strings in the buffer.
#+BEGIN_SRC emacs-lisp
  (setq prettify-symbols-alist
        '(("lambda" . 955) ; Replace instances of the word lambda with λ
          ))
  (global-prettify-symbols-mode 1)
#+END_SRC
** Disable Unnecessary UI elements
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
(add-to-list 'default-frame-alist
             '(vertical-scroll-bars . nil))
#+END_SRC
** Files and backups
Don't make backups.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC
Save cursor position in a file between sessions.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
** Line and Column numbers
Display them both in the mode line, and show line number on the side
of the screen in ~prog-mode~.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)

  (leader-key-def 'normal ; a keybinding to toggle line numbers
    "l" #'display-line-numbers-mode)

  (setq column-number-mode t)
#+END_SRC
** Tabs and Indentation
I use 4 space indentation by default.
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 8
                indent-tabs-mode nil)
#+END_SRC
** Line wrap
Do not truncate lines.
#+BEGIN_SRC emacs-lisp
  (setq truncate-lines nil)
#+END_SRC

Do not show visual-lines-mode (word wrap mode) in the mode line
#+BEGIN_SRC emacs-lisp
  (delight 'visual-line-mode nil t)
#+END_SRC
** Start frame maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC
** Confirmation
Type =y= or =n=, not =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Adaptive Cursor Width
Makes the cursor the full width of the current character.
#+BEGIN_SRC emacs-lisp
  (setq x-stretch-cursor t)
#+END_SRC
** COMMENT Clipboard
Enable vim-like clipboard. This puts text copied from programs other
than emacs into the "+" register.
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard nil)
#+END_SRC
** Delimiters
*** Electric pair mode
Close delimiters automatically as I write.
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t) 

  (defun local-disable-electric-pair-mode ()
    (electric-pair-local-mode -1))
#+END_SRC
*** Matching parens
Highlight the parentheis whose pair is under the point.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 0.125)
  (setq show-paren-delay 0
        show-paren-style 'parenthesis)
#+END_SRC
*** Highlight parentheses
Highlight the nearest outer parentheses. Thanks to [[https://stackoverflow.com/questions/34846531/show-parentheses-when-inside-them-emacs][this]] thread.
#+BEGIN_SRC emacs-lisp
  (require 'lispyville)

  (defun show-enclosing-paren-advice (fn)
    "Highlight enclosing parens."
    (if lispyville-mode
        (cond ((looking-at-p "\\s(") (funcall fn))
              (t (save-excursion
                   (ignore-errors (backward-up-list))
                   (funcall fn))))
      (funcall fn)))

  (advice-add 'show-paren-function
              :around
              #'show-enclosing-paren-advice)
#+END_SRC
** Ediff
Don't make a new frame for ediff.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
** Which-key
This plugin shows the available keys after a partially completed
key command. ~which-key~ key replacements are generated [[#leader][here]].
#+NAME: which-key
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package which-key
    :delight
    :after delight
    :config
    (delight 'which-key-mode "" t)
    (which-key-mode nil))
#+END_SRC
*** Prefix command completion
From [[https://with-emacs.com/posts/prefix-command-completion/][this blog post]], offer compltion of key prefix candidates in the
which-key buffer via the prefix-help-command.
#+BEGIN_SRC emacs-lisp
  (defun which-key-M-x-prefix+ (&optional _)
    "Completing read and execute command from current prefix map.

  This command can be used as `prefix-help-command'.

  The optional argument is ignored and only for compatability with
  `which-key-C-h-dispatch' so this command can be bound in
  `which-key-C-h-map', too."
    (interactive)
    (let* ((evs (if (which-key--current-prefix)
                    (which-key--current-key-list)
                  (butlast (append (this-command-keys-vector) nil))))
           (key (apply #'vector evs))
           (map (key-binding key)))
      (which-key--execute-binding+ map (key-description key))))

  (defun which-key--execute-binding+ (map &optional prefix)
    "Completing read command from MAP and execute it.

  If PREFIX is given it should be a key description which will be
  included in the prompt."
    (let ((cmd (which-key--completing-read-cmd+ map prefix)))
      (when (commandp cmd)
        (which-key--execute-cmd+ cmd))))

  (defun which-key--completing-read-cmd+ (map &optional prefix)
    "Completing read command from MAP.

  Include PREFIX in prompt if given."
    (which-key--hide-popup-ignore-command)
    (let* ((desc
            (completing-read
             (if prefix
                 (format "Execute (%s): " prefix)
               "Execute: ")
             (mapcar #'which-key--completing-read-format+
                     (which-key--get-keymap-bindings map 'all)))))
      (intern (car (split-string desc)))))

  (defun which-key--execute-cmd+ (cmd)
    "Execute command CMD as if invoked by key sequence."
    (setq prefix-arg current-prefix-arg)
    (setq this-command cmd)
    (setq real-this-command cmd)
    (command-execute cmd 'record))

  (defun which-key--completing-read-format+ (bnd)
    "Format binding BND for `completing-read'."
    (let* ((key (car bnd))
           (cmd (cdr bnd))
           (desc (format "%s (%s)" cmd
                         (propertize key 'face 'which-key-key-face))))
      (let ((which-key-show-docstrings t))
        (which-key--maybe-add-docstring
         (format "%-50s" desc) cmd))))

  (setq prefix-help-command
        #'which-key-C-h-dispatch)

  ;; (add-to-list 'helm-completing-read-handlers-alist
  ;;              nil)

  ;; (setq prefix-help-command #'which-key-M-x-prefix+)
  (general-def which-key-C-h-map
    "C-h" #'which-key-M-x-prefix+)
#+END_SRC
** Help
Keybindings for help mode
#+BEGIN_SRC emacs-lisp
  (general-nmap help-mode-map 
    "H" #'help-go-back
    "L" #'help-go-forward)
#+END_SRC
** COMMENT Beacon
Highlight the cursor when switching buffers.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :delight
    :config
    (beacon-mode 1))
#+END_SRC
** File navigation
I prefer to follow symbolic links under version control.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC
*** COMMENT Alt-tab buffer navigation
While emacs is missing key raised events, alt-tab style behavior can
still be replicated with a hydra with a timeout
(broken)
#+BEGIN_SRC emacs-lisp
  (lexical-let (blist length-blist)

    (defun buffer-switchable (buffer)
      (with-current-buffer buffer
        (not (or (minibufferp) ; dont switch to minibuffer
                 (get-buffer-window) ; or a buffer which is already visible
                 exwm--floating-frame ; or an exwm floating buffer
                 (and exwm--id ; if this is an exwm buffer
                      ;; don't switch if we are neither allowed to
                      ;; switch to exwm buffers in other frames, nor can
                      ;; see exwm buffers in other frames, unless the
                      ;; exwm buffer's frame is the current one.
                      (not (or (and exwm-workspace-show-all-buffers
                                    exwm-layout-show-all-buffers)
                               (eq (selected-frame) exwm--frame))))))))

    (defun buffer-history-delta (delta)
      (assert (or (= delta 1)
                  (= delta -1)))
      (setq blist (cd*r (if (minusp delta)
                            (+ length-blist delta)
                          delta)
                        blist))
      (if (buffer-switchable (car blist))
          ;(display-buffer-same-window (car blist) (list))
          (switch-to-buffer (car blist) t t)
        (buffer-history-delta delta)))

    (defun update-buffer-history ()
      (switch-to-buffer (current-buffer)))

    (general-def
     "M-<tab>" (lambda ()
                 (interactive)
                 (setq length-blist (length (buffer-list)))
                 (setq blist (circular (buffer-list)))
                 (buffer-history-delta 1)
                 (hydra-buffer-history/body)))

    (defhydra hydra-buffer-history (:timeout 2
                                             :post (update-buffer-history))
      "Buffer history: "
      ("M-<tab>" (buffer-history-delta 1))
      ("M-<S-iso-lefttab>" (buffer-history-delta -1))))
#+END_SRC


*** COMMENT Helm Alt-tab buffer navigation
While emacs is missing key raised events, alt-tab style behavior can
still be replicated with a hydra with a timeout
(broken)
#+BEGIN_SRC emacs-lisp
  (general-def
   "C-M-`" (lambda ()
             (interactive)
             (helm-mini)
             (hydra-helm-mini/body)))

  (defhydra hydra-helm-mini (:timeout 2
                                      :post (helm-execute-selection-action))
    "Buffer history: "
    ("M-<tab>" (helm-next-line))
    ("M-<S-iso-lefttab>" (helm-previous-line)))
#+END_SRC
*** COMMENT Buffer rotating
I bind tab and shift-tab to functions which switch to the previous and
next buffer with content respectively.
#+BEGIN_SRC emacs-lisp
  (defun content-buffer-p (buffer))
(general-def :states 'normal :keymaps 'override
                    "<tab>" 'previous-buffer
                    "<backtab>" 'next-buffer)
#+END_SRC
*** COMMENT Buffer toggling
This is a keybinding for toggling between 2
buffers. Faster than ~,-b\r~.
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal ; :keymaps 'override
                      "<tab>" 'evil-buffer)
#+END_SRC

** Buffer management
Utilities for buffer management

#+BEGIN_SRC emacs-lisp
  (defun get-next-valid-buffer-if (list pred &optional buffer visible-ok frame)
    (setq frame (or frame (selected-frame)))
    (let ((frame-pred (frame-parameter frame 'buffer-predicate))
          found buf)
      (while (and (not found) list)
        (setq buf (car list))
        (if (and (not (eq buffer buf))
                 (buffer-live-p buf)
                 (or (null frame-pred) (funcall frame-pred buf))
                 (funcall pred buf)
                 (not (eq (aref (buffer-name buf) 0) ?\s))
                 (or visible-ok (null (get-buffer-window buf 'visible))))
            (setq found buf)
          (setq list (cdr list))))
      (car list)))

  (defun last-buffer-if (pred &optional buffer visible-ok frame)
    (setq frame (or frame (selected-frame)))
    (or (get-next-valid-buffer-if (nreverse (buffer-list frame))
                                  pred
                                  buffer visible-ok frame)
        (get-buffer "*scratch*")
        (let ((scratch (get-buffer-create "*scratch*")))
          (set-buffer-major-mode scratch)
          scratch)))

  (defvar me/unbury-blacklist (if (featurep 'helm)
                                  helm-boring-buffer-regexp-list
                                nil))

  (defun me/unbury-interesting-pred (buffer)
    (every (lambda (regex)
             (not (string-match-p regex
                                  (buffer-name buffer))))
           me/unbury-blacklist))

  (defun unbury-interesting-buffer ()
    (interactive)
    (switch-to-buffer (last-buffer-if #'me/unbury-interesting-pred)))
#+END_SRC
** Mouse wheel scroll

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(2 ((shift) . 1) ((meta)) ((control) . text-scale)))
#+END_SRC
** COMMENT Icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC
* Autosaves
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(concat user-emacs-directory "backups"))))
  (setq auto-save-file-name-transforms
        `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(concat user-emacs-directory "backups") t)))

  (setq create-lockfiles nil)
#+END_SRC
* Text editing
** Spell Check
#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "aspell")
#+END_SRC
** Iedit
Iedit is a package for interactive refactoring.
#+BEGIN_SRC emacs-lisp
  (use-package iedit)

  (use-package evil-iedit-state
    :ensure t
    :config
    (defun me/evil-iedit-toggle ()
      (interactive)
      (if (evil-iedit-state-p)
          (evil-iedit-state/quit-iedit-mode)
        (evil-iedit-state/iedit-mode)))

    (general-def global-map
      "C-;" #'me/evil-iedit-toggle))
#+END_SRC
* Info/Man
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'info
    (general-def normal Info-mode-map
      "m" #'Info-menu
      "n" #'Info-next
      "p" #'Info-prev
      "g m" #'evil-set-marker
      "g n" #'evil-search-next
      "g p" #'evil-search-previous
      "H" #'Info-history-back
      "L" #'Info-history-forward
      "C-o" nil
      "C-i" nil)

    (eval-after-load 'Info
      (defface Info-quoted
        '((t :inherit fixed-pitch))
        "Face used for quoted elements."))


    (general-def normal Man-mode-map))
#+END_SRC
* Dired
Dired is the file manager built into Emacs.
#+BEGIN_SRC emacs-lisp
  (require 'dired)

  ;; Dired parses ls to produce its output. Use the flags "-alh"
  (setq dired-listing-switches "-alh"
        wdired-allow-to-change-permissions t)

  ;; Highlight the current line in dired mode
  (add-hook 'dired-mode-hook #'hl-line-mode)

  (defun me/dired-sort ()
    (interactive)
    (dired-sort-other
     (let ((alist '(("name" . "-Al")
                    ("date" .  "-Al -t")
                    ("size" . "-Al -S"))))
       (cdr (assoc (ido-completing-read "Sort by:" alist)
                   alist)))))
#+END_SRC
** Dired Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def normal dired-mode-map
    "A" (lambda () (interactive)
          (let ((current (current-buffer)))
            (call-interactively #'dired-up-directory)
            (kill-buffer current)))
    "SPC" nil)

  (general-def normal dired-mode-map
    "s" #'me/dired-sort)

  (general-def dired-mode-map
    "C-1" (lambda () (interactive)
            (dynamic-flet (dired-run-shell-command
                           (command)
                           (let ((handler
                                  (find-file-name-handler (directory-file-name default-directory)
                                                          'shell-command)))
                             (if handler (apply handler 'shell-command (list command))
                               (start-process-shell-command command nil command)))
                           ;; Return nil for sake of nconc in dired-bunch-files.
                           nil) 
              (call-interactively #'dired-do-shell-command))))
#+END_SRC
** Image Dired
~image-dired~ is a built-in image thumbnail viewer for dired.
#+BEGIN_SRC emacs-lisp
  (require 'image-dired)
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)

  (setq image-dired-thumb-size 400
        image-dired-thumb-width 400
        image-dired-thumb-height 400
        image-dired-thumb-margin 6
        image-dired-thumb-relief 6
        image-dired-show-all-from-dir-max-files 300)

  (defun image-dired-select-advice (arg)
    (call-interactively #'evil-force-normal-state)
    (me/image-dired-display-thumbnail-original-image))

  (advice-add 'image-dired-mouse-select-thumbnail
              :after
              #'image-dired-select-advice)

  (defun me/image-dired-thumbnail-mode-hook-fn ()
    (setq-local mouse-wheel-scroll-amount
                '(1 ((shift)) ((meta)) ((control) . text-scale))))

  (add-hook 'image-dired-thumbnail-mode-hook
            #'me/image-dired-thumbnail-mode-hook-fn)

  (defvar me/image-dired-display-image-buffer nil)

  (defun me/image-dired-display-thumbnail-original-image (&optional arg)
    "Display current thumbnail's original image in display buffer.
  See documentation for `image-dired-display-image' for more information.
  With prefix argument ARG, display image in its original size."
    (interactive "P")
    (let ((file (image-dired-original-file-name)))
      (if (not (string-equal major-mode "image-dired-thumbnail-mode"))
          (message "Not in image-dired-thumbnail-mode")
        (if (not (image-dired-image-at-point-p))
            (message "No thumbnail at point")
          (if (not file)
              (message "No original file name found")
            (save-selected-window
              (when (and me/image-dired-display-image-buffer
                         (get-buffer me/image-dired-display-image-buffer))
                (kill-buffer me/image-dired-display-image-buffer))
              (find-file-other-window file)
              (setq me/image-dired-display-image-buffer (current-buffer))
              (rename-buffer (concat "*image-dired: " (buffer-name) "*"))))))))

  (general-def normal image-dired-thumbnail-mode-map
    "=" #'image-increase-size
    "RET" #'me/image-dired-display-thumbnail-original-image
    "n" #'image-dired-display-next-thumbnail-original
    "p" #'image-dired-display-previous-thumbnail-original)

  (leader-key-def normal dired-mode-map
                  "i" (lambda nil (interactive)
                        (image-dired default-directory)))
#+END_SRC
** COMMENT Async
#+BEGIN_SRC emacs-lisp
  (use-package async
    :config
    (add-hook 'dired-mode-hook
              #'dired-async-mode))
#+END_SRC
** Dired Rsync
Asynchronously copy files with Rsync
#+BEGIN_SRC emacs-lisp
  (use-package dired-rsync
    :config
    (leader-key-def normal dired-mode-map
                    "r" #'dired-rsync))
#+END_SRC
** Dired FL
Add additional font lock rules for dired
#+BEGIN_SRC emacs-lisp
  (use-package diredfl
    :ensure t ;; TODO
    :config
    (diredfl-global-mode 1))
#+END_SRC
** COMMENT Dired Atool
Use atool for compression and extraction
#+BEGIN_SRC emacs-lisp
  (use-package dired-atool
    :ensure t
    :config
    (leader-key-def normal dired-mode-map
                    "z" #'dired-atool-do-unpack
                    ;; "Z" #'dired-atool-do-pack
                    ))
#+END_SRC
** Dired Du
Use du to list folder sizes
#+BEGIN_SRC emacs-lisp
  (use-package dired-du
    :config
    (setq dired-du-size-format t)
    ;; (leader-key-def 'normal dired-mode-map
    ;;                 "d" #'dired-du-mode)
    )
#+END_SRC
** Dired Hacks
[[https://github.com/Fuco1/dired-hacks#dired-rainbow][Various packages]] providing dired features
*** COMMENT Dired AVFS
This allows seamless archive browsing
#+BEGIN_SRC emacs-lisp
  (use-package dired-avfs)
#+END_SRC

*** Dired Subtree
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :config
    (defun me/dired-subtree-toggle ()
      "Insert subtree at point or remove it if it was not present."
      (interactive)
      (if (dired-subtree--dired-line-is-directory-or-link-p)
          (progn
            (if (dired-subtree--is-expanded-p)
                (progn
                  (dired-next-line 1)
                  (dired-subtree-remove))
              (save-excursion (dired-subtree-insert)))
            t)
        (if (> (line-number-at-pos) 5)
            (let ((prev-point (point)))
              (dired-previous-line 1)
              (unless (me/dired-subtree-toggle)
                ;; (set-window-point nil prev-point)
                ))
          nil)))

    (general-def 'normal dired-mode-map
      "z a" #'dired-subtree-toggle))
#+END_SRC
*** Dired Ranger
Multi-stage copy/paste
#+BEGIN_SRC emacs-lisp
  (use-package dired-ranger
    :config
    (general-def normal dired-mode-map
      "c" #'dired-ranger-copy
      "p" #'dired-ranger-paste)
    (leader-key-def normal dired-mode-map
                    "v" #'dired-ranger-move))
#+END_SRC
*** Dired Filter

#+BEGIN_SRC emacs-lisp
  (use-package dired-filter
    :config
    (customize-set-variable 'dired-filter-stack nil)
    (add-hook 'dired-mode-hook #'dired-filter-mode))
#+END_SRC
*** Dired Narrow
Interactively narrow/filter a dired buffer. Usually I just use
helm-find-file, but sometimes it's nice to narrow for a Dired
selection.
#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :config
    (leader-key-def normal dired-mode-map
                    "n" #'dired-narrow
                    "M-n" #'dired-narrow-regexp
                    "C-n" #'dired-narrow-fuzzy))
#+END_SRC
** COMMENT Dired Icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired :config
    (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))
#+END_SRC
* Proced
#+BEGIN_SRC emacs-lisp
  (setq proced-auto-update-interval 2)
  (defun me/proced-hook-fn ()
    (call-interactively #'proced-toggle-auto-update))

  (general-def ;; meme
    "<C-M-delete>" #'proced)

  (add-hook 'proced-mode-hook
            #'me/proced-hook-fn)
#+END_SRC
* Shell
** Eshell
~eshell~ is a shell that operates entirely within emacs. It is my
primary shell.
#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-smart)
#+END_SRC
*** Configuration
#+BEGIN_SRC emacs-lisp
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
  (setq eshell-history-size 1024)

  ;;(add-to-list 'eshell-visual-commands "rlwrap")

  ;; Eshell modules
  (require 'esh-module)
  (add-to-list 'eshell-modules-list 'eshell-tramp)
  ;; (setq password-cache t) ; enable password caching
  ;; (setq password-cache-expiry 3600) ; for one hour (time in secs)

  (setq eshell-prompt-function
        (lambda ()
          (let ((pwd (concat "[" (abbreviate-file-name (eshell/pwd)) "]")))
            (concat pwd
                    (when (< 0.5 (/ (* 1.0 (length pwd))
                                    (window-width))) "
  ")
                    " " (if (= (user-uid) 0) "Λ" "λ") " "))))

  (setq eshell-prompt-regexp  "^[^#$\n]* [Λλ] ")

  (cl-defun eshell-buffer-name-function (&optional (directory default-directory))
    (concat "*eshell at "
            (let ((directory (abbreviate-file-name directory)))
              (if (equal ?/ (car (last (string-to-list directory))))
                  directory
                (concat directory "/")))
            "*"))

  ;; (defun eshell-new ()
  ;;   "Open a new instance of eshell."
  ;;   (interactive)
  ;;   (let ((eshell-buffer-name (eshell-buffer-name-function)))
  ;;     (eshell 'N)))

  (defun eshell-singular ()
    "Open or switch to eshell"
    (interactive)
    (let ((eshell-buffer-name (eshell-buffer-name-function)))
      (eshell)))

  (defun eshell-at (directory)
    "Open a new instance of eshell in a new directory."
    (interactive (list (read-file-name "Eshell at: ")))
    (let ((default-directory directory))
      (eshell)))

  (defun eshell-at-or-switch (directory)
    (interactive (list (read-file-name "Eshell at: ")))
    (let ((buffer (get-buffer (eshell-buffer-name-function directory))))
      (if buffer
          (switch-to-buffer buffer)
        (eshell-at directory))))

  (defun eshell-here ()
    (interactive)
    (if eshell-mode
        (eshell-at default-directory)
      (eshell-at-or-switch default-directory)))

  (defun eshell-rename-buffer ()
    (let ((name (eshell-buffer-name-function)))
      (if (get-buffer name)
          (cl-labels ((recur (number)
                             (let ((new-name (set-buffer-number name number)))
                               (if (not (get-buffer new-name))
                                   (rename-buffer new-name)
                                 (recur (1+ number))))))
            (recur 1))
        (rename-buffer name))))

  (add-hook 'eshell-directory-change-hook #'eshell-rename-buffer)
  (add-hook 'eshell-mode-hook #'eshell-rename-buffer)
#+END_SRC
*** Commands
~eshell~ commands
#+BEGIN_SRC emacs-lisp
  (defun eshell/e (&rest args)
    "Open the given files"
    (dolist (file args) (if (listp file)
                            (dolist (file file)
                              (find-file file t))                          
                          (find-file file t))))

  (defun eshell/fd (&optional from-directory)
    "Run fzf to open a directory in dired"
    (fzf-directory-from (or from-directory
                            default-directory)))

  (defun eshell/fh ()
    (eshell/fd "~"))

  (defun eshell/econf () (econf))
  (defun eshell/gconf () (gconf))

  (if (executable-find "du")
      (fmakunbound 'eshell/du)) ; for speed
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key [f1] #'eshell)
  (global-set-key [f2] #'shell)

  (defun comint-style-insert-line (count)
    "insert line at the comint prompt"
    (interactive "p")
    (evil-goto-line)
    (evil-insert-line count))

  (defun comint-style-append-line (count)
    "append line at the comint prompt"
    (interactive "p")
    (evil-goto-line)
    (evil-append-line count))

  (defun eshell-properly-send-input ()
    "Go to end of buffer and send eshell input"
    (interactive)
    (evil-goto-line)
    (eshell-send-input))

  (defun me/eshell-prev ()
    (interactive)
    (evil-append 0)
    (call-interactively
     #'eshell-previous-matching-input-from-input)
    ;; (evil-force-normal-state)
    )

  (defun me/eshell-next ()
    (interactive)
    (evil-append 0)
    (call-interactively
     #'eshell-next-matching-input-from-input)
    ;; (evil-force-normal-state)
    )

  (defun eshell-previous-matching-input-from-input (arg)
    "Search backwards through input history for match for current input.
  \(Previous history elements are earlier commands.)
  With prefix argument N, search for Nth previous match.
  If N is negative, search forwards for the -Nth following match."
    (interactive "p")
    (if (not (memq last-command '(eshell-previous-matching-input-from-input
                                  eshell-next-matching-input-from-input)))
        ;; Starting a new search
        (setq eshell-matching-input-from-input-string
              (buffer-substring (save-excursion (eshell-bol) (point))
                                (save-excursion (end-of-line) (point)))
              eshell-history-index nil))
    (eshell-previous-matching-input
     (concat "^" (regexp-quote eshell-matching-input-from-input-string))
     arg))

  (defun eshell-previous-matching-input (regexp arg)
    "Search backwards through input history for match for REGEXP.
  \(Previous history elements are earlier commands.)
  With prefix argument N, search for Nth previous match.
  If N is negative, find the next or Nth next match."
    (interactive (eshell-regexp-arg "Previous input matching (regexp): "))
    (setq arg (eshell-search-arg arg))
    (if (> eshell-last-output-end (point))
        (error "Point not located after prompt"))
    (let ((pos (eshell-previous-matching-input-string-position regexp arg)))
      ;; Has a match been found?
      (if (null pos)
          (error "Not found")
        (setq eshell-history-index pos)
        (unless (minibuffer-window-active-p (selected-window))
          (message "History item: %d" (- (ring-length eshell-history-ring) pos)))
        ;; Can't use kill-region as it sets this-command
        (delete-region eshell-last-output-end (save-excursion (end-of-line)
                                                              (point)))
        (insert-and-inherit (eshell-get-history pos)))))

  (defun eshell-next-matching-input-from-input (arg)
    "Search forwards through input history for match for current input.
  \(Following history elements are more recent commands.)
  With prefix argument N, search for Nth following match.
  If N is negative, search backwards for the -Nth previous match."
    (interactive "p")
    (eshell-previous-matching-input-from-input (- arg)))


  (defun set-eshell-keybinds ()
    (general-def :states 'normal :keymaps 'eshell-mode-map
      "M-p" #'eshell-previous-matching-input-from-input
      "M-n" #'eshell-next-matching-input-from-input
      "I" #'comint-style-insert-line
      "A" #'comint-style-append-line
      "<return>" #'eshell-properly-send-input) ;;add push button support TODO
    (general-def 'insert 'eshell-mode-map
      "<tab>" #'helm-esh-pcomplete
      "TAB" #'helm-esh-pcomplete ; for text mode emacs
      "C-<return>" #'newline)
    (leader-key-def normal eshell-mode-map
                    "c" #'fish-completion-mode
                    "e" #'helm-eshell-history))

  (add-hook 'eshell-mode-hook ; needs to be in a hook because eshell is dumb/stupid
            #'set-eshell-keybinds)
#+END_SRC
*** Helm completion
~helm~ can be used for ~eshell~ completions.
#+BEGIN_SRC emacs-lisp
  ;; The keybinding to activate helm completion is bound in `set-eshell-keybinds'

  (general-def 'helm-esh-completion-map
    "<backtab>" #'helm-previous-line)
#+END_SRC
*** Disable Company
While company mode is widely useful, helm does better for eshell.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda () (company-mode -1)))
#+END_SRC
#+END_SRC
*** Properly Protect Prompt
~eshell~ doesn't play with ~evil~ with commands such as ~dd~ which target
the whole line. This code (inspired by spacemacs shell layer) solves
that problem.
#+BEGIN_SRC emacs-lisp
  (defun protect-eshell-prompt ()
    (let ((inhibit-field-text-motion t)
          (inhibit-read-only t))
      (add-text-properties
       (point-at-bol)
       (point)
       '(rear-nonsticky t
                        inhibit-line-move-fiold-capture t
                        field output
                        read-only t
                        front-sticky (field inhibit-line-move-field-capture)))))

  (add-hook 'eshell-after-prompt-hook 'protect-eshell-prompt)
#+END_SRC
*** COMMENT Attempted prompt fixes
This code is the sum of failed attempts to get the above feature working.
#+BEGIN_SRC emacs-lisp
  (defun eshell/clear ()
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer))
    (eshell-send-input))

  (defun restrict-bol (string)
    (propertize string
                'inhibit-line-move-field-capture t
                'rear-nonsticky t
                'field 'output
                'read-only t
                'front-sticky '(field inhibit-line-move-field-capture)))
  (defun protected-eshell-prompt (old-eshell-prompt &rest args)
    (restrict-bol (apply old-eshell-prompt args)))
  (advice-add 'eshell-prompt-functio)



  (setq eshell-prompt-regexp (regexp-quote "^\b$")
        eshell-prompt-function
        (lambda nil ""))

  (setq old-eshell-prompt-function (lambda nil (eshell-prompt-function)))
  (setq old-eshell-prompt-function (symbol-value 'eshell-prompt-function))
  (setq eshell-prompt-function
        (lambda nil
          (restrict-bol (old-eshell-prompt-function))))
  (setq eshell-prompt-function
        (lambda nil
          (restrict-bol (concat
                     (eshell/pwd)
                     " $ "))))
#+END_SRC

** Fish/Bash Completion
Get completion hints from bash and fish.
#+BEGIN_SRC emacs-lisp
  (use-package fish-completion
    :config
    ;; I toggle fish-completion-mode in eshell in the function
    ;; `set-eshell-keybinds'
    )
  (use-package helm-fish-completion
    :config
    (setq fish-completion-fallback-on-bash-p t)
    (define-key shell-mode-map (kbd "<tab>") 'helm-fish-completion)
    ;;   (defun me/helm-fish-completion-make-eshell-source ()
    ;;     "Make and return Helm sources for Eshell.
    ;; This is a good candidate for `helm-esh-pcomplete-build-source-fn'.
    ;; For `M-x shell', use `helm-fish-completion' instead."
    ;;     (list
    ;;      ;; 'helm-fish-completion-source
    ;;      (helm-make-source "Eshell completions" 'helm-esh-source
    ;;        :fuzzy-match helm-eshell-fuzzy-match)))
    ;;   (setq helm-esh-pcomplete-build-source-fn #'helm-esh-pcomplete-default-source)
    )
#+END_SRC
** Comint Mode
~comint mode~ is a generalized mode for repl-like interfaces.
#+BEGIN_SRC emacs-lisp
  (setq comint-prompt-read-only t ; Don't let me delete the comint prompt duh
        comint-move-point-for-output nil  ; reduce frequent redisplays
        comint-scroll-show-maximum-output nil)

  (general-def
    :states 'normal
    :keymaps 'comint-mode-map
    ;; go to prompt before append or insert line in comint mode
    "I" #'comint-style-insert-line
    "A" #'comint-style-append-line
    "M-p" #'comint-previous-matching-input-from-input
    "M-n" #'comint-next-matching-input-from-input)

  (with-eval-after-load 'company
    (defun comint-matching-input-like-eshell-advice (fun n)
      (company-cancel "")
      (funcall fun n)
      (end-of-buffer))

    (advice-add 'comint-previous-matching-input-from-input
                :around #'comint-matching-input-like-eshell-advice)
    (advice-add 'comint-next-matching-input-from-input
                :around #'comint-matching-input-like-eshell-advice))
#+END_SRC

** Shell
Shell mode is a comint-based mode for bash and other external shells.
I prefer ~shell-mode~ to open its buffers in the same window (like eshell does)
#+BEGIN_SRC emacs-lisp
  (push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)

  (add-hook 'shell-mode-hook
            #'company-mode-disable)

  (general-def 'shell-mode-map
    "M-p" #'comint-previous-matching-input-from-input
    "M-n" #'comint-next-matching-input-from-input)
#+END_SRC
** Vterm

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :config
    (general-def 'insert 'vterm-mode-map
      "<escape>" #'vterm-send-escape
      "<C-escape>" #'evil-force-normal-state))
#+END_SRC
** Term mode
Because terminal text cannot be edited with emacs ~evil mode~, bind ~C-g~
to evil normal mode, and ~<escape>~ to escape within the terminal.
#+BEGIN_SRC emacs-lisp
  (require 'subr-x)

  (defun me/term-paste ()
    (interactive)
    (term-send-raw-string (string-trim (current-kill 0))))

  (general-def 'insert 'term-raw-map
    "<escape>" #'term-send-esc
    "C-g" #'evil-force-normal-state
    "C-S-p" #'me/term-paste)

  (general-def 'normal 'term-mode-map
    "p" #'me/term-paste)


  ;; https://emacs.stackexchange.com/questions/17005/killing-ansi-term-says-has-a-running-process
  (defun set-no-process-query-on-exit ()
    (let ((proc (get-buffer-process (current-buffer))))
      (when (processp proc)
        (set-process-query-on-exit-flag proc nil))))

  ;; (add-hook 'term-exec-hook #'set-no-process-query-on-exit)

  ;; stop paste from entering commands.
  (setq term-suppress-hard-newline t)
#+END_SRC
*** COMMENT Protect Prompt
This code was the restult of a bad misunderstanding of the function of ~ansi-term~.
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook (lambda () (setq-local term-prompt-regexp "\\[.*\\]\\$ [\n]*")))

  (defun protect-term-prompt ()
    (interactive)
    (save-match-data
      (when (string-match (condition-case nil 
                              (symbol-value 'term-prompt-regexp) 
                            (void-variable "")) 
                          (thing-at-point 'line t))
        (let ((inhibit-field-text-motion t)
              (inhibit-read-only t))
          (add-text-properties
           (point-at-bol)
           (point-at-eol)
           '(rear-nonsticky t
                            inhibit-line-move-fiold-capture t
                            field output
                            read-only t
                            front-sticky (field inhibit-line-move-field-capture)))))))

  (advice-add 'term-send-input #'protect-term-prompt)
#+END_SRC

** Multi-Term
Allows multiple term buffers to be created.
#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :config
    ;; (global-set-key [f1] 'multi-term)
    ;; access shift arrow keys
    (define-key global-map "\eO2D" (kbd "S-<left>"))
    (define-key global-map "\eO2C" (kbd "S-<right>"))
    ;; term movement
    (general-def
      :states 'normal
      :keymaps 'term-mode-map
      "S-<right>" 'multi-term-next
      "S-<left>" 'multi-term-prev))
#+END_SRC

* Tramp
~tramp~ allows the access of remote files as if they were part of the
local filesystem across all of Emacs.
#+BEGIN_SRC emacs-lisp
  (require 'tramp)

  ;; try ftp passive mode
  (setq ange-ftp-try-passive-mode t)

  ;; Some quick functions
  (defun me/~club ()
    (interactive)
    (find-file "/ssh:ipkcle@tilde.club:/home/ipkcle"))
#+END_SRC
* Ielm
Automatically insert the outermost parens in ielm
#+BEGIN_SRC emacs-lisp
  (defun me/ielm-eval-with-outer-parens (oldfun string &rest r)
    (apply oldfun
           (if (not (or (not (some (lambda (c) (char-equal c ?\ ))
                                   string))
                        (equal (length string) 0)
                        (char-equal (elt "(" 0) (elt string 0))
                        (char-equal (elt ")" 0) (elt string (1- (length string))))))
               (concat "(" string ")")
             string)
           r))

  (advice-add 'ielm-eval-input
              :around
              #'me/ielm-eval-with-outer-parens)
#+END_SRC
* Emacs client/server settings
#+BEGIN_SRC emacs-lisp
  ;; run emacs server
  ;; (server-start)

  ;; easily restart emacs daemon
  ;; (use-package restart-emacs :ensure t)

  ;; focus any new frames
  (add-to-list 'after-make-frame-functions 'select-frame-set-input-focus)
#+END_SRC
** Daemon Management
I wrote this code to help manage Emacs daemons. It is usually fine to
operate within a single Emacs daemon, but when I need to have more
than one it's nice to be able to manage them as inferior processes.
#+BEGIN_SRC emacs-lisp
  (cl-defun make-daemon-frame (socket-name &rest args)
    "Make a new emacs frame for the daemon with the given socket name."
    (interactive "M" "Socket name: ")
    (apply 'start-process
           (concat socket-name "-frame")
           nil
           "emacsclient" "--create-frame" (concat "--socket-name=" socket-name)
           args))

  (cl-defun make-daemon (socket-name &key (create-buffer t) before after (theme 'doom-nord-light))
    "Make a new emacs daemon with the given socket name."
    (interactive "M" "Socket name: ")
    (message "Loading inferior emacs")
    (let ((daemon-name (concat socket-name "-daemon")))
      (start-process-shell-command
       daemon-name (when create-buffer daemon-name)
       (concat before
               "emacs --daemon=" socket-name
               ;; "--execute \"(load-theme '"
               ;; (symbol-name theme)
               ;; " t)\""
               ";"
               after))))
#+END_SRC

*** Nix
I wrote some other ugly but useful functions to spawn Emacs daemons within a
given Nix environment.
#+BEGIN_SRC emacs-lisp
  (cl-defun nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; nix-shell starts daemosn in /run/user/
    (interactive)
    (let ((running? (file-exists-p (concat "/run/user/1000/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun non-nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was NOT started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; daemons started outside of nix-shell exist in /tmp/
    (interactive)
    (let ((running? (file-exists-p (concat "/tmp/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun nix-daemon (&optional (theme 'doom-nord-light))
    "Start a daemon and frame in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let* ((default-directory (file-name-directory (nix-current-sandbox)))
               (socket-name (file-name-directory default-directory))
               (daemon-name (concat socket-name "-daemon")))
          (if (nix-daemon-running-p socket-name) 
              (nix-daemon-frame)
            (message "Loading inferior nix emacs")
            (start-process-shell-command
             daemon-name daemon-name
             (concat "nix-shell --command \""
                       "emacs --daemon=" socket-name
                       " --execute \\\"
                         (load-theme '"
                         (symbol-name theme)
                         " t)\\\""
                       "; "
                       "emacsclient --create-frame "
                       (concat "--socket-name=" socket-name)
                     "; "
                     "return"
                     "\""))))
      (error "No nix environment was found")))

  (defun nix-daemon-frame ()
    "Start a frame from the relevant nix Emacs daemon in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let ((default-directory (file-name-directory (nix-current-sandbox)))
              (socket-name (elt (nreverse (split-string default-directory "/")) 1)))
          (unless (nix-daemon-running-p socket-name)
            (error "The daemon is not active"))
          (start-process-shell-command
           (concat socket-name "-frame") nil
           (concat "nix-shell --command "
                   (concat "\"emacsclient --create-frame --socket-name=" socket-name "\""))))
      (error "No nix environment was found")))
#+END_SRC
* Color Theme
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :config
    (doom-themes-visual-bell-config)) ; flash mode line when emacs bell rings

  ;; (use-package poet-theme)

  ;; (use-package chocolate-theme)

  ;; (use-package spacemacs-theme)

  ;; (use-package cyberpunk-theme)

  (defun disable-all-themes ()
    (interactive)
    (mapcar #'disable-theme custom-enabled-themes))

  ;; (switch-theme 'doom-fairy-floss)
#+END_SRC
*** COMMENT time-based theme
The theme loaded depends upon time of day. Causes slight face issues.
#+BEGIN_SRC emacs-lisp
  (use-package theme-changer
    :after doom-themes
    :config
    (setq calendar-location-name me/calendar-location-name)
    (setq calendar-latitude me/calendar-latitude)
    (setq calendar-longitude me/calendar-longitude)
    (change-theme 'doom-one-light 'doom-one))
#+END_SRC

* Window mangement
** Winner Mode
~winner-mode~ lets me switch between window configurations with emacs-like undo capabilities.
I abbreviate the command with ~hydra~.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)

  (defhydra hydra-winner (global-map "C-c" :timeout 2)
    "Window configuration history"
    ("u" winner-undo)
    ("r" winner-redo))
#+END_SRC
** Helm winconf
I wrote a small and simple package for managing named window configurations.
#+BEGIN_SRC emacs-lisp
  (require 'helm-winconf)

  (general-def "M-<tab>" #'helm-winconf-swap)

  (unless (featurep 'exwm)
    (leader-key-def 'normal 'override
                    "RET" #'helm-winconf))
#+END_SRC
*** COMMENT Alt tab style winconf switching
And an alt-tab hydra for it. Doomed to fail.
#+BEGIN_SRC emacs-lisp
  (lexical-let (winconf-list length)

    (defun helm-winconf-history-delta (delta)
      (assert (or (= delta 1)
                  (= delta -1)))
      (setq winconf-list (cd*r (if (minusp delta)
                                   (+ length delta)
                                 delta)
                               winconf-list))
      (set-window-configuration (cdar winconf-list)))

    (defun helm-winconf-update-history ()
      (cl-flet ((helm-winconf--rassoc (conf)
                                      (car (rassoc conf helm-winconf--names-alist)))))
      (helm-winconf--new (helm-winconf--current))
      (let ((conf (current-window-configuration))
            (name-and-conf (cons (helm-winconf--rassoc conf)
                                 conf)))
        (setq helm-winconf--names-alist (cons name-and-conf
                                              (remove name-and-conf
                                                      helm-winconf--names-alist)))))

    (general-def
     "M-<tab>" (lambda ()
                 (interactive)
                 (setq length (length helm-winconf--names-alist))
                 (setq winconf-list (circular helm-winconf--names-alist))
                 (helm-winconf-history-delta 1)
                 (hydra-winconf-history/body)))

    (defhydra hydra-winconf-history (:timeout 2
                                              :post (helm-winconf-update-history))
      "Winconf history: "
      ("M-<tab>" (helm-winconf-history-delta 1))
      ("M-<S-iso-lefttab>" (helm-winconf-history-delta -1))))
#+END_SRC
** Keybindings

#+BEGIN_SRC emacs-lisp
  (general-nmap
    "C-w C-+" #'evil-window-increase-height
    "C-w C--" #'evil-window-decrease-height

    "C-w C->" #'evil-window-increase-width
    "C-w C-<" #'evil-window-decrease-width
    "C-w C-." #'evil-window-increase-width
    "C-w C-," #'evil-window-decrease-width

    "C-w C-h" #'evil-window-left
    "C-w C-j" #'evil-window-down
    "C-w C-k" #'evil-window-up
    "C-w C-l" #'evil-window-right

    "C-w C-=" #'balance-windows
    "C-w C-\\" #'evil-window-set-width)
#+END_SRC
** COMMENT Perspective
~perspective~ is a package for managing window configurations.
#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :config
    (persp-mode)

    ;; I just want to use `persp-mode' as a layout saver, so I remove
    ;; all inter-persp buffer restrictions
    (setq persp-disable-buffer-restriction-once t)
    (setq persp-kill-foreign-buffer-behaviour 'just-kill)

    (general-def :keymap 'persp-mode-map
                        "M-<tab>" #'persp-next
                        "<M-iso-lefttab>" #'persp-prev))
#+END_SRC
** COMMENT Persp-mode
~persp-mode~ is a package for managing window configurations. I prefer
this to managing frames.
#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :config
    (persp-mode)

    ;; I just want to use `persp-mode' as a layout saver, so I remove
    ;; all inter-persp buffer restrictions
    (setq persp-disable-buffer-restriction-once t)
    (setq persp-kill-foreign-buffer-behaviour 'just-kill)

    (general-def :keymap 'persp-mode-map
                        "M-<tab>" #'persp-next
                        "<M-iso-lefttab>" #'persp-prev))
#+END_SRC
** COMMENT FZF
As powerful as ~projectile~ is, ~fzf~ still takes the cake on
speed of recursive search.
#+BEGIN_SRC emacs-lisp
  (use-package fzf)
#+END_SRC

This function opens a directory using ~fzf/start~.
#+BEGIN_SRC emacs-lisp
  (defun fzf-directory-from-home () (interactive)
         (fzf/start "~/" "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null"))

  (defun fzf-directory-from (directory) (interactive "D")
         (fzf/start directory "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null"))
#+END_SRC
* Programming tools and settings
** Projects
*** Projectile
~projectile~ is a powerful package which facilitates navigation within a
project.
#+BEGIN_SRC emacs-lisp
  ;; (use-package f)

  (use-package projectile
    :delight ""
    :after (general f)
    :config
    ;; (projectile-discover-projects-in-search-path)
    (defun projectile-discover-projects-in-directory-recursive (directory)
      (unless (projectile-project-p directory)
        (mapcar (lambda (dir)
                  (progn (projectile-discover-projects-in-directory dir)
                         (projectile-discover-projects-in-directory-recursive dir)))
                (cl-remove-if (lambda (dir) (or (not (f-directory? dir))
                                           (cl-case (file-name-nondirectory dir)
                                             (".." t) ("." t))))
                              (mapcar (lambda (file) (concat directory file))
                                      (directory-files directory))))))

    (setq projectile-ignored-project-function
          (lambda (dir) (not (cl-some (lambda (dir-file) (string= dir-file ".git"))
                                 (directory-files dir)))))

    ;; (projectile-discover-projects-in-directory-recursive "~/Code/")

    (general-def
      :states 'normal
      :keymaps 'projectile-mode-map
      "C-p" 'helm-projectile-find-file)

    (project-key-def 'normal
                     "p" 'projectile-switch-project
                     "e" 'projectile-run-eshell)
    (projectile-mode +1))

  ;; use helm for projectile
  (use-package helm-projectile
    :after projectile
    :config
    (helm-projectile-on))
#+END_SRC
*** Skeletor
~skeletor~ is a project skeleton package which helps me get off the ground faster.
#+BEGIN_SRC emacs-lisp
  (use-package skeletor
    :config
    (setq skeletor-project-directory "~/code/") ; by default, put the
                                          ; project in the ~/code
                                          ; directory.
    (setq skeletor-user-directory (dotfiles "emacs/.emacs.d/skeletor/"))

    (defun skeletor-create-project-here ()
      "Create a skeletor project in the current directory."
      (interactive)
      (let ((skeletor-project-directory default-directory))
        (call-interactively 'skeletor-create-project)))

    ;; global substitutions
    (add-to-list 'skeletor-global-substitutions
                 '("__AUTHOR__" . "Adrian Fullmer"))

    ;; (defun setup--lorri (dir)
    ;;   (let ((default-directory dir))
    ;;     (skeletor-shell-command "direnv allow")
    ;;     (projectile-lorri-watch)))

    ;; I don't like the default skeletons.
    (setq skeletor--project-types nil)

    ;; Custom project skeletons
    (skeletor-define-template "generic"
      :title "Generic Project"
      ;; :substitutions
      ;; '(("__PACKAGES__" . (lambda () (read-string "Packages to use: "))))
      )
                                          ; a lambda is used to avoid a
                                          ; failed assertation where the
                                          ; function itself would
                                          ; do. maybe report the bug.

    (skeletor-define-template "common-lisp"
      :title "Common Lisp Project"
      :substitutions
      '(("__DESCRIPTION__" . (lambda () (read-string "Description: ")))))

    (skeletor-define-template "python"
      :title "Python Project"
      ;; :substitutions
      ;; '(("__PACKAGES__" . (lambda () (read-string "Packages: "))))
      )

    (skeletor-define-template "haskell"
      :title "Haskell Project"
      ;; :substitutions
      ;; '(("__HASKELL-PACKAGES__" . (lambda () (read-string "Haskell packages: ")))
      ;;   ("__PACKAGES__" . (lambda () (read-string "Other packages: "))))
      )

    (skeletor-define-template "clojure"
      :title "Clojure Project")

    (skeletor-define-template "gnu"
      :title "Gnu Build System Project")

    (skeletor-define-template "ats"
      :title "ATS Project")

    ;;keybindings
    (project-key-def 'normal
                     "s" 'skeletor-create-project-here))
#+END_SRC
** Agressive Indent
~agressive-indent-mode~ enforces indentation as code is being edited.
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :delight
    :config
    (global-aggressive-indent-mode 1)
    (add-to-list 'aggressive-indent-excluded-modes 'html-mode)
    (add-to-list 'aggressive-indent-excluded-modes 'helm-mode)
    (add-to-list 'aggressive-indent-excluded-modes 'ats-mode)
    (add-to-list 'aggressive-indent-excluded-modes 'slime-repl-mode)
    (add-to-list 'aggressive-indent-excluded-modes 'java-mode)
    (add-to-list
     'aggressive-indent-dont-indent-if
     '(and (or (derived-mode-p 'c-mode) (derived-mode-p 'c++-mode))
           (null (string-match-p "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                                 (thing-at-point 'line))))))
#+END_SRC
** Autocompletion
I use the ~Company~ package for autocompletion.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :config
    ;; (add-to-list 'company-frontends 'company-tng-frontend) ; test this vs evil collection
    (add-to-list 'company-backends 'company-files) ; test this vs evil collection
    (add-to-list 'completion-styles 'initials t)
    ;;(add-to-list 'completion-styles 'substring t)
    (general-def 'company-active-map
      "M-." #'company-show-location
      "C-d" #'company-show-doc-buffer
      ;; "<return>" #'company-complete-selection
      "<return>" nil
      "RET" nil
      "<tab>" #'company-complete-selection
      "C-s" #'company-filter-candidates
      "C-h" nil
      "M-n" nil
      "M-p" nil)
    (define-key company-active-map (kbd "M-.") 'company-show-location)
    (define-key company-active-map (kbd "\C-d") 'company-show-doc-buffer)
    ;;(setq company-dabbrev-downcase 0)

    (setq company-minimum-prefix-length 2)
    (setq company-idle-delay 0)
    ;; (remove-hook 'sly-mode-hook (lambda () (progn (setq company-idle-delay 0.1)
    ;;                                               (setq company-minimum-prefix-length 2))))

    (global-company-mode nil)

    (defun company-mode-disable ()
      (company-mode -1)))
#+END_SRC
*** Smart Tab
#+BEGIN_SRC emacs-lisp
  (use-package smart-tab
    :ensure t ;; TODO is this necessary?
    :delight)
#+END_SRC
*** Helm-company
Complete helm candidates with helm-company
#+BEGIN_SRC emacs-lisp
  (use-package helm-company
    :config
    (general-def 'company-active-map
      "M-<tab>" #'helm-company))
#+END_SRC
** Linting
I use the ~flycheck~ package for linting.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (setq flycheck-global-modes '(not c-mode c++-mode)))
#+END_SRC
** Git (Magit)
I use ~magit~, a very nice Git interface.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
With ~evil~ friendly keybindings.
#+BEGIN_SRC emacs-lisp
(use-package evil-magit)
#+END_SRC
and a leader shortcut.
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal 'override
                  "m" 'magit)
#+END_SRC
*** COMMENT Magit Forge
A package to interact with Git forges like Gitlab.
#+BEGIN_SRC emacs-lisp
  (use-package forge)
#+END_SRC
** Snippets
~yasnippet~ expands short trigger strings in to interactive text snippets
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    :config
    (yas-global-mode t)
    ;; (setq yas/root-directory
    ;;       nil
    ;;       ;; (list (dotfiles "emacs/.emacs.d/snippets")
    ;;       ;;       yas/root-directory)
    ;;       )
    ;; (ys-reload-all)
    (setq yas-snippet-dirs '("~/.emacs.d/snippets")))
#+END_SRC
~yasnippet~ can be used as a backend for ~company~.
#+BEGIN_SRC emacs-lisp
  ;; https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")

  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC
*** COMMENT snippet collection
A large collection of snippets is found in the ~yasnippet-snippets~ package.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets)
#+END_SRC
** Language client features
The language server protocol can provide IDE-like features for many
languages. ~lsp-mode~ also serves as a backend for ~company~ and ~flycheck~ / ~flymake~.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode ; :commands lsp
    :config

    (defun seq-first (&rest args)
      (apply #'lsp-seq-first args))

    (defun seq-rest (&rest args)
      (apply #'lsp-seq-rest args))

    ;; (setq lsp-keymap-prefix "s-l")
    ;; (customize-set-variable 'lsp-keymap-prefix
    ;;                         "M-l")

    (general-def 'lsp-mode-map
      "s-l" nil)

    (general-def 'normal 'lsp-mode-map
      "M-." #'lsp-goto-implementation))

  (use-package lsp-ui :commands lsp-ui-mode) ; adds flycheck support
  (use-package company-lsp :commands company-lsp) ; links with company
  (use-package helm-lsp :commands helm-lsp-workspace-symbol)
  ;; (use-package dap-mode
  ;;   :ensure t :after lsp-mode
  ;;   :config
  ;;   (dap-mode t)
  ;;   (dap-ui-mode t))
  ;; optionally if you want to use debugger
  ;; (use-package dap-mode)

  (leader-key-def 'normal 'lsp-mode-map
                  "e" #'lsp-execute-code-action)
#+END_SRC
** Compilation
I wrote this function to run ~make~ on a recursive upward
search. Inspired by [[https://emacs.stackexchange.com/questions/7475/recursively-go-up-to-find-makefile-and-compile][this]].
#+BEGIN_SRC emacs-lisp
(cl-defun compile-rec (&key (filename "Makefile") (command "make -k"))
  "Traveling up the path, find a Makefile and `compile'."
  (interactive)
  (let ((makefile-dir (locate-dominating-file default-directory filename)))
    (when makefile-dir
      (with-temp-buffer
        (cd makefile-dir)
        (compile command)))))
#+END_SRC
** Envrc
Buffer-local direnv integration with the Envrc package

#+BEGIN_SRC emacs-lisp
  (use-package envrc
    :ensure t
    :after projectile
    :config)
  ;; (envrc-global-mode) should be called late in the startup sequence
#+END_SRC
*** COMMENT envrc async

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (with-eval-after-load 'envrc
    (defun envrc--export-async (env-dir result-fn)
      (unless (file-exists-p (expand-file-name ".envrc" env-dir))
        (error "%s is not a directory with a .envrc" env-dir))
      (message "Running direnv in %s..." env-dir)
      (unwind-protect
          (let ((default-directory env-dir)
                (stdout (generate-new-buffer (concat " *direnv output at " env-dir "*")))
                (stderr (generate-new-buffer (concat "*envrc at " env-dir "*"))))
            (let ((process-environment (default-value 'process-environment))
                  (exec-path (default-value 'exec-path)))
              (make-process
               :name "direnv"
               :buffer stdout
               :stderr stderr
               :command '("direnv" "export" "json")
               :sentinel
               (lambda (process msg)
                 (unless (eq (process-status process) 'run)
                   (let ((exit-code (process-exit-status process))
                         result)
                     (envrc--debug "Direnv exited with %s and output: %S" exit-code (buffer-string))
                     (if (zerop exit-code)
                         (progn
                           (message "Direnv succeeded in %s" env-dir)
                           (with-current-buffer stdout
                             (unless (zerop (buffer-size))
                               (goto-char (point-min))
                               (setq result (let ((json-key-type 'string)) (json-read-object))))))
                       (message "Direnv failed in %s" env-dir)
                       (setq result 'error))
                     (kill-buffer stdout)
                     (envrc--at-end-of-special-buffer "*envrc*"
                       (insert "==== " (format-time-string "%Y-%m-%d %H:%M:%S") " ==== " env-dir " ====\n\n")
                       (let ((initial-pos (point)))
                         (insert-buffer-substring stderr)
                         ;; (insert-file-contents (let (ansi-color-context)
                         ;;                         (ansi-color-apply stderr-file)))
                         (goto-char (point-max))
                         (add-face-text-property initial-pos (point) (if (zerop exit-code)
                                                                         'success 'error)))
                       (insert "\n\n"))
                     (kill-buffer stderr)
                     (funcall result-fn result)))))))))

    (defun envrc--update-env-async (env-dir)
      (when (not (eq 'loading (gethash env-dir envrc--envs)))
        (puthash env-dir 'loading envrc--envs)
        (envrc--apply-all env-dir)
        (envrc--export-async env-dir
                             (lambda (result)
                               (puthash env-dir result envrc--envs)
                               (envrc--apply-all env-dir)))))

    (defun envrc--lighter ()
      "Return a colourised version of `envrc--status' for use in the mode line."
      `(" env["
        (:propertize ,(symbol-name envrc--status)
                     face
                     ,(pcase envrc--status
                        (`on 'envrc-mode-line-on-face)
                        (`error 'envrc-mode-line-error-face)
                        (`loading 'envrc-mode-line-none-face)
                        (`none 'envrc-mode-line-none-face)))
        "]"))

    (defun envrc-reload-async ()
      "Run \"direnv allow\" in the current env."
      (interactive)
      (envrc--with-required-current-env env-dir
        (envrc--update-env-async env-dir)))

    (defun envrc-allow-async ()
      "Run \"direnv allow\" in the current env."
      (interactive)
      (envrc--with-required-current-env env-dir
        (let* ((default-directory env-dir)
               (exit-code (envrc--call-process-in-default-env "direnv" nil (get-buffer-create "*envrc-allow*") nil "allow")))
          (if (zerop exit-code)
              (envrc--update-env-async env-dir)
            (display-buffer "*envrc-allow*")))))

    (defun envrc--apply (buf result)
      "Update BUF with RESULT, which is a result of `envrc--export'."
      (with-current-buffer buf
        (setq-local
         envrc--status
         (pcase result
           (`loading 'loading)
           (`error 'error)
           (`() 'none)
           (_ 'on)))
        (kill-local-variable 'exec-path)
        (kill-local-variable 'process-environment)
        (kill-local-variable 'eshell-path-env)
        (let ((pairs (when (listp result) result)))
          (if pairs
              (progn
                (envrc--debug "[%s] applied merged environment" buf)
                (setq-local process-environment (envrc--merged-environment process-environment pairs))
                (let ((path (getenv "PATH"))) ;; Get PATH from the merged environment: direnv may not have changed it
                  (setq-local exec-path (parse-colon-path path))
                  (when (derived-mode-p 'eshell-mode)
                    (setq-local eshell-path-env path))))
            (unless (eq 'loading result)
              (envrc--debug "[%s] reset environment to default" buf))))))

    (setf (symbol-function 'envrc--update-env) #'envrc--update-env-async)
    )
#+END_SRC
** COMMENT Direnv and Lorri
Direnv allows Emacs to automatically set environment variables on a
per-buffer basis. Direnv integrates with Nix sandboxes through Lorri.
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :delight
    :after projectile          ; I integrate projectile with direnv here
    :config
    ;; (direnv-mode 1)

    (leader-key-def 'normal
                    "d" #'direnv-mode)

    ;; Keybindings to direnv refresh and lorri watch

    (cl-defun projectile-lorri-watch (&optional (project-directory (projectile-project-root)))
      "Begin an inferior process to watch the current projectile
  project with lorri."
      (interactive)
      (let* ((project-name (file-name-directory project-directory))
             (process-name (concat "Lorri [" project-name "]"))
             (default-directory project-directory))
        (if (file-exists-p "shell.nix")
            (if (not (get-process process-name))
                (progn
                  ;; (start-process-shell-command
                  ;;  (concat "direnv-" process-name) nil
                  ;;  "direnv-allow")
                  (start-process-shell-command
                   process-name (earmuffs process-name)
                   "lorri watch")
                  (message (concat "Lorri watching " project-name)))
              (error (concat "Lorri is already watching " project-name)))
          (error (concat "There is no shell.nix for " project-name)))))

    (project-key-def 'normal
                     "d" 'direnv-update-directory-environment
                     ;; "l" 'projectile-lorri-watch
                     )

    ;; Lorri watch the given project when switching to a new project.
    ;; (add-hook 'projectile-after-switch-project-hook
    ;;           (lambda () (ignore-errors (projectile-lorri-watch))))

    ;; Advice to run emacsHook
    (defun run-emacs-hook ()
      (if (getenv "emacsHook")
          (eval (car (read-from-string
                      (format "(progn %s)"
                              (getenv "emacsHook")))))))

    ;; (advice-add 'direnv-update-directory-environment
    ;;             :after
    ;;             #'run-emacs-hook)

    (defvar to-add-to-ld-library-path "")

    (defun add-to-ld-library-path ()
      (let ((new-to-add (or (getenv "emacsAddLdLibraryPath")
                            "")))
        (remove-from-path to-add-to-ld-library-path "LD_LIBRARY_PATH" ":")
        (setq to-add-to-ld-library-path new-to-add)
        (add-to-path to-add-to-ld-library-path "LD_LIBRARY_PATH" ":")))

    ;; (advice-add 'direnv-update-directory-environment
    ;;             :after
    ;;             #'add-to-ld-library-path)

    ;; Non-file modes which should also be synched with direnv
    (defmacro add-direnv-non-file-modes (&rest body)
      `(mapcar (lambda (mode) (add-to-list 'direnv-non-file-modes mode)) (list ,@body)))

    (add-direnv-non-file-modes
     'sly-mode
     'slime-mode
     'eshell-mode
     'comint-mode
     'term-mode
     'prolog-mode
     'inferior-python-mode
     'haskell-mode))
#+END_SRC
** COMMENT Polymode
This is a very cool package that provides support for multiple major
modes in the same buffer. It seems to crash sometimes when editing org
files.
#+BEGIN_SRC emacs-lisp
(use-package polymode)
(use-package poly-org)
#+END_SRC
* Language specific tools and settings
** Lisps
#+BEGIN_SRC emacs-lisp
  (defvar me/lisp-modes
    '(emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode slime-mode-map sly-mode-map
                      scheme-mode))

  (cl-defun me/lisp-mode-p (&optional (mode major-mode))
    (find mode me/lisp-modes))
#+END_SRC
*** Lispy/ville
~lispy~ is my S-expr editing tool of choice. It integrates with ~evil~
through ~lispyville~ minor mode.
#+BEGIN_SRC emacs-lisp
  (use-package lispyville
    :delight
    :hook ((scheme-mode emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode) . lispyville-mode)
    :config
    (lispyville-set-key-theme
     '(operators
       ;; atom-motions
       prettify
       wrap
       slurp-cp
       barf-cp
       c-w
       (escape insert)
       (additional-movement normal visual motion)))

    (defun lispy-slurp-or-barf-advice (fun &rest args)
      "Adjust lispy slurp or barf functions to operate with the
  point to the left of the paren, rather than the right. Makes them
  work better in normal-mode"
      (forward-char)
      (apply fun args)
      (backward-char))

    (aaa '(lispy-slurp-or-barf-left
           lispy-slurp-or-barf-right)
         #'lispy-slurp-or-barf-advice
         :around))
#+END_SRC

*** Lisp keybindings
Lispy is my de-facto mode for lisp languages, so lisp-specific
functionality can be bound to that mode.
#+BEGIN_SRC emacs-lisp
  (evil-define-operator me/lispyville-prettify (beg end type)
    (lispyville-prettify beg end))

  (general-def :states 'insert
    :keymaps 'lispyville-mode-map
    "M-l" (lambda () (interactive)
            (insert "lambda"))
    "M-k" #'lispy-slurp-or-barf-right
    "M-j" #'lispy-slurp-or-barf-left)

  (general-def :states 'normal
    :keymaps 'lispyville-mode-map
    "M-k" #'lispy-slurp-or-barf-right
    "M-j" #'lispy-slurp-or-barf-left
    "[" #'lispyville-beginning-of-defun
    "]" #'lispyville-beginning-of-next-defun
    "=" #'me/lispyville-prettify)

  (general-def '(visual normal) 'lispyville-mode-map
    "gc" #'lispyville-comment-or-uncomment)
#+END_SRC
*** Rainbow delimiters
While ~rainbow-delimeters-mode~ is active each depth of delimiter is
given a different color.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :delight
    :config
    (add-hook 'lispyville-mode-hook #'rainbow-delimiters-mode-enable))
#+END_SRC
** Emacs lisp
*** Nameless
This uses font-lock to hide namespace prefixes automatically.
#+BEGIN_SRC emacs-lisp
  (use-package nameless
    :ensure t
    :delight
    :config
    (add-hook 'emacs-lisp-mode-hook #'nameless-mode)
    (general-def :states 'insert
                        :keymaps 'emacs-lisp-mode-map
                        "C-:" 'nameless-insert-name)
    (setq nameless-global-aliases '(("fl" . "font-lock")
                                    ("s" . "seq")
                                    ("me" . "macroexp")
                                    ("c" . "cider")
                                    ("q" . "queue")
                                    ("xn" . "exwm-named-workspace"))))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def 'normal 'emacs-lisp-mode-map
    "M-." #'find-function-or-variable-at-point)

  (eval-key-def 'normal emacs-lisp-mode-map
                "b" #'eval-buffer
                "f" #'eval-defun)
  (eval-key-def 'visual emacs-lisp-mode-map
                "r" #'eval-region)

  (general-def 'normal 'lisp-interaction-mode-map
    "M-." #'find-function-or-variable-at-point)
  (eval-key-def 'normal lisp-interaction-mode-map
                "b" #'eval-buffer
                "f" #'eval-defun)
  (eval-key-def 'visual lisp-interaction-mode-map
                "r" #'eval-region)

  (general-def 'normal lisp-interaction-mode-map
    "C-j" #'eval-print-last-sexp)
#+END_SRC
** Common Lisp
*** COMMENT Slime
~slime~ is a Common Lisp IDE for Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :after evil
    :config
    (delight 'slime-autodoc-mode "" t)

    (setq slime-contribs '(slime-fancy))
    (add-to-list 'smart-tab-completion-functions-alist
                 '(lisp-mode . helm-slime-complete))
    (add-to-list 'smart-tab-completion-functions-alist
                 '(slime-repl-mode . helm-slime-complete))

    (defmacro define-slime-lisp (name command)
      `(defun ,name () (interactive) (slime ,command)))

    (defmacro define-slime-lisp-defun (name fn)
      `(defun ,name () (interactive) (slime (funcall ,fn))))

    ;;(define-slime-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
    (define-slime-lisp sbcl "sbcl")
    (define-slime-lisp ecl "ecl --load ~/quicklisp/setup.lisp")
    (define-slime-lisp ccl "ccl")
    (define-slime-lisp clisp "clisp")

    (setq inferior-lisp-program "sbcl")
    ;; ;; Open slime debug buffers in emacs state, rather than evil state.
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(slime-read-symbol-name . nil))
    ;; ;; Avoid using helm when bugget at slime-read-symbol-name functions
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(slime-describe-symbol . nil)
    ;;              '(slime-describe-function . nil))

    ;; (defun helm-slime-completion-at-point-function ()
    ;;   #'helm-slime-complete)

    (defun slime-mode-hook-fn ()
      (company-mode -1)
      (smart-tab-mode 1))

    (add-hook 'slime-mode-hook #'slime-mode-hook-fn)

    (add-hook 'slime-repl-mode-hook
              #'slime-mode-hook-fn)

    (add-hook 'slime-repl-mode-hook
              #'local-disable-electric-pair-mode))


  ;; (use-package slime-company)

  (use-package helm-slime
    :config
    (setq helm-slime-complete-sources
          ;; '(helm-slime-fuzzy-complete-source)
          '(helm-slime-simple-complete-source helm-slime-fuzzy-complete-source helm-slime-compound-complete-source))
    (global-helm-slime-mode 1))
#+END_SRC
**** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal :keymaps 'slime-mode-map
    "K" 'slime-describe-symbol
    "M-." #'slime-edit-definition)

  (general-def :states 'normal :keymaps 'slime-repl-mode-map
    "<return>" #'slime-repl-return

    "I" #'comint-style-insert-line
    "A" #'comint-style-append-line
    "M-." #'slime-edit-definition)

  (leader-key-def 'normal slime-mode-map
                  "z" 'slime-switch-to-output-buffer
                  "c" 'slime-compile-file
                  "l" 'slime-load-file)

  (start-key-def 'normal slime-mode-map
                 "s" 'slime
                 "c" 'slime-connect)

  (eval-key-def 'normal slime-mode-map
    "b" 'slime-eval-buffer
    "f" 'slime-eval-defun)
  (eval-key-def 'visual 'slime-mode-map
                "r" 'slime-eval-region)
#+END_SRC

**** Parenscript
#+BEGIN_SRC emacs-lisp
  (let ((file "~/Code/common-lisp/parenscript/extras/js-expander.el"))
    (when (file-exists-p file)
      (load-file file)
      (map nil (lambda (x)
                 (slime-add-custom-expander (car x)
                                            (cdr x)
                                            "*Parenscript generated Javascript*"
                                            (if (featurep 'js) 'javascript-mode 'c-mode)
                                            #'read))
           '(("j" . ps:ps) ("d" . ps:ps-doc)))))

#+END_SRC
*** Sly
~sly~ is a fork of ~slime~.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (use-package sly
    :after evil
    :config

    ;; make functions for using specific lisp implementations.
    (defmacro define-sly-lisp (name command)
      `(defun ,name ()  (interactive)  (sly ,command)))

    (defmacro define-sly-lisp-defun (name fn)
      `(defun ,name ()  (interactive)  (sly (funcall ,fn))))

    (add-to-list 'sly-contribs 'sly-stickers)

    ;;(define-sly-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
    (define-sly-lisp sbcl "sbcl")
    (define-sly-lisp ecl "ecl --load ~/quicklisp/setup.lisp")
    (define-sly-lisp ccl "ccl")
    (define-sly-lisp clisp "clisp")

    (setq inferior-lisp-program "sbcl")
    ;; ;; Open sly debug buffers in emacs state, rather than evil state.
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(sly-read-symbol-name . nil))
    ;; ;; Avoid using helm when bugget at sly-read-symbol-name functions
    ;; (add-to-list 'helm-completing-read-handlers-alist
    ;;              '(sly-describe-symbol . nil)
    ;;              '(sly-describe-function . nil))

    (defun sly-mode-hook-fn ()
      ;; Sly completion at point provides out of order results in
      ;; company when `company-backends' contains other backends.
      (let ((backends '(company-capf)))
        (when (company-safe-backends-p backends)
          (setq-local company-backends backends)))) 

    (add-hook 'sly-mrepl-mode-hook #'local-disable-electric-pair-mode)

    (add-hook 'sly-mode-hook #'sly-mode-hook-fn)
    (add-hook 'sly-mrepl-mode-hook #'sly-mode-hook-fn)

    (cl-flet ((next () (interactive)
                    (forward-char)
                    (call-interactively #'sly-stickers-next-sticker))
              (prev () (interactive)
                    (backward-char)
                    (call-interactively #'sly-stickers-prev-sticker)))
      (cl-flet ((hydra-body (defhydra sly-stickers-jump () ("n" next) ("p" prev))))
        (general-def sly-mode-map
          "C-c C-s C-n" (lambda () (interactive) (next) (hydra-body))
          "C-c C-s C-p" (lambda () (interactive) (prev) (hydra-body)))))

    (general-def 'normal 'sly-mrepl-mode-map
      "<return>" #'sly-mrepl-return

      "I" #'comint-style-insert-line
      "A" #'comint-style-append-line)

    (general-def 'sly-mrepl-mode-map
      "M-p" #'comint-previous-matching-input-from-input
      "M-n" #'comint-next-matching-input-from-input))
#+END_SRC
**** COMMENT Sly Helm
#+BEGIN_SRC emacs-lisp
  (use-package helm-sly)
#+END_SRC
**** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def :states 'normal :keymaps 'sly-mode-map
    "K" 'sly-describe-symbol
    "M-." #'sly-edit-definition)

  (leader-key-def 'normal sly-mode-map
    "z" 'sly-switch-to-output-buffer
    "c" 'sly-compile-file
    "l" 'sly-load-file)

  (start-key-def 'normal sly-mode-map
    "s" 'sly
    "c" 'sly-connect)

  (eval-key-def 'normal sly-mode-map
    "b" 'sly-eval-buffer
    "f" 'sly-eval-defun)
  (eval-key-def 'visual 'sly-mode-map
    "r" 'sly-eval-region)
#+END_SRC
** Clojure
A popular lisp on the JVM.
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC
*** Cider
It's like ~slime~ for Clojure! Kinda.
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :config
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)
    (setq cider-shadow-cljs-command "shadow-cljs"))

  ;; some visual flare
  (use-package spinner)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal clojure-mode-map
  "s" 'cider-jack-in
  "z" 'cider-switch-to-repl-buffer
  "a" 'cider-close-ancillary-buffers)

(eval-key-def 'normal clojure-mode-map
  "b" 'cider-eval-buffer
  "f" 'cider-eval-defun-at-point)
#+END_SRC
** Scheme
*** Geiser
It's like ~slime~ for Scheme. Kinda.
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config

    (setq-default scheme-imenu-generic-expression
                  '((nil
                     "^(define\\(\\|-\\(generic\\(\\|-procedure\\)\\|method\\|public\\)\\)*\\s-+(?\\(\\sw+\\)" 4)
                    ("Types"
                     "^(define-class\\s-+(?\\(\\sw+\\)" 1)
                    ("Macros"
                     "^(\\(defmacro\\|define-macro\\|define-syntax\\)\\s-+(?\\(\\sw+\\)" 2)))

    (setq geiser-active-implementations '(guile))

    (setq geiser-guile-load-path nil)
    (with-eval-after-load 'geiser-guile
      (if (symbol-function 'guix-eval) 
          (mapcar (lambda (path)
                    (add-to-list 'geiser-guile-load-path path))
                  (read (car (guix-eval "%load-path"))))))

    ;; (add-to-list 'geiser-guile-load-path "~/Code/guix")

    (defun geiser-add-company-file-backend ()
      (setq company-backends
            (remove-if (lambda (backend) (eq backend 'company-files))
                       company-backends))
      (add-to-list 'company-backends 'company-files))

    (add-hook 'geiser-mode-hook
              #'geiser-add-company-file-backend)

    (add-hook 'geiser-repl-mode-hook
              #'geiser-add-company-file-backend)

    (add-hook 'geiser-repl-mode-hook
              #'local-disable-electric-pair-mode)

    ;; (defun geiser-repl--connection* ()
    ;;   (let ((buffer (if guix-devel-mode
    ;;                     (guix-get-repl-buffer t)
    ;;                   (geiser-repl--set-up-repl geiser-impl--implementation))))
    ;;     (and (buffer-live-p buffer)
    ;;          (get-buffer-process buffer)
    ;;          (with-current-buffer buffer geiser-repl--connection))))

    ;; geiser keybindings
    (leader-key-def 'normal geiser-mode-map
                    "z" 'geiser-mode-switch-to-repl
                    "c" 'geiser-compile-file
                    "l" 'geiser-load-file)

    ;; (defun geiser-connect-guix ()
    ;;   (interactive)
    ;;   (aif (guix-repl-socket-file-name)
    ;;        (geiser-connect-local 'guile (concat it
    ;;                                             "/repl-socket"))
    ;;        (error "Guix repl not active.")))

    (start-key-def 'normal geiser-mode-map
                   "s" 'geiser
                   "c" 'geiser-connect
                   )

    (eval-key-def 'normal geiser-mode-map
                  "b" 'geiser-eval-buffer
                  "f" 'geiser-eval-definition)
    (eval-key-def 'visual 'geiser-mode-map
                  "r" 'geiser-eval-region)
    (general-def
      :states 'normal
      :keymaps 'geiser-repl-mode-map))
#+END_SRC
** Python
*** COMMENT Linting
Python support is built in to ~flycheck~.
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'python-mode-hook #'flycheck-mode)
#+END_SRC
*** Language Server
Python support is built in to ~lsp-mode~.
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'python-mode-hook #'lsp)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal python-mode-map
    "z" 'python-shell-switch-to-shell)

  (start-key-def 'normal python-mode-map
    "s" 'run-python)

  (eval-key-def 'normal python-mode-map
    "b" 'python-shell-send-buffer
    "f" 'python-shell-send-defun)

  (eval-key-def 'visual 'python-mode-map
    "r" 'python-shell-send-region)
#+END_SRC
** COMMENT Lua
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
    ;; Don't always switch to lua repl after sending code.
    (setq lua-always-show nil))

  (start-key-def 'normal lua-mode-map
    "s" 'run-lua
    "l" (lambda () (interactive)
          (let ((exwm-manage-force-tiling t))
            (run-lua "love" "love" nil "."))))

  (eval-key-def 'normal lua-mode-map
    "b" 'lua-send-buffer
    "f" 'lua-send-defun
    "s" 'lua-send-string
    "l" 'lua-send-current-line
    "y" (lambda () (interactive)
          (lua-send-string "repl.y()")))

  (eval-key-def 'visual lua-mode-map
    "r" 'lua-send-region)
#+END_SRC
*** COMMENT Love
#+BEGIN_SRC emacs-lisp
  (use-package love-minor-mode
    :config
    ;(setq love-local-documentation-path "~/Documents/programming/documentation/lua-love-wiki/")
    )
#+END_SRC
*** COMMENT Autocomplete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete-lua
    ;; :straight t (:host github :repo "rolpereira/auto-complete-lua")
    :config
    (add-hook 'lua-mode-hook '(lambda ()
                                (setq ac-sources '(ac-source-lua))
                                (auto-complete-mode 1))))

  (use-package auto-complete-love
    :after auto-complete-lua
    ;; :straight t (:host github :repo "rolpereira/auto-complete-love")
    :config
    (add-hook 'lua-mode-hook '(lambda ()
                                (setq ac-sources '(ac-source-love))
                                (push ac-source-lua ac-sources)
                                (auto-complete-mode 1))))
#+END_SRC
*** Lank
#+BEGIN_SRC emacs-lisp
  (make-variable-buffer-local
   (defvar lua-send-string-signals nil
     "A list of integers or strings representing the signals to send
    to the lua process before sending a string."))

  (make-variable-buffer-local
   (defvar lua-send-string-post ""
     "This string is sent to the lua process after any string is sent"))

  (defun lua-send-string (str)
    "Send STR plus a newline to the Lua process.
  If `lua-process' is nil or dead, start a new process first."
    (unless (string-equal (substring str -1) "\n")
      (setq str (concat str "\n")))
    (let ((process (lua-get-create-process)))
      (dolist (sig lua-send-string-signals)
        (signal-process process sig))
      (process-send-string process str)
      (process-send-string process lua-send-string-post)))

  (make-variable-buffer-local
   (defvar lank-mode-running nil))

  (define-minor-mode lank-mode
    "Use signals to automatically send code to a running lua
  process."
    :lighter " Lank"
    (if lank-mode-running
        (progn
          (setq lank-mode-running nil)
          (setq lua-send-string-signals nil)
          (setq lua-send-string-post ""))
      (progn
        (setq lank-mode-running t)
        (setq lua-send-string-signals
              (list 'SIGUSR1))
        (setq lua-send-string-post
              (format "loadstring(%s);\n"
                      (lua-make-lua-string "coroutine.yield()"))))))
#+END_SRC
** Shen
#+BEGIN_SRC emacs-lisp
(use-package shen-mode :ensure t)

(leader-key-def 'normal shen-mode-map
  "z" 'switch-to-shen
  "c" 'shen-compile-file
  "l" 'shen-load-file)

(start-key-def 'normal shen-mode-map
  "s" 'run-shen)

(eval-key-def 'normal shen-mode-map
  "b" 'shen-eval-buffer
  "f" 'shen-eval-defun)

(eval-key-def 'visual 'shen-mode-map
  "r" 'shen-eval-region)
#+END_SRC
** Prolog
I use the built-in prolog mode.
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal prolog-mode-map
    "z" 'switch-to-prolog
    "c" 'prolog-compile-buffer)

  (start-key-def 'normal prolog-mode-map
    "s" 'run-swi-prolog)

  (eval-key-def 'normal prolog-mode-map
    "b" 'prolog-consult-buffer
    "f" 'prolog-consult-predicate)

  (eval-key-def 'visual 'prolog-mode-map
    "r" 'prolog-consult-region)
#+END_SRC
*** Helper functions
#+BEGIN_SRC emacs-lisp
  (defun run-swi-prolog ()
    (interactive)
    (let ((prolog-program-name "swipl"))
      (call-interactively 'run-prolog)))
#+END_SRC
** C/C++/CPP/Cpp/Sepples
*** COMMENT CQuery
A language server back end for C/++
#+BEGIN_SRC emacs-lisp
(use-package cquery
  :after projectile
  :init
  (add-hook 'c-mode-hook #'cquery//enable)
  (add-hook 'c++-mode-hook #'cquery//enable)
  :config
  (defun cquery//enable ()
    (condition-case nil
        (lsp)
      (user-error nil)))
  (setq cquery-executable "cquery")
  (setq cquery-extra-init-params '(:cacheFormat "msgpack"))
  (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".cquery")
                projectile-project-root-files-top-down-recurring)))
#+END_SRC
*** COMMENT Font lock
Corrects font lock for modern C++.
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock
    :config
    (add-hook 'c++-mode-hook #'modern-c++-font-lock-mode))
#+END_SRC
*** Linting
Enable ~flycheck~
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'flycheck-mode)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal c-mode-base-map
                  "s" nil
                  "c" nil
                  "r" nil)
#+END_SRC
*** Style
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4
              c-default-style "linux")
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
  (add-hook 'rust-mode-hook #'lsp)
#+END_SRC
** Julia
#+BEGIN_SRC emacs-lisp
  (use-package julia-mode)
#+END_SRC
** C Sharp
#+BEGIN_SRC emacs-lisp
  (use-package omnisharp
    :ensure t
    :after company
    :config
    (add-hook 'csharp-mode-hook 'omnisharp-mode)
    (add-to-list 'company-backends 'company-omnisharp)
    (add-hook 'csharp-mode-hook #'flycheck-mode)

    (defun omnisharp--resolve-omnisharp-server-executable-path ()
      (executable-find "omnisharp"))
  
    (leader-key-def :states 'normal :keymaps 'omnisharp-mode-map
                    "e" #'recompile
                    "r" #'omnisharp-run-code-action-refactoring))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :config
  ;; allows capf and dabbrev backends while using haskell
  (add-hook 'haskell-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   (append '((company-capf company-dabbrev-code))
                           company-backends)))))
#+END_SRC
** ATS
#+BEGIN_SRC emacs-lisp
  (when (require 'ats-mode nil t)
    (add-to-list 'load-path  "~/Code/ats/ATS-Postiats/utils/emacs")
    (require 'ats-mode "ats2-mode")
    (require 'ats2-flymake "flymake-ats2")

    (defvar-local flymake-do-after-change t)

    (defun flymake-after-change-advice (oldfun &rest args)
      (when flymake-do-after-change
        (apply oldfun args)))

    (advice-add 'flymake-after-change-function
                :around
                #'flymake-after-change-advice)

    (defun ats-flymake-hook-fn ()
      (flymake-mode)
      (setq flymake-do-after-change nil))

    (add-hook 'ats-mode-hook
              #'ats-flymake-hook-fn)
    ;; (setenv "ATSHOME" "~/code/ats/ATS-Postiats/")

    )
#+END_SRC
** COMMENT Elm
#+BEGIN_SRC emacs-lisp
(use-package flycheck-elm
  :config
  (add-hook 'flycheck-mode-hook 'flycheck-elm-setup))
  
(use-package elm-mode)
#+END_SRC
** Javascript
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.\\(?:js\\|jsx\\|ts\\|tsx\\)\\'" . web-mode))
#+END_SRC
** COMMENT Javascript
#+BEGIN_SRC emacs-lisp
  (use-package indium
    :ensure t
    :config
    (defun me/indium-local-advice (old-fun &rest args)
      (let ((indium-client-executable (aif (projectile-project-root)
                                           (concat it "node_modules/.bin/indium")
                                           indium-client-executable)))
        (apply old-fun args)))
    (advice-add 'indium-client-start :around
                #'me/indium-local-advice)

    (defun me/region-for-defun-at-point (&optional pos)
      "Return a list (START END) for the positions of defun at POS.
  POS defaults to point"
      (save-excursion
        (save-match-data
          (goto-char (or pos (point)))
          (end-of-defun)
          (let ((end (point)))
            (beginning-of-defun)
            (list (point) end)))))

    (defun me/indium-eval-toplevel-form ()
      (interactive)
      (indium-eval (save-excursion
                     (save-match-data
                       (apply #'buffer-substring-no-properties
                              (me/region-for-defun-at-point))))
                   (lambda (value)
                     (indium-interaction--handle-eval-result value))))

    (eval-key-def 'normal 'js-mode-map
                  "b" #'indium-eval-buffer
                  "f" #'me/indium-eval-toplevel-form
                  "i" #'indium-eval-defun)

    (eval-key-def 'visual 'js-mode-map
                  "r" #'indium-eval-region)

    (remove-hook 'js-mode-hook
                 #'indium-interaction-mode))

  (use-package js2-mode
    :config
    ;; (add-to-list 'auto-mode-alist
    ;;              '("\\.jsm?\\'" . js2-mode))
    (add-to-list 'aggressive-indent-excluded-modes 'js-mode)
    ;; (add-hook 'js-mode-hook #'js2-minor-mode)
    (setq js2-mode-show-strict-warnings nil)
    (setq js2-basic-offset 2))
#+END_SRC
** COMMENT Java
#+BEGIN_SRC emacs-lisp
  (use-package lsp-java)
#+END_SRC
** HTML
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))

  (use-package emmet-mode
    :config
    ;; (add-to-list 'auto-mode-alist '("\\.html?\\'" . emmet-mode))
    (add-hook 'web-mode #'emmet-mode))

#+END_SRC
** Guix
Tools for Guix, a package manager and operating system.
#+BEGIN_SRC emacs-lisp
  (if (not (string-equal "Ubuntu" (which-linux-distribution)))
      (use-package guix
        :after yasnippet
        :config
        (add-to-path "~/.guix-profile/bin/")

        (setq guix-load-path me/guix-config-dir)

        (with-eval-after-load 'guix-external
          (add-to-list 'guix-guile-program  "--listen=37146" t))

        (add-hook 'geiser-mode-hook #'guix-devel-mode)

        (add-to-list 'yas-snippet-dirs "~/Code/guix/etc/snippets")

        (guix-prettify-global-mode +1)
        (delight 'guix-prettify-global-mode "" t)


        ;; shut up error
        ;; (defun guix-repl-autoload-emacs-packages-maybe ()
        ;;     "Load autoloads for Emacs packages if needed.
        ;; See `guix-emacs-activate-after-operation' for details."
        ;;     (and guix-emacs-activate-after-operation
        ;;          (require 'guix-emacs nil t)
        ;;          ;; FIXME Since a user can work with a non-current profile (using
        ;;          ;; C-u before `guix-search-by-name' and other commands), emacs
        ;;          ;; packages can be installed to another profile, and the
        ;;          ;; following code will not work (i.e., the autoloads for this
        ;;          ;; profile will not be loaded).
        ;;          (guix-emacs-autoload-packages)))

        ;; avoid error when deleting and re-starting guix repl
        (with-eval-after-load 'geiser-repl
          (defun geiser-repl--narrow-to-prompt ()
            "Narrow to active prompt region and return t, otherwise returns nil."
            (if (get-buffer-process (current-buffer))
                (let* ((proc (get-buffer-process (current-buffer)))
                       (pmark (and proc (process-mark proc)))
                       (intxt (and pmark
                                   (when (>= (point) (marker-position pmark))
                                     (save-excursion
                                       (if comint-eol-on-send
                                           (if comint-use-prompt-regexp
                                               (end-of-line)
                                             (goto-char (field-end))))
                                       (buffer-substring pmark (point))))))
                       (prompt-beg (and pmark (marker-position pmark)))
                       (prompt-end (and prompt-beg (+ prompt-beg (length intxt)))))
                  (when (> (length intxt) 0)
                    (and prompt-end (narrow-to-region prompt-beg prompt-end))
                    t))
              nil)))
        ;;       (defun guix-fix-completion ()
        ;;         (defvar guix-help-parse-command-regexp
        ;;           (rx bol "    "
        ;;               (group wordchar (one-or-more (or wordchar "-"))))
        ;;           "Regexp used to find guix commands.
        ;; 'Command' means any option not prefixed with '-'.  For example,
        ;; guix subcommand, system action, importer, etc.")

        ;;         (guix-pcomplete-define-options-finder guix-pcomplete-commands
        ;;           "If COMMANDS is nil, return a list of available guix commands.
        ;; If COMMANDS is non-nil (it should be a list of strings), return
        ;; available subcommands, actions, etc. for 'guix COMMANDS'."
        ;;           guix-help-parse-command-regexp)

        ;;         (progn
        ;;           (guix-geiser-eval-in-repl-synchronously
        ;;            "(load-from-path \"/home/adrian/Code/guile/guix/guix/gexp.scm\")" guix-internal-repl-buffer t t)
        ;;           (guix-geiser-eval-in-repl-synchronously
        ;;            ",m (emacs-guix)" guix-internal-repl-buffer t t)
        ;;           )
        ;;         )
        ;;       (add-hook 'guix-repl-after-start-hook
        ;;                 #'guix-fix-completion)

        ;; broken
        (fmakunbound 'pcomplete/guix)
        ))
#+END_SRC

** Nix
Tools for Nix, a package manager and operating system.
*** COMMENT Sandbox
Features for dealing with nix-shell in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package nix-sandbox)
#+END_SRC
*** Nix language support
#+BEGIN_SRC emacs-lisp
  ;; (use-package company-nixos-options
  ;;   :hook (nix-mode-hook . (lambda () (add-to-list 'company-backends 'company-nixos-options))))

  (use-package nix-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
    (add-hook 'nix-mode-hook
              (lambda ()
                (setq tab-always-indent nil)
                (setq indent-tabs-mode t))))

#+END_SRC
*** COMMENT Updating Nix hashes
#+BEGIN_SRC emacs-lisp
  (use-package nix-update)
#+END_SRC
*** COMMENT Nixos options search
#+BEGIN_SRC emacs-lisp
  (use-package nixos-options)
  (use-package helm-nixos-options)
#+END_SRC
** Bash
#+BEGIN_SRC emacs-lisp
  (auto-mode-add 'sh-mode ; set shell mode for configuration files as they appear in this repository.
                 "\\(/\\|\\`\\)\\(bash_\\(aliases\\|profile\\|history\\|log\\(in\\|out\\)\\)\\|z?log\\(in\\|out\\)\\)\\'"
                 "\\(/\\|\\`\\)\\(shrc\\|zshrc\\|m?kshrc\\|bashrc\\|inputrc\\|t?cshrc\\|esrc\\)\\'"
                 "\\(/\\|\\`\\)\\([kz]shenv\\|xinitrc\\|startxrc\\|xsession\\)\\'")
#+END_SRC
*** Auto Mode
Enter ~common-lisp-mode~ in the following files
#+BEGIN_SRC emacs-lisp
  (auto-mode-add 'common-lisp-mode
       ".sbclrc\\'"
       ".lisprc\\'"
       ".otherlisprc\\'")
#+END_SRC


** Org
~org-mode~ is a markup mode with many features which include creating
literate source files like this one.
#+BEGIN_SRC emacs-lisp
  (setq header-line-format " ")
  ;;(add-hook 'org-mode-hook '(load-theme-buffer-local 'tsdh-light (current-buffer)))
  ;; (lambda () (progn
  ;;              (setq left-margin-width 2)
  ;;              (setq right-margin-width 2)
  ;;              (set-window-buffer nil (current-buffer))))
  ;;(setq line-spacing 0.1)
  (setq org-startup-indented t
        ;;org-bullets-bullet-list '(" ") ;; no bullets, needs org-bullets package
        ;;org-ellipsis "  " ;; folding symbol
        org-pretty-entities t
        org-hide-emphasis-markers nil
        ;; show actually italicized text instead of /italicized text/
  ;;;org-agenda-block-separator ""
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t
        org-src-ask-before-returning-to-edit-buffer nil
        org-src-window-setup 'current-window)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((lisp . t)
     (python . t)))
  (setq org-babel-lisp-eval-fn #'sly-eval)
  (setq org-babel-python-eval-fn #'python-send-string)

  (require 'delight)
  (delight 'auto-fill-function "" t)
  (delight 'org-indent-mode "" t)

  (add-hook 'org-mode-hook #'visual-line-mode)
  (add-hook 'org-mode-hook #'company-mode-disable)

  (leader-key-def 'normal org-src-mode-map
                  "q" 'org-edit-src-exit)

  (defun me/org-open-at-point (&rest args)
    "org-open-at-point except it does the jumpy jump"
    (interactive)
    (let ((point (point)))
      (org-open-at-point args)
      (evil-set-jump point)))

  (my-visual-line-mode-rebind org-mode-map)

  (defun org-mode-hook-fn ()
    (general-def :states 'normal :keymaps 'org-mode-map
      "RET" 'me/org-open-at-point))

  (add-hook 'org-mode-hook
            #'org-mode-hook-fn)

  ;; silly alternative to a hook
  (defun org-babel-edit-prep:emacs-lisp (babel-info)
    (setq lexical-binding t))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def org-mode-map
    "C-c C-'" #'org-edit-src-code-or-make-block)
#+END_SRC
*** Org src mode
Settings for editing code in org src blocks
**** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-def org-src-mode-map
    "C-c C-'" #'org-edit-src-exit)
#+END_SRC
**** Source block generation
#+BEGIN_SRC emacs-lisp
  (defun me/org-in-src-block-p ()
    (let* ((element (org-element-at-point))
           (type (org-element-type element)))
      (if (and (memq type '(example-block src-block))
               (org-src--on-datum-p element))
          t nil)))

  (defun org-get-src-language ()
    (save-excursion
      (goto-char (point-min))
      (cl-labels
          ((rec ()
                (or (plist-get (second (org-element-at-point))
                               :language)
                    (and (forward-line)
                         (< (line-number-at-pos)
                            (count-lines (point-min)
                                         (point-max)))
                         (rec)))))
        (rec))))

  (defun org-edit-src-code-or-make-block ()
    (interactive)
    (unless (me/org-in-src-block-p)
      (let ((language (or (org-get-src-language)
                          (read-string "Language: "))))
        (move-end-of-line nil)
        (insert (format "
  ,#+BEGIN_SRC %s

  ,#+END_SRC"
                        language))))
    (org-edit-src-code))

  (general-def :states 'normal :keymaps 'org-mode-map
    "C-`" 'org-edit-src-code-or-make-block)
#+END_SRC

**** Source block jumping hydra
A hydra to jump between org-babel source blocks:
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-org-babel-source-block-jump (org-mode-map "C-c C-v")
    "Jump between org babel source blocks"
    ("n" org-babel-next-src-block)
    ("p" org-babel-previous-src-block))

  (general-def org-mode-map
    "C-c C-v C-n" #'hydra-org-babel-source-block-jump/org-babel-next-src-block
    "C-c C-v C-p" #'hydra-org-babel-source-block-jump/org-babel-previous-src-block)
#+END_SRC
**** Block splitting
#+BEGIN_SRC emacs-lisp
  (defun org-src-split-block ()
    "Split a source block at point. Not 100% functional."
    (interactive)
    (if (not (and (org-in-src-block-p)
                  (save-excursion
                    (forward-line)
                    (org-in-src-block-p))))
        (user-error "Not in source block")
      (move-end-of-line nil)
      (insert   "
  ,#+END_SRC
  ")
      (let ((pos (point)))
        (insert
         (format
          "
  ,#+BEGIN_SRC %s"
          (plist-get (second (org-element-at-point))
                     :language)))
        (goto-char pos))))
#+END_SRC
*** Table auto allign
#+BEGIN_SRC emacs-lisp
  (require 'subr-x)

  (defvar org-table-auto-align-in-progress nil)

  (defun org-table-auto-align (begin end length)
    (save-match-data
      (unless (or org-table-auto-align-in-progress
                  (not (org-at-table-p))
                  (and (eq this-command 'org-self-insert-command)
                       (member (this-command-keys)
                               '(" " "+" "|" "-"))))
        (run-with-idle-timer
         0 nil
         (lambda ()
           (if (looking-back "| *\\([^|]+\\)")
               (let ((pos (string-trim-right (match-string 1))))
                 (setq org-table-auto-align-in-progress t)
                 (unwind-protect
                     (progn
                       (org-table-align)
                       (search-forward pos nil t))
                   (setq org-table-auto-align-in-progress nil)))))))))

  (define-minor-mode org-table-auto-align-mode
    "A mode for aligning Org more tabales automatically as you type."
    :lighter ""
    (if org-table-auto-align-mode
        (add-hook 'after-change-functions #'org-table-auto-align t t)
      (remove-hook 'after-change-functions #'org-table-auto-align t)))

  ;; (add-hook 'org-mode-hook
  ;;           #'org-table-auto-align-minor-mode)
#+END_SRC
*** COMMENT Toc-org
Create a table of contents without exporting.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :ensure t
  :config
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC
*** Agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/Documents/notes/" "~/dotfiles/"))
#+END_SRC
*** COMMENT superstar

#+BEGIN_SRC emacs-lisp
  (use-package org-superstar
    :config
    (add-hook 'org-mode-hook
              #'org-superstar-mode))
#+END_SRC
*** COMMENT Zettelkasten

Slip-box method of note-taking (like a personal wiki) using ~org-roam~

#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :delight
    :config
    (setf org-roam-directory "~/Documents/notes/zettelkasten/")
    (add-hook 'after-init-hook 'org-roam-mode))
#+END_SRC

* External tools
#+BEGIN_SRC emacs-lisp
  ;; startup programs
  (define-multi-macro startup-programs start-process-shell-command 3)

  ;; (when (featurep 'exwm)
  ;;     (startup-programs
  ;;      "networkmanager applet" nil "nm-applet"
  ;;      "compton" nil "compton --config ~/comptonconfig.txt"
  ;;      "avfs" nil "mountavfs"
  ;;      "restart redshift" nil "systemctl --user restart redshift.service"))

  ;; (use-package prodigy)

  (use-package openwith
    :config
    ;; from https://emacs.stackexchange.com/questions/17095/how-supress-dired-confirmation-of-large-file-for-specific-extensions?rq=1
    (defvar my-ok-large-file-types
      "\\.\\(?:mpe?g\\|png\\|m4v\\|mkv\\|mp4\\|mp3\\|avi\\|flv\\|mov\\|gif?\\|webm\\)$"
      "Regexp matching filenames which are definitely ok to visit,
  even when the file is larger than `large-file-warning-threshold'.")

    (defun abort-if-file-too-large-whitelist (old-fun &rest args)
      (unless (string-match-p my-ok-large-file-types (third args))
        (apply old-fun args)))

    (advice-add #'abort-if-file-too-large
                :around
                'abort-if-file-too-large-whitelist)

    ;; (defadvice abort-if-file-too-large (around my-check-ok-large-file-types)
    ;;   "If FILENAME matches `my-ok-large-file-types', do not abort."
    ;;   (unless (string-match-p my-ok-large-file-types (ad-get-arg 2))
    ;;     ad-do-it))
    ;; (ad-deactivate 'abort-if-file-too-large)

    (setq openwith-associations
          '(("\\.\\(?:mpe?g\\|m4v\\|mp4\\|mp3\\|avi\\|flv\\|mov\\|gif?\\|webm\\)$"
             "mpv" ("--loop" file))
            ("\\.\\(?:mkv\\)$"
             "mpv" (file))))
    (openwith-mode +1))

  (general-def process-menu-mode-map
    "M-D" #'process-menu-delete-process)
#+END_SRC
* Emacs does everything
** Writing
Olivetti creates an environment fit for writing

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :config)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap)
#+END_SRC
** COMMENT Spotify
Control spotify running on any device from Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package spot4e :load-path "~/code/elisp/spot4e"
    :after general
    :requires helm url json
    :config
    (setq spot4e-refresh-token me/spotify-refresh-token)
    (run-with-timer 0 (* 60 59) 'spot4e-refresh))

  (define-subleader :leader alt-leader
    "s" "spotify" spotify-key-def)

  (spotify-key-def 'normal emacs-lisp-mode-map
    "b" 'spot4e-helm-search-user-tracks
    "a" 'spot4e-helm-search-albums
    "s" 'spot4e-player-pause
    "p" 'spot4e-player-play
    "n" 'spot4e-player-next
    "N" 'spot4e-player-previous)

  (defun spot4e-player-volume (volume)
    "Set the volume on Spotify active device."
    (interactive "nVolume: ")
    (if (or (> volume 100) (< volume 0))
        (error "Volume must be between 1 and 100"))
    (spot4e-request "PUT"
                    (concat spot4e-player-url "volume")
                    (concat "?volume_percent=" (number-to-string volume))
                    nil
                    `(("Authorization" . ,(concat "Bearer " spot4e-access-token )))))

    ;; (spot4e-player-do-action "PUT" (concat "/volume?volume_percent=" (number-to-string volume)))
#+END_SRC
** Emacs window manager (EXWM)
*** Main Package
Call emacsclient with ~-f exwm-enable~ in order to start exwm.
#+BEGIN_SRC emacs-lisp
  (setq mouse-autoselect-window nil
        focus-follows-mouse nil)

  (use-package exwm
    :delight
    :config

    (defvar clear-minibuffer-delay "2 sec")

    (require 'exwm-randr)

    (setq exwm-randr-workspace-monitor-plist '(0 "eDP" 1 "HDMI-A-0"))
    (add-hook 'exwm-randr-screen-change-hook
              (lambda ()
                (start-process-shell-command
                 "xrandr" nil "xrandr --output HDMI-A-0 --left-of eDP --auto")))
    (exwm-randr-enable)

    (defun clear-minibuffer ()
      (message nil))

    (let ((timer nil))
      (defun clear-minibuffer-delayed ()
        (when (current-message)
          (when (find timer timer-list)
            (cancel-timer timer))
          (setq timer
                (run-with-timer clear-minibuffer-delay nil
                                #'clear-minibuffer)) )))


    (defun set-clear-minibuffer-delayed ()
      (interactive)
      (add-hook 'post-command-hook
                #'clear-minibuffer-delayed
                nil t))

    (defun unset-clear-minibuffer-delayed ()
      (interactive)
      (remove-hook 'post-command-hook
                   #'clear-minibuffer-delayed t))

    (fringe-mode 1)
    (require 'exwm-config)

    ;; Make sure minibuffer-line is visible after a command.
    (add-hook 'exwm-mode-hook #'set-clear-minibuffer-delayed)

    (add-hook 'exwm-update-class-hook
              (lambda ()
                (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-title))))

    (general-def :keymaps 'exwm-mode-map
      "C-c" nil ; so that C-c can be used for copy in many
                                          ; applications. I put all emacs bindings for exwm behind
                                          ; the super key.
      ;; "C-c C-f" 'exwm-layout-toggle-fullscreen
      ;; "C-c C-l" 'exwm-floating-toggle-floating
      )

    (defun me/launch (command))

    (defun me/exwm-maybe-make-defualt-directory ()
      (when me/exwm-always-home-dir
        (setq default-directory "~/")
        (setq me/exwm-always-home-dir nil)))

    (add-hook 'exwm-manage-finish-hook #'me/exwm-maybe-make-defualt-directory)

    (defvar me/exwm-always-home-dir nil)

    (require 'helm-qutebrowser)

    (let ((tp-on t))
      (defun ttp () (interactive)
             (if tp-on (progn
                         (start-process-shell-command "ttp" nil "xinput disable 13")
                         (message "t off")
                         (setq tp-on nil))
               (start-process-shell-command "ttp" nil "xinput enable 13")
               (message "t on")
               (setq tp-on t))))

    (customize-set-variable
     'exwm-input-global-keys
     `(;; Bind "s-r" to exit char-mode and fullscreen mode.
       ([?\s-r] . exwm-reset)

       ;; Bind f11 to toggle full screen
       ([f11] . exwm-layout-toggle-fullscreen)

       ;; Bind "s-!" and "s-@" to launch exteral commands with READ-SHELL-COMMAND
       ([?\s-!] . (lambda (command)
                    (interactive (list (read-shell-command "! ")))
                    (setq me/exwm-always-home-dir t)
                    (start-process-shell-command command nil command)))
       ([?\s-@] . (lambda (command)
                    (interactive (list (read-shell-command "@ ")))
                    (setq me/exwm-always-home-dir nil)
                    (start-process-shell-command command nil command)))

       ([?\s-`] . helm-qutebrowser)
       ([?\s-1] . eshell-here)
       ([?\s-2] . (lambda nil (interactive) (find-file default-directory)))
       ([?\s-3] . (lambda nil (interactive) (eshell-at-or-switch "~/")))

       (,(kbd "<s-f1>"). previous-buffer)
       (,(kbd "<s-f2>"). next-buffer)

       ;; ,@(mapcar (lambda (n)
       ;;             `(,(kbd (format "s-%d" n)) .
       ;;               (lambda ()
       ;;                 (interactive)
       ;;                 (eshell ,n))))
       ;;           (number-sequence 1 3))


       (,(kbd "<print>") . (lambda () (interactive)
                             (let ((command "screengrab"))
                               (start-process-shell-command command nil command))))

       (,(kbd "<XF86MonBrightnessUp>"). desktop-brightness-increment-large)
       (,(kbd "<XF86MonBrightnessDown>" ). desktop-brightness-decrement-large)
       (,(kbd "<S-XF86MonBrightnessUp>" ). desktop-brightness-increment-normal)
       (,(kbd "<S-XF86MonBrightnessDown>" ) . desktop-brightness-decrement-normal)
       (,(kbd "<C-XF86MonBrightnessUp>" ). desktop-brightness-increment-small)
       (,(kbd "<C-XF86MonBrightnessDown>" ) . desktop-brightness-decrement-small)

       (,(kbd "<XF86AudioRaiseVolume>") . desktop-volume-increment-large)
       (,(kbd "<XF86AudioLowerVolume>") . desktop-volume-decrement-large)
       (,(kbd "S-<XF86AudioRaiseVolume>") . desktop-volume-increment-normal)
       (,(kbd "S-<XF86AudioLowerVolume>") . desktop-volume-decrement-normal)
       (,(kbd "C-<XF86AudioRaiseVolume>") . desktop-volume-increment-small)
       (,(kbd "C-<XF86AudioLowerVolume>") . desktop-volume-decrement-small)
       (,(kbd "<XF86AudioMute>") . pulseaudio-control-toggle-current-sink-mute)

       (,(kbd "<s-f12>") . ttp)
       (,(kbd "<s-f11>") . (lambda ()
                             (interactive)
                             (start-process-shell-command "toggle redshift" nil
                                                          "pkill -USR1 '^redshift$'")))


       ;; Bind "s- " to launch external commands through my launcher.
       ([?\s- ] . exlaunch)

       ;; Winconf
       ([s-return] . helm-winconf)

       ;; bind "s-[direction] to switch windows"
       ([?\s-v] . evil-window-vsplit)
       ([?\s-s] . evil-window-split)

       ;; bind "s-[direction] to switch windows"
       ([?\s-h] . windmove-left)
       ([?\s-j] . windmove-down)
       ([?\s-k] . windmove-up)
       ([?\s-l] . windmove-right)

       ;; bind "s-arrow" to move, "maximize" or "minimize" a window
       ([s-right] . windows-right)
       ([s-down] . evil-quit)
       ([s-up] . delete-other-windows)
       ([s-left] . windows-left)

       ;; lock screen
       ([?\s-o] . desktop-environment-lock-screen)

       ;; symon mode toggle
       ([?\s-\\] . symon-mode)

       ;; toggle window floating
       ([?\s-/] . exwm-floating-toggle-floating)

       ;; switch between buffers
       ([s-tab] . evil-buffer)

       ;; switch to scratch winconf and scratch buffer
       ([?\s-0] . org-agenda)

       ([?\s-u] . hydra-winner/winner-undo)
       ;; ([?\s-c ?\u] . hydra-winner/winner-undo)
       ;; ([?\s-c ?\r] . hydra-winner/winner-redo)
       ;; ([?\s-c ?\l] . exwm-floating-toggle-floating)
       ;; bind "s-z" to M-x
       ([?\s-z] . helm-M-x)
       ;; bind "s-;" to ex mode
       ([?\s-\;] . evil-ex)
       ;; bind "s-b" to buffer switching
       ([?\s-b] . me/helm-buffer)
       ;; bind "s-f" to file switching
       ([?\s-f] . helm-find-files)
       ;; bind "s-q" to kill this buffer, closing the current
       ;; program, and "s-w" to kill the current buffer AND window
       ([?\s-w] . actually-kill-this-buffer)
       ([?\s-q] . evil-delete-buffer)
       ([?\s-a] . bury-evil-buffer)
       ([?\s-A] . unbury-interesting-buffer)
       ([?\s-g] . guix)
       ;; bind "s-g" to keyboard-quit
       ([?\s-G] . keyboard-quit)))

    ;; ;; start in char mode by default
    ;; (setq exwm-manage-configurations '((t char-mode t)))
    (setq exwm-manage-configurations '(((string-match-p "^ ?Dwarf Fortress -" exwm-title)
                                        floating t)))


    ;; sys tray
    (require 'exwm-systemtray)
    (setq exwm-systemtray-height 17)
    (exwm-systemtray-enable)

    ;; set prefix keys
    (setq exwm-input-prefix-keys (append
                                  (list
                                   ?\s-,
                                   ;; ?\C-w
                                   ?\s-m
                                   (elt (kbd "C-g") 0)
                                   (elt (kbd "M-<tab>") 0)
                                   (elt (kbd "<XF86AudioPause>") 0)
                                   (elt (kbd "<M-iso-lefttab>") 0)
                                   (elt (kbd "s-<tab>") 0)
                                   (elt (kbd "<s-iso-lefttab>") 0))
                                  (cl-mapcar (lambda (i) (elt (kbd (concat "C-M-" (number-to-string i))) 0))
                                             (iota 10))))

    (setq exwm-input-simulation-keys
          `((,(kbd "s-C-w") . [?\C-w])))

    ;; Allow pulling a window between workspaces by switching to its buffer
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    ;; Redefine function to fix global-display-line-numbers-mode bug
    ;; regarding the exwm "frame" not having the 'client parameter
    (defun display-line-numbers--turn-on ()
      "Turn on `display-line-numbers-mode'."
      (unless (or (minibufferp)
                  ;; taken from linum.el
                  nil
                  ;; (and (daemonp) (null (frame-parameter nil 'client)))
                  )
        (display-line-numbers-mode 1))))
#+END_SRC
*** COMMENT Named Workspaces
I wrote a small package to replace the numbered workspaces of exwm
with named ones. This includes creation, deletion, and switching by
narrowing name.
#+BEGIN_SRC emacs-lisp
  (require 'exwm-named-workspace)

  ;; ; (exwm-named-workspace-make "scratch")
#+END_SRC

This is a hydra to switch between workspaces in the classic "Alt-tab"
style

#+BEGIN_SRC emacs-lisp
  (lexical-let ((history-element 0))
    (defun workspace-history-delta (delta)
      (exwm-named-workspace-history (+ history-element delta) t)
      (incf history-element delta))

    (general-def
     "M-<tab>" (lambda ()
                 (interactive)
                 (workspace-history-delta 1)
                 (hydra-workspace-history/body)))

    (defhydra hydra-workspace-history (:timeout 2
                                       :post (progn
                                               (setq history-element 0)
                                               (exwm-named-workspace-update-history)))
      "Workspace history: "
      ("M-<tab>" (workspace-history-delta 1))
      ;; ("s-<S-iso-lefttab>" (workspace-history-delta -1))
      ("<M-iso-lefttab>" (workspace-history-delta -1))))
#+END_SRC
*** Exlaunch
I wrote a package to launch programs which integrates with ~exwm~ and
~exwm-named-workspaces~.
#+BEGIN_SRC emacs-lisp
  (require 'exlaunch)

  (define-multi-macro-clauses exlaunch-shortcuts exlaunch-shortcut
    "Define functions to launch programs. ")

  (exlaunch-shortcuts
   multimc
   next
   icecat
   firefox
   krita
   gimp)
#+END_SRC
*** Symon system monitor
#+BEGIN_SRC emacs-lisp
  (use-package symon)
#+END_SRC
*** Helm EXWM
~Helm-EXWM~ defines helm sources for exwm buffers
#+BEGIN_SRC emacs-lisp
  (use-package helm-exwm
    :config
    (setq helm-exwm-buffer-max-length 120)

    ;; preview buffer when switching
    (add-to-list 'helm-source-names-using-follow "EXWM buffers")

    (general-def :keymaps 'helm-exwm-map
      "M-d" #'helm-buffer-run-kill-persistent
      "S-<return>" #'helm-buffer-switch-buffers-other-window)

    (require 'helm-next)

    ;; ;; Separate EXWM and qutebrowser buffers in helm-mini
    ;; (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
    ;; (setq helm-exwm-source (helm-next-build-exwm-source))
    ;; (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
    ;;                                   helm-exwm-source
    ;;                                   helm-next--buffers-source
    ;;                                   helm-source-recentf))
    (setq helm-mini-default-sources `(helm-source-buffers-list
                                      helm-source-recentf
                                      helm-source-buffer-not-found)))
#+END_SRC
**** Helm Next
A helm source to switch between Next browser window) or to
search for url if a matching tab is not found.
#+BEGIN_SRC emacs-lisp
  (require 'helm-next)
#+END_SRC
*** Desktop Environment
#+BEGIN_SRC emacs-lisp
  (use-package pulseaudio-control
    :config
    (setq pulseaudio-control-use-default-sink t))

  (defmacro define-increment-functions (type
                                        get-command
                                        get-regex
                                        set-command
                                        argument-large-increment
                                        argument-normal-increment
                                        argument-small-increment
                                        argument-large-decrement
                                        argument-normal-decrement
                                        argument-small-decrement)
    (let ((getter-fn-name (intern (concat "desktop-" type "-get"))))
      `(progn
         ,(when get-command
            `(defun ,getter-fn-name ()
               (let ((output ,(if (stringp get-command)
                                  `(shell-command-to-string ,get-command)
                                `(funcall ,get-command))))
                 (save-match-data
                   (string-match ,get-regex output)
                   (match-string 1 output)))))
         ,@(mapcar
            (lambda (l)
              `(defun ,(intern (concat "desktop-" type (car l))) ()
                 (interactive)
                 ,(if (stringp set-command)
                      `(shell-command-to-string ,(format set-command (cadr l)))
                    `(funcall ,set-command ,(cadr l)))
                 ,(when get-command `(message ,(concat type ": %s") (,getter-fn-name)))))
            `(("-increment-large" ,argument-large-increment)
              ("-increment-normal" ,argument-normal-increment)
              ("-increment-small" ,argument-small-increment)
              ("-decrement-large" ,argument-large-decrement)
              ("-decrement-normal" ,argument-normal-decrement)
              ("-decrement-small" ,argument-small-decrement))))))

  (define-increment-functions
    "brightness"
    "brightnessctl" "\\([0-9]+%\\)"
    "brightnessctl set %s"
    "10%+" "5%+" "1%+" "10%-" "5%-" "1%-")

  (defun pulseaudio-set-volume (percent)
    (let ((pulseaudio-control-volume-step (format "%d%%" (abs percent))))
      (if (minusp percent)
          (pulseaudio-control-decrease-volume)
        (pulseaudio-control-increase-volume))))

  (define-increment-functions
    "volume"
    nil nil
    #'pulseaudio-set-volume
    5 2 1 -5 -2 -1)

  (general-def
    "<XF86MonBrightnessUp>" #'desktop-brightness-increment-large
    "<XF86MonBrightnessDown>" #'desktop-brightness-decrement-large
    "<S-XF86MonBrightnessUp>" #'desktop-brightness-increment-normal
    "<S-XF86MonBrightnessDown>" #'desktop-brightness-decrement-normal
    "<C-XF86MonBrightnessUp>" #'desktop-brightness-increment-small
    "<C-XF86MonBrightnessDown>" #'desktop-brightness-decrement-small)

  (general-def
    "<XF86AudioRaiseVolume>" #'desktop-volume-increment-large
    "<XF86AudioLowerVolume>" #'desktop-volume-decrement-large
    "S-<XF86AudioRaiseVolume>" #'desktop-volume-increment-normal
    "S-<XF86AudioLowerVolume>" #'desktop-volume-decrement-normal
    "C-<XF86AudioRaiseVolume>" #'desktop-volume-increment-small
    "C-<XF86AudioLowerVolume>" #'desktop-volume-decrement-small
    "<XF86AudioMute>" #'pulseaudio-control-toggle-current-sink-mute)

  (defun pulseaudio-control-increase-volume ()
    "Increase volume of currently-selected Pulse sink.

  Amount of increase is specified by `pulseaudio-control-volume-step'."
    (interactive)
    (pulseaudio-control--maybe-update-current-sink)
    (let* ((volume-step (progn
                          (string-match "\\([[:digit:]]+\\)%" pulseaudio-control-volume-step)
                          (string-to-number (or (match-string 1 pulseaudio-control-volume-step)
                                                0))))
           (volume-max (progn
                         (string-match "\\([[:digit:]]+\\)%" pulseaudio-control--volume-maximum)
                         (string-to-number (or (match-string 1 pulseaudio-control--volume-maximum)
                                               0))))
           (volumes-current (pulseaudio-control--get-current-volume))
           (volumes-re-component "\\([[:digit:]]+\\)\\s-+/\\s-+\\([[:digit:]]+\\)%\\s-+/\\s-+\\(-?[[:digit:]]+\\(\.[[:digit:]]+\\)?\\) dB")
           (volumes-re (concat volumes-re-component
                               "[^[:digit:]]+"
                               volumes-re-component))
           (percentage-left (string-to-number (or (match-string 2 volumes-current) "0")))
           (percentage-right (string-to-number (or (match-string 6 volumes-current) "0"))))
      (if (or (> (+ percentage-left
                    volume-step)
                 volume-max)
              (> (+ percentage-right
                    volume-step)
                 volume-max))
          ;; Clamp volume to value of pulseaudio-control--volume-maximum.
          (pulseaudio-control--call-pactl (concat "set-sink-volume "
                                                  pulseaudio-control--current-sink
                                                  " "
                                                  pulseaudio-control--volume-maximum))
        ;; Increase volume by pulseaudio-control-volume-step.
        (pulseaudio-control--call-pactl (concat "set-sink-volume "
                                                pulseaudio-control--current-sink
                                                " +"
                                                pulseaudio-control-volume-step)))
      (if pulseaudio-control-volume-verbose
          (pulseaudio-control-display-volume))))
#+END_SRC
*** COMMENT Desktop Environment
~desktop-environment~ is a package which provides keybindings for tasks such as changing volume.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :delight
    :config

    (general-def 'desktop-environment-mode-map
      "s-l" #'windmove-right)

    (desktop-environment-mode 1)

    (defun desktop-environment-volume-set (value)
      (error value)
      (error "test")
      (pulseaudio-control-set-volume value))

    (defun desktop-environment-lock-screen ()
      "Lock the screen, preventing anyone without a password from using the system."
      (interactive)
      (start-process-shell-command "slock" nil desktop-environment-screenlock-command))

    (defcustom desktop-environment-brightness-tiny-increment "1%+"
      "Tiny brightness increment value."
      :type 'string)

    (defcustom desktop-environment-brightness-tiny-decrement "1%-"
      "Tiny brightness decrement value."
      :type 'string)

    (defun desktop-environment-brightness-increment-very-slowly ()
      "Increment brightness by `desktop-environment-brightness-tiny-increment'."
      (interactive)
      (desktop-environment-brightness-set desktop-environment-brightness-tiny-increment))

    (defun desktop-environment-brightness-decrement-very-slowly ()
      "Decrement brightness by `desktop-environment-brightness-tiny-decrement'."
      (interactive)
      (desktop-environment-brightness-set desktop-environment-brightness-tiny-decrement))

    (general-def ; :keymaps 'dekstop-environment-mode-map
      "<C-XF86MonBrightnessUp>" #'desktop-environment-brightness-increment-very-slowly
      "<C-XF86MonBrightnessDown>" #'desktop-environment-brightness-decrement-very-slowly)


    ;; run brightness and volume changes in home directory
    (defun desktop-environment-brightness-get ()
      "Return a string representing current brightness level."
      (let ((default-directory "~/")
            (output (shell-command-to-string desktop-environment-brightness-get-command)))
        (save-match-data
          (string-match desktop-environment-brightness-get-regexp output)
          (match-string 1 output))))

    (defun desktop-environment-brightness-set (value)
      "Set brightness to VALUE."
      (let ((default-directory "~/"))
        (shell-command-to-string (format desktop-environment-brightness-set-command value))
        (message "New brightness value: %s" (desktop-environment-brightness-get))))

    
  ;;; Helper functions - volume

    (defun desktop-environment-volume-get ()
      "Return a string representing current volume level."
      (let ((default-directory "~/")
            (output (shell-command-to-string desktop-environment-volume-get-command)))
        (save-match-data
          (string-match desktop-environment-volume-get-regexp output)
          (match-string 1 output))))

    (defun desktop-environment-volume-set (value)
      "Set volume to VALUE."
      (let ((default-directory "~/"))
        (shell-command-to-string (format desktop-environment-volume-set-command value))
        (message "New volume value: %s" (desktop-environment-volume-get))))


    ;; better mute function (single line output)
    (defun desktop-environment-toggle-mute ()
      "Toggle between muted and un-muted."
      (interactive)
      (let ((default-directory "~/"))
        (message "%s"
                 (if (find "off" (split-string (shell-command-to-string desktop-environment-volume-toggle-command)
                                               (rx (or "[" "]")))
                           :test #'string=)
                     "Sound Off"
                   "Sound On")))))
#+END_SRC
*** Next Browser
This allows sending Common Lisp code to a live running Next browser process.
#+BEGIN_SRC emacs-lisp
  ;; ;; -*- lexical-binding: t; -*-

  ;; ;; (setq browse-url-browser-function #'browse-url-generic)
  ;; ;; (setq browse-url-generic-program "firefox")

  ;; ;; (require 'slime)

  ;; (defvar next-browser-connection nil)

  ;; (defun get-next-browser-connection ()
  ;;   (if (and next-browser-connection
  ;;            (find next-browser-connection slime-net-processes))
  ;;       next-browser-connection
  ;;     (aif (ignore-errors
  ;;            (slime-net-connect "localhost"
  ;;                               "4006"))
  ;;          (setq next-browser-connection it))))

  ;; (defun next-browser-eval (sexp)
  ;;   (aif (get-next-browser-connection)
  ;;        (let ((slime-dispatching-connection it))
  ;;          (slime-eval sexp))
  ;;        (error "Next browser has not been started.")))

  ;; (defun next-edit (id)
  ;;   (let ((buffer (generate-new-buffer (generate-new-buffer-name "*Next edit*"))))
  ;;     (switch-to-buffer buffer)
  ;;     (with-current-buffer buffer
  ;;       (add-hook 'kill-buffer-hook
  ;;                 (lambda ()
  ;;                   (ignore-errors
  ;;                     (next-browser-eval
  ;;                      `(next-user::emacs-edit-recieve-string
  ;;                        ,id ,(with-current-buffer buffer
  ;;                               (buffer-string))))))
  ;;                 nil t))))
#+END_SRC
*** Browse url
#+BEGIN_SRC emacs-lisp
  (setq browse-url-generic-program "nyxt")

  (setq browse-url-browser-function
        '((".*youtu\\.*be." . browse-url-mpv)
          (".*invidious\\..*" . browse-url-mpv)
          ("." . browse-url-generic)))

  (defvar browse-url-mpv-arguments nil)

  (defun browse-url-mpv (url &optional _new-window)
    (interactive (browse-url-interactive-arg "URL: "))
    (setq url (browse-url-encode-url url))
    (let* ((process-environment (browse-url-process-environment)))
      (apply 'start-process
             (concat "mpv " url) nil
             "mpv"
             (append browse-url-mpv-arguments (list url)))))
#+END_SRC
*** Qutebrowser
#+BEGIN_SRC emacs-lisp
  ;; (setq browse-url-browser-function #'browse-url-generic)
  ;; (setq browse-url-generic-program "qutebrowser"
  ;;       browse-url-generic-args '("--target" "window"))

  (require 'helm-qutebrowser)

  (defun not-qutebrowser-buffer-p ()
    (not (string= exwm-class-name "qutebrowser")))

  (setq helm-exwm-source (helm-exwm-build-source #'not-qutebrowser-buffer-p))

  (defvar helm-source-start-program
    (helm-build-dummy-source
        "Start Program"
      :action (helm-make-actions
               "Start program"
               (lambda (candidate) (start-process-shell-command candidate nil candidate)))))

  (setq helm-qutebrowser-sources '(;; helm-qutebrowser--buffers-source
                                   helm-exwm-source
                                   ;; helm-qutebrowser-source-not-found
                                   helm-source-start-program))
#+END_SRC
*** COMMENT EXWM firefox
#+BEGIN_SRC emacs-lisp
  (use-package exwm-firefox-core)

  (use-package exwm-firefox-evil)

  (setq browse-url-generic-program "firefox")
#+END_SRC
*** Helpful commands
#+BEGIN_SRC emacs-lisp
  ;; logout function
  (defun logout ()
    (interactive)
    (recentf-save-list)
    (save-some-buffers)
    (start-process-shell-command "logout" nil "lxsession-logout"))
#+END_SRC
**** COMMENT Old launchers
#+BEGIN_SRC emacs-lisp

  (defun bluetooth ()
    (interactive)
    (split-window-vertically)
    (other-window 1)
    (start-process-shell-command "blueman-manager" nil "blueman-manager"))

  (defmacro define-start-process-shell-function (name command)
    `(defun ,name ()
       (interactive)
       (start-process-shell-command ,(symbol-name name)
                                    nil
                                    ,command)))

  (define-multi-macro define-start-process-shell-functions define-start-process-shell-function 2)

  (define-start-process-shell-functions 
    wifi "cool-retro-term -e nmtui"
    spotify "spotify --force-device-scale-factor=2")
#+END_SRC
*** Other config
#+BEGIN_SRC emacs-lisp
  ;; Rename exwm buffers to window title
  (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)

  ;;; Allow non-floating resizing with mouse.
  (setq window-divider-default-bottom-width 0
        window-divider-default-right-width 6)
  (window-divider-mode 1)


#+END_SRC
*** COMMENT autominimize
#+BEGIN_SRC emacs-lisp
  (defvar autominimize-list (list "love"))

  (defun autominimize ()
    (when (find-if (lambda (class) (string= exwm-class-name class))
                   autominimize-list)
      (winner-undo)))

  (remove-hook 'exwm-manage-finish-hook
            #'autominimize)
#+END_SRC
*** COMMENT floating toggle
#+BEGIN_SRC emacs-lisp
  (defconst floating-toggle-list (list "love" "firefox"))

  (defun enforce-floating-toggle-list ()
    (mapcar (lambda (class)
              (when (string= exwm-class-name class)
                (exwm-floating--unset-floating exwm--id)))
            floating-toggle-list))

  (add-hook 'exwm-manage-finish-hook
            #'enforce-floating-toggle-list)
#+END_SRC
*** COMMENT Helm randr
#+BEGIN_SRC emacs-lisp
  (defun helm-randr ()
    (interactive)
    (let ((xrandr-output (shell-command-to-string "xrandr"))
          screens
          resolutions)
      (with-temp-buffer
        (insert xrandr-output)
        (forward-line -1)
        (while (not (<= (line-number-at-pos) 1))
          (if (looking-at-p "   .*")
              (setq resolutions
                    (cons (progn
                            (looking-at ".* [0-9]+x[0-9]+")
                            (string-trim (match-string 0)))
                          resolutions))
            (progn
              (let ((screen (progn
                              (looking-at "^.*? ")
                              (string-trim (match-string 0)))))
                (setf (alist-get screen screens nil nil #'string=)
                      resolutions))
              (setq resolutions nil)))
          (forward-line -1)))
      (let* ((cr-screens (remove-if #'null
                                    (mapcar (lambda (screen)
                                              (when (cdr screen)
                                                (car screen)))
                                            screens)))
             (screen (if (= (length cr-screens) 1)
                         (car cr-screens)
                       (completing-read "Screen: " cr-screens)))
             (resolution (completing-read "Resolution: "
                                          (alist-get screen
                                                     screens
                                                     nil nil #'string=))))
        (insert (prin1-to-string `(,screen ,resolution)))
        (call-process "xrandr" nil nil nil
                      "--screen" screen
                      "--mode" resolutio("eDP1" "1920x1080")n))))
#+END_SRC

*** COMMENT DPI adjustment
#+BEGIN_SRC emacs-lisp
  (require 'zoom-frm)

  (defvar my-zoom-frm-base-dpi (get-dpi)
    "The DPI of the screen when at maxiumum resolution.")

  (defun my-zoom-frm-by-dpi (&optional frame)
    "Zoom FRAME so that the effective font size is equivalent to
  what is would be at DPI `my-zoom-frm-base-dpi' and font size
  `my-default-font-pixelsize'."
    (interactive)
    (let ((frame (or frame (selected-frame))))
      (when (frame-parameter frame 'zoomed)
        (zoom-frm-unzoom frame))
      (let ((frame-zoom-font-difference (round (* my-default-font-pixelsize
                                                  (1- (/ (true-dpi frame)
                                                         my-zoom-frm-base-dpi))))))
        (when (called-interactively-p 'interactive)
          (message "Zooming by %S" frame-zoom-font-difference))
        (zoom-frm-in frame))))

  ;; Apply the scaling I want to each newly created frame:
  (add-hook 'exwm-randr-refresh-hook #'my-zoom-frm-by-dpi)
  ;; (add-hook 'after-make-frame-functions #'my-zoom-frm-by-dpi)
#+END_SRC
*** Mouse follows focus
Snap mouse to the center of a window selected by the keyboard

#+BEGIN_SRC emacs-lisp
  ;; (with-eval-after-load 'exwm-initialized
  ;;   (use-package exwm-mff
  ;;     :after exwm
  ;;     :config
  ;;     ;; (mouse-avoidance-mode 'banish)
  ;;     (exwm-mff-mode +1)))
#+END_SRC
** Document viewer
*** PDF
~pdf-tools~ is a document viewer for emacs
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :config
    ;; (pdf-tools-install)
    )
#+END_SRC
*** EPUB
~nov.el~ provides support for viewing epub files. Best combined with olivetti-mode

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :config
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))

    (setq nov-text-width nil)

    (add-hook 'nov-mode-hook #'visual-line-mode)
    (add-hook 'nov-mode-hook #'olivetti-mode)
    ;; (defun me/nov-mode-init ()
    ;;   (setq cursor-type nil))
    ;; (add-hook 'nov-mode-hook #'me/nov-mode-init)
    (my-visual-line-mode-rebind nov-mode-map)

    (defun toggle-cursor ()
      (interactive)
      (if cursor-type
          (setq cursor-type nil)
        (setq cursor-type t)))

    (defun evil-force-normal-state-and-toggle-cursor ()
      (interactive)
      (evil-force-normal-state)
      (toggle-cursor))

    (general-def 'normal 'nov-mode-map
      "f" #'evil-scroll-page-down
      "C-f" #'evil-find-char
      "L" #'nov-history-forward
      "H" #'nov-history-back
      "<escape>" #'toggle-cursor))
#+END_SRC
** Image viewer
Emacs has an inbuilt image viewer ~image-mode~.
#+BEGIN_SRC emacs-lisp
  (require 'image)
  (require 'image-dimensions-minor-mode)

  (setq ;; imagemagick-render-type 1 ; increase image scaling speed
        ;; exclude .gif files because I prefer to handle them with external programs
        image-file-name-extensions '("webp" "png" "jpeg" "jpg" "tiff" "tif" "xbm" "xpm" "pbm" "pgm" "ppm" "pnm" "svg"))

  (setq image-transform-resize nil)

  (defun image-transform-fit-to-width-or-height (&rest _)
    "Fit the current image to the shortest of width or height of
  the current window. This command has no effect unless Emacs is
  compiled with ImageMagick support."
    (interactive)
    (let ((image-transform-resize
           (let* ((size (image-size (image-get-display-property))))
             (if (> (/ (car size) (cdr size))
                    (/ (* 1.0 (window-width))
                       (* 1.0 (window-height))))
                 'fit-width
               'fit-height))))
      (image-toggle-display-image)))

  (defun me/image-transform-fit-to-height ()
    "Fit the current image to the height of the current window.
  This command has no effect unless Emacs is compiled with
  ImageMagick support."
    (interactive)
    (let ((image-transform-resize 'fit-height))
      (image-toggle-display-image)))

  (defun me/image-transform-fit-to-width ()
    "Fit the current image to the width of the current window.
  This command has no effect unless Emacs is compiled with
  ImageMagick support."
    (interactive)
    (let ((image-transform-resize 'fit-width))
      (image-toggle-display-image)))

  ;; (add-hook 'image-minor-mode-hook #'image-transform-fit-to-width-or-height)

  (general-def normal image-mode-map

    "R" #'image-transform-reset

    "W" #'me/image-transform-fit-to-height
    "w" #'me/image-transform-fit-to-width
    "o" #'image-transform-fit-to-width-or-height

    "p" #'image-previous-file
    "N" #'image-previous-file
    "n" #'image-next-file
    "," nil)

  (general-def normal '(image-mode-map image-dired-display-image-mode-map)
    "-" #'image-decrease-size
    "+" #'image-increase-size
    "=" #'image-increase-size

    "C-j" (lambda nil (interactive)
            (image-next-line 1))
    "C-k" (lambda nil (interactive)
            (image-previous-line 1))
    "j" (lambda nil (interactive)
          (image-next-line 10))
    "k" (lambda nil (interactive)
          (image-previous-line 10))
    "J" (lambda nil (interactive)
          (image-next-line 50))
    "K" (lambda nil (interactive)
          (image-previous-line 50))

    "C-h" (lambda nil (interactive)
            (image-backward-hscroll 1))
    "C-l" (lambda nil (interactive)
            (image-forward-hscroll 1))
    "h" (lambda nil (interactive)
          (image-backward-hscroll 20))
    "l" (lambda nil (interactive)
          (image-forward-hscroll 20))
    "H" (lambda nil (interactive)
          (image-backward-hscroll 100))
    "L" (lambda nil (interactive)
          (image-forward-hscroll 100)))
#+END_SRC
** EMMS
Emacs media manager
#+BEGIN_SRC emacs-lisp
  (use-package emms
    :config

    (require 'emms-setup)
    ;; (require 'emms-player-mpd)
    (require 'emms-player-mpv)

    ;; (emms-default-players)
    (emms-all)
    (require 'emms-volume)
    (require 'emms-streams)
    (require 'emms-stream-info)
    (require 'emms-info-libtag)
    (defun me/emms-playlist-current-nondirectory ()
      (format emms-mode-line-format (file-name-nondirectory
                                     (emms-track-description
                                      (emms-playlist-current-selected-track)))))
    (setq emms-player-seek-seconds 5
          emms-source-file-default-directory (expand-file-name "~/Music/")
          emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
          emms-player-list '(emms-player-mpv)
          ;; emms-player-mpd-music-directory "~/Music"
          emms-info-functions '(emms-info-libtag)
          emms-volume-change-function #'emms-volume-pulse-change
          emms-volume-change-amount 5
          emms-mode-line-format " | %s"
          emms-mode-line-mode-line-function #'me/emms-playlist-current-nondirectory 
          emms-browser-covers #'emms-browser-cache-thumbnail-async
          emms-browser-default-covers '("~/Music/default-cover-small.png"
                                        "~/Music/default-cover-medium.png"
                                        "~/Music/default-cover-large.png")
          ;; emms-stream-info-backend 'mplayer
          )


    ;; (general-def normal emms-playlist-mode-map
    ;;   ;; "<return>" #'emms-playlist-mode-play-current-track
    ;;   "d" nil
    ;;   )

    (general-create-definer emms-key-def
      :prefix "s-m")

    (general-def 
      "<XF86AudioPrev>" 'emms-previous
      "<XF86AudioNext>" 'emms-next
      "<XF86AudioPlay>" 'emms-pause
      "<XF86AudioPause>" 'emms-pause
      "<XF86AudioStop>" 'emms-stop)

    (emms-key-def 'normal 
      "s-m" #'emms-pause
      "m" #'emms
      "b" #'emms-browse-by-album
      ;; "r" 'emms-player-mpd-update-all-reset-cache
      ))

  (defun me/pulseaudio-control--get-current-mute ()
    "Get volume of currently-selected sink."
    (let (beg)
      (pulseaudio-control--maybe-update-current-sink)
      (with-temp-buffer
        (pulseaudio-control--call-pactl "list sinks")
        (goto-char (point-min))
        (search-forward (concat "Sink #" pulseaudio-control--current-sink))
        (search-forward "Mute:")
        (backward-word)
        (setq beg (point))
        (move-end-of-line nil)
        (buffer-substring beg (point)))))

  (defun me/pulsaudio-display-mute ()
    (if pulseaudio-control-volume-verbose
        (message (me/pulseaudio-control--get-current-mute))))

  (advice-add 'pulseaudio-control-toggle-current-sink-mute
              :after
              #'me/pulsaudio-display-mute)

  (add-hook 'emms-playlist-mode-hook #'hl-line-mode)
#+END_SRC
*** Uncle Dave's Commands
Stolen from [[https://github.com/daedreth/UncleDavesEmacs#emms-with-mpd][UncleDavesEmacs]]
#+BEGIN_SRC emacs-lisp
  (defun mpd/start-music-daemon ()
    "Start MPD, connects to it and syncs the metadata cache."
    (interactive)
    (shell-command "mpd")
    (mpd/update-database)
    (emms-player-mpd-connect)
    (emms-cache-set-from-mpd-all)
    (message "MPD Started!"))

  (defun mpd/kill-music-daemon ()
    "Stops playback and kill the music daemon."
    (interactive)
    (emms-stop)
    (call-process "killall" nil nil nil "mpd")
    (message "MPD Killed!"))

  (defun mpd/update-database ()
    "Updates the MPD database synchronously."
    (interactive)
    (call-process "mpc" nil nil nil "update")
    (message "MPD Database Updated!"))

  (emms-key-def 'normal
    "s" 'mpd/start-music-daemon
    "k" 'mpd/kill-music-daemon
    "u" 'mpd/update-database)
#+END_SRC
*** Other commands 
#+BEGIN_SRC emacs-lisp
  ;; from https://www.emacswiki.org/emacs/EMMS#toc36
  (defun my-emms-playlist-total-time-below-point ()
    "Calculates the total time taken for all the tracks currently in playlist and below point"
    (interactive)
    (let ((move-forward t)
          (total-playlist-time 0))
      (save-excursion 		
        (while move-forward
          (setq total-playlist-time (+ total-playlist-time (or (emms-track-get (emms-playlist-track-at (point)) 'info-playing-time) 0)))
          (forward-line 1)
          (setq move-forward (next-single-property-change (point) 'emms-track))))
      (setq total-hour-only (/ total-playlist-time 3600)
            total-minutes-only (/ (% total-playlist-time 3600) 60)
            total-seconds-only (% total-playlist-time 60))
      (message "Total time is %dh:%dm:%ds" total-hour-only total-minutes-only total-seconds-only)))

  (leader-key-def normal emms-playlist-mode-map
    "i" #'my-emms-playlist-total-time-below-point)
#+END_SRC
*** Helm EMMS
#+BEGIN_SRC emacs-lisp
  (use-package helm-emms
    :config
    ;; (setq helm-emms-dired-directories `(,me/music-directory))
    ;; (setq helm-emms-dired-directories nil)
    (defun helm-emms-sans-streams ()
      (interactive)
      (helm :sources '(helm-source-emms-dired
                       helm-source-emms-files)
            :buffer "*Helm Emms*"))

    (emms-key-def 'normal
      "," 'helm-emms-sans-streams))
#+END_SRC
** System package managment
#+BEGIN_SRC emacs-lisp
  (use-package system-packages
    :ensure t ; TODO
    :config
    (setf (cdr
           (assoc
            'search
            (cdr
             (assoc
              'guix system-packages-supported-package-managers))))
          "~/.emacs.d/guix-search-full.sh"))

  (use-package helm-system-packages) ;; can manage packages across tramp
#+END_SRC
** IRC (ERC)
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t; -*-
  (require 'erc)

  (erc-keep-place-enable)

  (defun me/erc-insert-timestamp-right-margin (string)
    (unless (and erc-timestamp-only-if-changed-flag
                 (string-equal string erc-timestamp-last-inserted))
      (setq erc-timestamp-last-inserted string)
      (goto-char (point-max))
      (forward-char -1);; before the last newline
      (let ((len (1- (length string)))
            ;; (from (point))
            )
        ;; (insert string)
        ;; (erc-put-text-property 0 len )
        ;; (erc-put-text-property 0 len )
        ;; (when erc-timestamp-intangible
        ;;   (erc-put-text-property 0 len 'cursor-intangible t string))
        (overlay-put (make-overlay (point) (point))
                     'before-string
                     (propertize "."
                                 'rear-nonsticky t string
                                 'field 'erc-timestamp string
                                 'display `((margin right-margin) ,string))))))

  (defun me/erc-fill-static ()
    "Fills a text such that messages start at column `erc-fill-static-center'."
    (save-match-data
      (goto-char (point-min))
      (looking-at "^\\(\\S-+\\)")
      (let ((nick (match-string 1)))
        (let ((fill-prefix (make-string erc-fill-static-center 32)))
          (insert (make-string (max 0 (- erc-fill-static-center
                                         (length nick) 1))
                               32)))
        (erc-restore-text-properties))))


  (defvar me/erc-right-margin-width 10)
  (defvar me/erc-left-pseudomargin-width 15)

  (defun me/erc-wrap-prefix (&optional width)
    (let ((prefix ""))
      (dotimes (_ (or width me/erc-left-pseudomargin-width))
        (setq prefix (concat " " prefix)))
      prefix))

  (defvar me/erc-prompt "ERC>")

  (defun me/erc-prompt-with-margin ()
    (concat (me/erc-wrap-prefix (max 0 (1- (- me/erc-left-pseudomargin-width
                                              (length me/erc-prompt)))))
            me/erc-prompt))

  (setq erc-track-position-in-mode-line t
        erc-hide-list '("JOIN" "PART" "QUIT")
        ;; erc-rename-buffers t
        erc-join-buffer 'bury
        erc-interpret-mirc-color t
        erc-fill-function 'me/erc-fill-static
        erc-fill-static-center me/erc-left-pseudomargin-width
        erc-input-line-position -1
        erc-timestamp-right-column 90
        erc-insert-timestamp-function #'me/erc-insert-timestamp-right-margin
        erc-insert-away-timestamp-function #'me/erc-insert-timestamp-right-margin
        erc-prompt (me/erc-prompt-with-margin)
        erc-hide-list '("JOIN" "PART" "QUIT")
        erc-lurker-hide-list '("JOIN" "PART" "QUIT")
        erc-lurker-threshold-time 43200
        erc-server-reconnect-timeout 3
        erc-track-exclude-server-buffer t
        erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
                                  "324" "329" "332" "333" "353" "477"))

  (defvar me/erc-text-region-width 86)

  (defun me/erc-margin-adjust (&optional buffer width)
    (let ((buffer (or buffer (window-buffer))))
      ;; (with-current-buffer "*scratch*" (insert buffer))
      (with-current-buffer buffer
        (when (eq major-mode 'erc-mode)
          (setq right-margin-width (or width
                                       (max me/erc-right-margin-width
                                            (- (+ (window-width (get-buffer-window))
                                                  (or (cdr (window-margins (get-buffer-window)))
                                                      0))
                                               (+ me/erc-left-pseudomargin-width
                                                  me/erc-text-region-width
                                                  1)))))
          (set-window-buffer (get-buffer-window) buffer)))))

  (defvar me/erc-margin-adjust-delay "0.5 sec")
  (let ((timer nil))
    (defun me/erc-margin-adjust-delayed ()
      (when (find timer timer-list)
        (cancel-timer timer))
      (setq timer
            (run-with-timer me/erc-margin-adjust-delay nil
                            #'me/erc-margin-adjust
                            (window-buffer)))))

  (defun me/erc-reset-margins (&optional window size side pixelwise)
    (if (window-live-p window)
        (with-selected-window window
          (when (eq (with-current-buffer (window-buffer window)
                      major-mode)
                    'erc-mode)
            (set-window-margins window nil)))))

  (advice-add 'split-window
              :before
              #'me/erc-reset-margins)

  (advice-add 'split-window-sensibly
              :before
              #'me/erc-reset-margins)

  (general-def '(normal visual) erc-mode-map
    ;; Make evil-mode up/down operate in screen lines instead of logical lines
    "j" #'evil-next-visual-line
    "k" #'evil-previous-visual-line
    "0" #'evil-beginning-of-visual-line
    "E" #'evil-end-of-visual-line)

  (defun me/erc-setup ()
    (setq
     fringes-outside-margins t
     right-margin-width me/erc-right-margin-width
     word-wrap t
     wrap-prefix (me/erc-wrap-prefix))
    (add-hook 'window-configuration-change-hook
              #'me/erc-margin-adjust nil t))

  (add-hook 'erc-mode-hook #'me/erc-setup)
  (add-hook 'erc-mode-hook #'erc-pcomplete-enable)
  (add-hook 'erc-mode-hook #'company-mode-disable)

  ;; (add-to-list 'erc-modules 'notifications)
  ;; (add-to-list 'erc-modules 'spelling)
  ;; (erc-services-mode 1)
  ;; (erc-update-modules)

  (defun bitlbee ()
    (interactive)
    (erc :server "localhost"
         :port 6667
         :nick "adrian"
         :password (auth-source-pass-get 'secret "bitlbee")))

  (defun me/erc-count-users ()
    "Displays the number of users connected on the current channel."
    (interactive)
    (if-let* ((channel (erc-default-target))
              (erc-channel-p channel))
        (message "%d users are online on %s"
                 (hash-table-count erc-channel-users)
                 channel)
      (user-error "The current buffer is not a channel")))

  (defun erc-hide-users-on (message)
    (when (string-match-p (rx "Users on " (* anything) ":")
                          message)
      (setq erc-insert-this nil)))

  (add-hook 'erc-insert-pre-hook
            #'erc-hide-users-on)

  (defun erc-cmd-NAMES-advice (fn &rest args)
    (if (find #'erc-hide-users-on
              erc-insert-pre-hook)
        (progn
          (remove-hook 'erc-insert-pre-hook
                       #'erc-hide-users-on t)
          (let ((result (apply fn args)))
            (add-hook 'erc-insert-pre-hook
                      #'erc-hide-users-on t)
            result))
      (apply fn args)))

  ;; (aaa '(erc-cmd-NAMES)
  ;;      #'erc-cmd-NAMES-advice
  ;;      :around)


  (use-package erc-hl-nicks
    :after erc)

  (general-def
    :states 'normal
    :keymaps 'erc-mode-map
    ;; go to prompt before append or insert line in comint mode
    "RET" #'erc-send-current-line
    "I" #'comint-style-insert-line
    "A" #'comint-style-append-line)

  ;; (defun me/erc-shorten-names (channel-names)
  ;;   (erc-unique-channel-names
  ;;    (erc-all-buffer-names)
  ;;    channel-names

  ;;    erc-track-shorten-start))

  (defun me/erc (server)
    (erc :server server
         :port 6667
         :nick "drainful"
         :password (auth-source-pass-get
                    'secret
                    (concat (second (nreverse (split-string server "\\.")))
                            " nickserv"))))

  (defun freenode-erc ()
    (interactive)
    (me/erc "irc.freenode.net"))

  ;; Bouncer
  (use-package znc
    :config
    (setq znc-servers
          ;; `(("localhost" 12533 t
          ;;    ((network-slug "znc-username" "znc-password"))))
          `(("znc.fullmer.info" 5000 t
             ((irc\.freenode\.net ,(concat me/freenode-nick
                                           "/freenode")
                                  auth)
              (irc\.rizon\.net ,(concat me/freenode-nick
                                        "/rizon")
                               auth)
              (irc\.indymedia\.net ,(concat me/freenode-nick
                                            "/indymedia")
                                   auth)
              (irc\.esper\.net ,(concat me/freenode-nick
                                        "/espernet")
                               auth)
              ;; (irc\.tilde\.chat ,(concat me/freenode-nick
              ;;                            "/tilde")
              ;;                   ,(me/znc-password))
              ))))
    (defun me/znc-self-message ()
      (erc-server-send "CAP REQ :znc.in/self-message")
      (erc-server-send "CAP END"))
    (advice-add 'erc-login
                :before
                #'me/znc-self-message))

  (defun znc-erc-connect (endpoint)
    (message "Called with: %s" endpoint)
    (let (authenticated-pass)
      (cl-flet ((authenticate-pass
                 (pass)
                 (progn
                   (if (equal pass 'auth)
                       (or authenticated-pass
                           (setq authenticated-pass
                                 (auth-source-pass-get 'secret "znc")))
                     pass))))
        (with-endpoint endpoint
                       (message "Have endpoint: %s" endpoint)
                       (let* ((buffer (znc-network-buffer-name slug))
                              (erc-fun (if ssl znc-erc-ssl-connector znc-erc-connector))
                              (erc-args `(:server ,host :port ,port
                                                  :nick ,user
                                                  :password
                                                  ,(format "%s:%s"
                                                           user (authenticate-pass pass))))
                              (erc-buffer (apply erc-fun erc-args)))
                         (when (get-buffer buffer)
                           (znc-kill-buffer-always buffer))
                         (znc-set-name buffer erc-buffer)
                         (with-current-buffer erc-buffer
                           (rename-buffer buffer)))))))
#+END_SRC
**** COMMENT ERC Image
#+BEGIN_SRC emacs-lisp
  (use-package erc-image
    :config
    (add-to-list 'erc-modules 'image)
    (erc-update-modules))
#+END_SRC
**** Scroll to bottom
A fix based on Deniz Dogan's scrolltobottom patch from [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2012-06/msg00360.html][here]] prevents
new messages from scrolling the page past the bottom.
#+BEGIN_SRC emacs-lisp
  (erc-scrolltobottom-mode)
  (setq erc-input-line-position -2)

  (defun me/erc-display-after (_ buffer)
    (with-current-buffer buffer
      (let ((windows (get-buffer-window-list (current-buffer) nil 'visible)))
        (dolist (w windows)
          (with-selected-window w
            (when (>= (window-end) erc-input-marker)
              (save-excursion
                (goto-char (point-max))
                (recenter erc-input-line-position))))))))

  (advice-add 'erc-display-line-1
              :after
              #'me/erc-display-after)

  (defun damd-erc-send-post-hook ()
    (when (>= (window-end) erc-input-marker)
      (goto-char (point-max))
      (widen)
      (recenter erc-input-line-position)))
  (add-hook 'erc-send-post-hook #'damd-erc-send-post-hook)

  ;; (defun damd-window-configuration-change-hook ()
  ;;   (when (and (eq major-mode 'erc-mode)
  ;;              (>= (window-end) erc-input-marker))
  ;;     (recenter erc-input-line-position)))
  ;; (add-hook 'window-configuration-change-hook #'damd-window-configuration-change-hook)
#+END_SRC
*** COMMENT Circe
#+BEGIN_SRC emacs-lisp
  (use-package circe
    :config
    (setq circe-format-self-say "<{nick}> {body}")

    (setq
     lui-time-stamp-position 'right-margin
     lui-time-stamp-format "%H:%M"
     lui-fill-type 'variable
     ;; lui-fill-column 70
     lui-track-bar-behavior 'before-switch-to-buffer)

    ;; (enable-lui-track-bar)

    (defun my-lui-setup ()
      (setq
       fringes-outside-margins t
       right-margin-width 5
       word-wrap t
       wrap-prefix "    "))
    (add-hook 'lui-mode-hook 'my-lui-setup))


    ;; (setq circe-network-options
    ;;       `(("Freenode"
    ;;          :tls nil
    ;;          :nick ,me/freenode-nick
    ;;          :nickserv-password me/nickserv-password))))
#+END_SR
** EWW
Emacs web wowser for integrated web browsing

#+BEGIN_SRC emacs-lisp
  (general-def 'normal 'eww-mode-map)
#+END_SRC
** Elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :config
    (defvar twitter-accounts-nsfw (split-string (file-string "~/dotfiles/feeds/twitter-nsfw.txt")))

    (defvar default-nitter-instance "nitter.net")

    (cl-defun nitter-account-homepage (account &optional (instance default-nitter-instance))
      (concat "https://" instance "/" account))

    (cl-defun me/elfeed-add-nitter (account &key (instance default-nitter-instance) tags)
      (let* ((url (concat (nitter-account-homepage account instance) "/rss")))
        (cl-pushnew (append (list url 'nitter) tags) elfeed-feeds
                    :test #'equal)
        (setf (elfeed-meta (elfeed-db-get-feed url) :twitter-account)
              account)
        elfeed-feeds))

    (dolist (account twitter-accounts-nsfw)
      (me/elfeed-add-nitter account :tags (list 'nsfw)))

    (defun me/elfeed-never-read-tagger (entry)
      (when (and (< date (- (float-time) (elfeed-time-duration "2 weeks ago")))
                 (find 'unread (elfeed-entry-tags entry)))
        (elfeed-untag entry 'unread)
        (elfeed-tag entry 'never-read)
        entry))

    (add-hook 'elfeed-new-entry-hook #'me/elfeed-never-read-tagger)

    (defalias 'elfeed-search-toggle-star
      (elfeed-expose #'elfeed-search-toggle-all 'star))
    (general-def 'normal 'elfeed-search-mode-map
      "m" #'elfeed-search-toggle-star)
    ;; (defun elfeed-show-toggle-star
    ;;     (elfeed-s))

    )
#+END_SRC
** COMMENT Gnus
#+BEGIN_SRC emacs-lisp
  (require 'gnus)
  (setq gnus-select-method 
        ;; '(nntp "news.gwene.org")
        ;; '(nnimap "imap.mail.yahoo.com:993")
        '(nnrss "nitter.net")
        )

  (add-hook 'gnus-mode-hook
            #'gnus-topic-mode)
  (add-hook 'gnus-mode-hook
            #'hl-line-mode)

  ;; (setq user-mail-address "adrianfullmer@yahoo.com"
  ;;       user-full-name "Adrian Fullmer")
#+END_SRC
** Weather
Interface to wttr.in
#+BEGIN_SRC emacs-lisp
  (use-package wttrin
    :config
    (setq wttrin-default-cities '("Evanston")))
#+END_SRC
** COMMENT Bluetooth interface
#+BEGIN_SRC emacs-lisp
  (require 'bluetooth "~/Code/elisp/load/emacs-bluetooth/bluetooth.el")
  (use-package bluetooth
    :config
    (leader-key-def normal
                    "1" #'bluetooth-list-devices)
    (general-def normal bluetooth-mode-map
      "s" #'bluetooth-show-device-info
      "d" #'bluetooth-start-discovery
      "D" #'bluetooth-stop-discovery
      "R" #'bluetooth-remove-device
      "t" #'bluetooth-toggle-trusted
      "p" #'bluetooth-pair
      "c" #'bluetooth-connect
      "x" #'bluetooth-disconnect))
#+END_SRC
** COMMENT Bitwarden
Emacs interface to ~bitwarden-cli~ 
#+BEGIN_SRC emacs-lisp
  (use-package bitwarden
    ;; :straight t (:host github :repo "seanfarley/emacs-bitwarden")
    :config
    (setq bitwarden-automatic-unlock (lambda ()
                                       (read-passwd "Password: "))))
#+END_SRC
** Pass

#+BEGIN_SRC emacs-lisp
  (use-package pass
    :config
    (setq password-store-password-length 16)
    (setq epg-pinentry-mode 'loopback))

  (use-package auth-source-pass
    :config
    (auth-source-pass-enable))

  (use-package helm-pass)
  ;; (use-package pinentry
  ;;   :config
  ;;   (pinentry-start))
#+END_SRC
** Bittorrent
Interface to the bittorrent client Transmission

#+BEGIN_SRC emacs-lisp
  (use-package transmission)
#+END_SRC
* COMMENT Post-startup
~envrc-global-mode~ should be enabled late in the startup sequence so
that it is initialized before other modes which might rely upon the
updated environment variables, since ~envrc-global-mode~ prepends
itself to various hooks
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'envrc (envrc-global-mode))
#+END_SRC
* Utilities
Various functions and macros which are evaluated before anything else in the file.
#+NAME: utilities
#+BEGIN_SRC emacs-lisp :tangle no
  ;; -*- lexical-binding: t; -*-

  (defun file-string (filename)
    (with-temp-buffer
      (insert-file-contents filename)
      (buffer-string)))

  (defun true-dpi (&optional display)
    "Get the DPI of DISPLAY.
    DISPLAY is a display name, frame or terminal, as in
    `display-monitor-attributes-list'."
    (* (/ (cl-flet ((pyth (lambda (w h)
                            (sqrt (+ (* w w)
                                     (* h h)))))
                    (mm2in (lambda (mm)
                             (/ mm 25.4))))
            (let* ((atts (frame-monitor-attributes))
                   (pix-w (cl-fourth (assoc 'geometry atts)))
                   (pix-h (cl-fifth (assoc 'geometry atts)))
                   (pix-d (pyth pix-w pix-h))
                   (mm-w (cl-second (assoc 'mm-size atts)))
                   (mm-h (cl-third (assoc 'mm-size atts)))
                   (mm-d (pyth mm-w mm-h)))
              (/ pix-d (mm2in mm-d))))
          282.7349271323943)
       276.0))

  (defun get-dpi ()
    (let ((dpi (getenv "DPI")))
      (if dpi
          (string-to-number dpi)
        139
        ;; (true-dpi)
        )))

  (defun insert-current-date () (interactive)
         (insert (calendar-date-string (calendar-current-date))))

  (defun advice-add-all (symbols function where &optional props)
    (mapcar (lambda (sym)
              (advice-add sym where function props))
            symbols))

  (defalias 'aaa #'advice-add-all)

  (defun advice-remove-all (symbols function &optional where)
    (mapcar (lambda (sym)
              (advice-remove sym function))
            symbols))

  (defalias 'ara #'advice-remove-all)

  (require 'seq)

  (defun iota (n)
    (let (l)
      (dotimes (i n)
        (setq l (cons (1- (- n i)) l)))
      l))

  (defun find-function-or-variable-at-point ()
    (interactive)
    (let ((sym (symbol-at-point)))
      (if (fboundp sym)
          (find-function-at-point)
        (find-variable-at-point))))

  (defvar buffer-number-regex (rx "<" (* (not (any "<"))) ">" string-end)
    "A regex to match that angle-bracketed number at the end of a
    buffer name that represents that it is a duplicate of another
    buffer.")

  (defun get-buffer-number (buffer-name)
    "Gets the number in angle brackets from the name of a buffer"
    (save-match-data
      (when (string-match buffer-number-regex buffer-name)
        (let ((val (match-string 0 buffer-name)))
          (string-to-number (substring val 1 (1- (length val))))))))

  (defun set-buffer-number (buffer-name new-number)
    "Return a new string with a different number in angle brackets at the end."
    (let ((new-number-string (concat "<" (number-to-string new-number) ">")))
      (save-match-data
        (if (string-match buffer-number-regex buffer-name)
            (replace-match new-number-string t t buffer-name)
          (concat buffer-name new-number-string)))))

  (defun auto-mode-add (mode &rest filenames)
    "Add a number of file name patterns to the given mode in
    auto-mode-alist"
    (mapcar (lambda (name)
              (add-to-list 'auto-mode-alist
                           `(,name . ,mode)))
            filenames))

  (defun remove-keyword-args (list)
    "Remove keyword arguments from the given list"
    (car (general--remove-keyword-args list)))

  (defun earmuffs (string)
    "Add *earmuffs* to the given string. This represents the name
      of a buffer which is not associated with a file."
    (concat "*" string "*"))

  (defun reload-init-file ()
    "Load all elisp from 'user-init-file'."
    (interactive)
    (load-file user-init-file))

  (defun dotfiles (path)
    "Return path relative to the dotfiles directory"
    (concat me/dotfiles path))

  (defun actually-kill-this-buffer ()
    "Kills the current buffer, unlike ~kill-this-buffer~ 
  which does not always do that."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun windows-right ()
    (interactive)
    (if (> (length (window-list)) 1)
        (evil-window-move-far-right)
      (progn
        (split-window-right)
        (evil-window-move-far-right)
        (other-window 1)
        (next-buffer)
        (other-window 1))))

  (defun windows-left ()
    (interactive)
    (if (> (length (window-list)) 1)
        (funcall-interactively
         #'evil-window-move-far-left)
      (progn
        (split-window-right)
        (other-window 1)
        (next-buffer)
        (other-window 1))))

  (defun move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (defun move-line-up ()
    "Move the current line up."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move the current line down."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (defun disable-most-recent-theme ()
    (interactive)
    (disable-theme (car custom-enabled-themes)))

  (defun switch-theme (theme)
    "load a theme interactively while disabling the current one."
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapcar 'symbol-name
                                       (custom-available-themes))))))
    (disable-most-recent-theme)
    (load-theme theme t))

  (defun string-represents-integer-p (string)
    "Truthy if string is a representation of an integer (leading
  zeroes allowed), nil otherwise."
    (string-match-p "\\`[0-9][0-9]*\\'" string))

  (defun string-to-integer-or-nil (string)
    "If the string represents an integer, return that integer,
  otherwise return nil."
    (when (string-represents-integer-p string)
      (string-to-number string)))

  (defun circular (list)
    "Return a copy of the given list where the last element points
  to the first, rather than to nil."
    (when list
      (let ((new-list (copy-list list)))
         (setf (cdr (last new-list))
                  new-list))))

  (defun cd*r (n list)
    "n cdrs of list. recursive."
    (if (<= n 0)
        list
      (cd*r (1- n) (cdr list))))

  (defun add-to-env (env val)
    (setenv env (concat (getenv env) val)))

  (cl-defun add-to-path (file-paths-string &optional (env "PATH") (seperator ":"))
    (dolist (path (split-string file-paths-string seperator))
      (unless (find-if (lambda (s)
                         (string= s path))
                       (split-string (getenv env) seperator))
        (add-to-env env (concat seperator (expand-file-name path)))))
    (getenv env))

  (cl-defun remove-from-path (paths &optional (env "PATH") (seperator ":"))
    (let ((new-path (getenv env)))
      (dolist (path (split-string paths seperator))
        (setq new-path (reduce (lambda (a b)
                                 (if a (if b (concat a seperator b) a)
                                   (if b b "")))
                               (mapcar (lambda (s)
                                         (if (string= s (expand-file-name path)) nil s))
                                       (split-string new-path seperator)))))
      (setenv env new-path)))

  (defun lua-path+ (val)
    (add-to-path val
                 "LUA_PATH"
                 ";"))

  (defun lua-cpath+ (val)
    (add-to-path val
                 "LUA_CPATH"
                 ";"))

  ;;;; Macrology

  (defmacro aif (cond then &rest else)
    `(let ((it ,cond))
       (if it
           ,then
         ,@else)))

  (defmacro dobody (spec &rest body)
    "A tool for creating domain specific languages.

  Return a progn which contains the collected results of
  evaluating BODY with VAR bound to each car from LIST, in turn.

  \(fn (VAR LIST) BODY...)"
    (unless (consp spec)
      (signal 'wrong-type-argument (list 'consp spec)))
    (unless (= 2 (length spec))
      (signal 'wrong-number-of-arguments (list '(2 . 2) (length spec))))
    (list 'backquote
          (list 'progn
                (list backquote-splice-symbol
                      `(mapcar (lambda (,(cl-first spec))
                                 (progn ,@body))
                               ,(cl-second spec))))))

  ;; todo: add support for kwargs which act as uniform values for the
  ;; entire multi-macro call.
  (defmacro define-multi-macro (name macro num-parameters &optional documentation)
    `(defmacro ,name (&rest args)
       ,(concat documentation
                (format "For each %d arguments, call `%s' with those arguments."
                        num-parameters macro))
       (dobody (elt (seq-partition args ,num-parameters))
               `(,',macro ,@elt))))

  (defmacro define-multi-macro-clauses (name macro &optional documentation)
    `(defmacro ,name (&rest clauses)
       ,(concat documentation
                (format "\n\nFor clause syntax, look at the documentation of `%s'.

  Example clauses:

  (ARG1 ARG2 :KEYWORD1 VAL1 :KEYWORD2 VAL2)

  (ARG BODY1
       BODY2)

  The clause \"(ARG)\" can be written as \"ARG\".
  " macro))
       (dobody (clause clauses)
               `(,',macro ,@(if (consp clause)
                                clause
                              (list clause))))))

  (defmacro dynamic-flet (binding &rest body)
    "Dynamic (not lexical) flet. Borked if emacs ever gets real
  concurrency."
    (declare (indent 1))
    (let* ((name (car binding))
           (old (cl-gensym (symbol-name name))))
      `(let ((,old (symbol-function ',name)))
         (unwind-protect
             (progn
               (fset ',name (lambda ,@(cdr binding)))
               ,@body)
           (fset ',name ,old)))))
#+END_SRC
