#+TITLE: Emacs Configuration

* Table of contents                                                     :TOC:
- [[#startup][Startup]]
  - [[#lexical-scope][Lexical Scope]]
  - [[#garbage-collector-threshold][Garbage Collector Threshold]]
  - [[#filename-handlers][Filename Handlers]]
  - [[#load-helper-functions][Load helper functions]]
  - [[#load-secrets][Load secrets]]
  - [[#constants][Constants]]
- [[#packages][Packages]]
  - [[#package-initialization][Package Initialization]]
  - [[#use-package][Use-Package]]
  - [[#quelpa][Quelpa]]
- [[#evil][Evil]]
  - [[#evil-collection][Evil collection]]
  - [[#evil-easymotion][Evil easymotion]]
  - [[#evil-surround][Evil surround]]
  - [[#the-creation-of-text-objects][The creation of text objects]]
- [[#keybindings-and-commands][Keybindings and commands]]
  - [[#generalel][General.el]]
  - [[#hydrael][Hydra.el]]
  - [[#commands][Commands]]
  - [[#conditional-key-translations][Conditional key translations]]
  - [[#all-modes][All modes]]
  - [[#normal-mode][Normal Mode]]
  - [[#visual-mode][Visual Mode]]
  - [[#insert-mode][Insert Mode]]
  - [[#leader][Leader]]
  - [[#other-commands][Other Commands]]
- [[#user-interface-preferences][User interface preferences]]
  - [[#startup-screen][Startup screen]]
  - [[#mode-line][Mode line]]
  - [[#helm][Helm]]
  - [[#hideshow][Hideshow]]
  - [[#unnecessary-ui-elements][Unnecessary UI elements]]
  - [[#line-and-column-numbers][Line and Column numbers]]
  - [[#line-wrap][Line wrap]]
  - [[#start-frame-maximized][Start frame maximized]]
  - [[#confirmation][Confirmation]]
  - [[#clipboard][Clipboard]]
  - [[#delimiters][Delimiters]]
  - [[#which-key][Which-key]]
  - [[#ediff][Ediff]]
- [[#dired][Dired]]
- [[#shell][Shell]]
  - [[#eshell][Eshell]]
  - [[#comint-mode][Comint Mode]]
  - [[#shell-1][Shell]]
  - [[#term-mode][Term mode]]
  - [[#multi-term][Multi-Term]]
- [[#tramp][Tramp]]
- [[#emacs-clientserver-settings][Emacs client/server settings]]
  - [[#daemon-management][Daemon Management]]
- [[#colors-themes-fonts-and-other-aesthetic-settings][Colors, Themes, Fonts, and other aesthetic settings]]
  - [[#doom-themes][Doom Themes]]
  - [[#poet-theme][Poet Theme]]
  - [[#theme][Theme]]
- [[#text-tab-and-indent-related][Text, tab and indent related]]
- [[#moving-around-buffers-windows-and-splits][Moving around, buffers, windows and splits]]
  - [[#winner-mode][Winner Mode]]
  - [[#projects][Projects]]
  - [[#fzf][FZF]]
  - [[#file-navigation][File navigation]]
- [[#programming-tools-and-settings][Programming tools and settings]]
  - [[#autocompletion][Autocompletion]]
  - [[#linting][Linting]]
  - [[#git][Git]]
  - [[#language-client-features][Language client features]]
  - [[#compilation][Compilation]]
  - [[#documentation][Documentation]]
  - [[#direnv-and-lorri][Direnv and Lorri]]
- [[#language-specific-tools-and-settings][Language specific tools and settings]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs lisp]]
  - [[#common-lisp][Common Lisp]]
  - [[#clojure][Clojure]]
  - [[#scheme][Scheme]]
  - [[#python][Python]]
  - [[#shen][Shen]]
  - [[#prolog][Prolog]]
  - [[#cccppcppsepples][C/C++/CPP/Cpp/Sepples]]
  - [[#julia][Julia]]
  - [[#haskell][Haskell]]
  - [[#elm][Elm]]
  - [[#org][Org]]
  - [[#nix][Nix]]
  - [[#bash][Bash]]
- [[#excessive-nonsense][Excessive Nonsense]]
  - [[#emacs-window-manager][Emacs window manager]]
- [[#files-and-backups][Files and backups]]
- [[#helper-functions][Helper functions]]

* Startup
** Lexical Scope
I enable lexical scope. This not only improves execution time, but
also allows lexical techniques such as closures to be used.

#+PROPERTY: header-args:emacs-lisp :lexical t

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC

** Garbage Collector Threshold
In search of faster startup times, I took some advice from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom
Emacs]].
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook
    (setq gc-cons-threshold 16777216
          gc-cons-percentage 0.1))

  (defun lex-p ()
    "Return t if lexical binding is in effect."
    (let (lex
      _lex-p)
      (let ((lex t))
        (setq _lex-p
          (lambda ()
            lex)))
      (funcall _lex-p)))
#+END_SRC

** Filename Handlers
Similarly to the garbage collector, startup time can be improved by
disabling the ~file-name-handler-alist~, as it will not be needed during
startup. This trick also comes from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]].
#+BEGIN_SRC emacs-lisp
(defvar temp-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

(add-hook 'emacs-startup-hook
  (setq file-name-handler-alist temp-file-name-handler-alist))
#+END_SRC

** Load helper functions
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<helper-functions>>
#+END_SRC
** Load secrets
Secrets are stored in ~~/.emacs.d/.secrets.el~.
#+BEGIN_SRC emacs-lisp
  (let ((secret.el (expand-file-name ".secrets.el" user-emacs-directory)))
    (when (file-exists-p secret.el)
      (load secret.el)))
#+END_SRC
** Constants
I create a few constants for later use
#+BEGIN_SRC emacs-lisp
  ;; Directory containing my dotfiles.
  (defconst me/dotfiles "~/.dotfiles/")
  ;; directory containing my nixos configutation
  (defconst me/nixos-directory "/sudo::/etc/nixos/") 
#+END_SRC
* Packages
** Package Initialization
Before I can install packages I must first initialize package sources
and installation tools. Here I source ~elpa~ and ~melpa~.
#+BEGIN_SRC emacs-lisp

(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl (warn "\
Your version of Emacs does not support SSL connections,
which is unsafe because it allows man-in-the-middle attacks.
There are two things you can do about this warning:
1. Install an Emacs version that does support SSL and be safe.
2. Remove this warning from your init file so you won't see it again."))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+END_SRC

** Use-Package
I use the ever-popular package-using facility ~use-package~. It is
installed automatically by a nix expression in my dotfiles. This line
causes ~use-package~ expressions to be automatically downloaded.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

** Quelpa
~quelpa~ is a package installation facility that allows packages to be
installed from arbitrary sources. This is convenient for getting
bleeding edge versions of packages which have yet to reach ~melpa~.
#+BEGIN_SRC emacs-lisp
(use-package quelpa)

(setq quelpa-upgrade-p nil)

(use-package quelpa-use-package)

(quelpa-use-package-activate-advice)
#+END_SRC

** COMMENT Automatic Upgrades
This code enables automatic package upgrades.
#+BEGIN_SRC emacs-lisp
(setq quelpa-upgrade-p t)

(package-refresh-contents)

(use-package auto-package-update
  :config
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+END_SRC
* Evil
These are settings for the emulation of Vim in Emacs. I would not be
using emacs today if it were not for ~evil-mode~.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  ;; highlight all search results
  (setq evil-search-module 'evil-search)
  ;; settings for evil-collection integration
  (setq evil-want-keybinding nil)
  (setq evil-want-integration t)
  :config
  (evil-mode 1)
  ;; The undo tree sometimes deletes undo data, I prefer to just disable it.
  (global-undo-tree-mode -1))
#+END_SRC
** COMMENT Early loading of general for evil commands
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<use-package-general>>
<<leader-definitions>>
<<leader-helpers>>
<<leader-subleaders>>
#+END_SRC
** Evil collection
This provides ~evil~ friendly keybindings for a variety of modes.
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :init
    (setq evil-want-keybinding nil)
    :after evil
    :config
    ;; (setq evil-collection-term-sync-state-and-mode-p nil)
    (evil-collection-minibuffer-setup)
    (evil-collection-init))
#+END_SRC
** Evil easymotion
This package helps with the issue of not knowing how many times to
repeat an ~evil~ motion by providing a tag at the location of
each possible motion result.
#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :config
  (evilem-default-keybindings "SPC"))
#+END_SRC
** Evil surround
This solves the tricky issue of surrounding a block of text with
delimiters when they automatically close.
#+BEGIN_SRC emacs-lisp
(use-package "evil-surround"
  :config
  (global-evil-surround-mode 1))
#+END_SRC
** COMMENT Evil snipe
At one point I used ~evil-snipe~, a tool for jumping to pairs of characters.
#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :after evil-easymotion
  :config
  (evilem-define (kbd "SPC s") 'evil-snipe-s))
#+END_SRC
** The creation of text objects
This macro was copied from [[https://stackoverflow.com/a/22418983/4921402][this]] Stackoverflow thread, and facilitates
the creation of simple ~evil~ text objects.
#+BEGIN_SRC emacs-lisp
  (defmacro define-and-bind-regex-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))

  (create-multi-macro--old simple-text-objects
                      define-and-bind-regex-text-object
                      4)
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
  (simple-text-objects
   "pipe" "|" "|" "|"
   "slash" "/" "/" "/"
   "sexpr" "i" "(" ")")

#+END_SRC

More complex text objects are defined manually:
#+BEGIN_SRC emacs-lisp
  (evil-define-text-object evil-a-defun (count &optional beg end type)
    "Text object for a top level form (language agnostic)"
    (save-excursion
      (mark-defun)
      (list (point) (mark))))
  (define-key evil-outer-text-objects-map "f" #'evil-a-defun)

  (evil-define-text-object evil-entire-buffer (count &optional beg end type)
    "Text object for the entire buffer"
    (list 1 (1+ (buffer-size))))
  (define-key evil-outer-text-objects-map "a" #'evil-entire-buffer)
#+END_SRC
* Keybindings and commands
** General.el
I mainly use the the package ~general~ to define keybindings and
commands. 
#+NAME: use-package-general
#+BEGIN_SRC emacs-lisp
(use-package general)
#+END_SRC
It integrates well with ~evil~.
#+BEGIN_SRC emacs-lisp
(general-evil-setup)
#+END_SRC
** Hydra.el
~hydra~ is useful to reduce repetitive keybindings.
#+BEGIN_SRC emacs-lisp
(use-package hydra)
#+END_SRC
** Commands
I don't have too much use for ~evil~ commands, but early on I created a
couple.
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "Src" 'reload-init-file)
(evil-ex-define-cmd "Restart" 'restart-emacs)
#+END_SRC
** Conditional key translations
The equivalent of Vim noremaps are Emacs key translations. They apply
globally, so here are some macros to create key translations which apply
conditionally. They are inspired by [[https://www.emacswiki.org/emacs/Evil#toc14][this]].
#+BEGIN_SRC emacs-lisp
  ;; does not require lexical scope
  (defmacro make-conditional-key-translation (key-from key-to translate-keys-p)
    "Make a Key Translation such that if the translate-keys-p function returns true,
     key-from translates to key-to, else key-from translates to itself. "
    `(define-key key-translation-map (kbd ,key-from)
      (lambda (prompt)
        (if (,translate-keys-p) (kbd ,key-to) (kbd ,key-from)))))

  (create-multi-macro--old make-conditional-key-translations
                      make-conditional-key-translation
                      3)

  (defmacro inoremap-single (from to)
    `(make-conditional-key-translation ,from ,to evil-insert-state-p))
  (create-multi-macro--old inoremap inoremap-single 2)

  (defmacro noremap-single (from to)
    `(make-conditional-key-translation ,from ,to (lambda nil t)))
  (create-multi-macro--old noremap noremap-single 2)
#+END_SRC
** All modes
#+BEGIN_SRC emacs-lisp
  ;; (noremap "9" "("
  ;;            "0" ")"
  ;;            "(" "9"
  ;;            ")" "0")
#+END_SRC
** Normal Mode
qThese are normal mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-nmap
  "C-h" 'evil-window-left
  "C-j" 'evil-window-down
  "C-k" 'evil-window-up
  "C-l" 'evil-window-right
  "s-h" 'evil-window-left
  "s-j" 'evil-window-down
  "s-k" 'evil-window-up
  "s-l" 'evil-window-right
  "s-H" 'evil-window-move-far-left
  "s-J" 'evil-window-move-very-bottom
  "s-K" 'evil-window-move-very-top
  "s-L" 'evil-window-move-far-right
  "C--" 'helm-projectile-grep
  ;; Move a line of text using ALT+[jk]
  "M-j" (kbd ":move + RET")
  "M-k" (kbd ":move .-2 RET")
  "M-j" 'move-line-down
  "M-k" 'move-line-up)
#+END_SRC
** Visual Mode
And these are visual mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-vmap
  ;; Move a visual block of text using ALT+[jk]
  "M-k" (kbd ":move '< -2 RET `> my `< mz gv`yo`z"))
#+END_SRC
** Insert Mode
#+BEGIN_SRC emacs-lisp
  ;; (inoremap "." "-"
  ;;           "-" ".")
#+END_SRC
** Leader
The leader key is an old technique common among Vim users. A number of
sequential key commands are hidden behind a single key. For those who
are familiar with ~hydra~, this is a similar concept.
*** Definitions
First I define the leader keys,
#+NAME: leader-definitions
#+BEGIN_SRC emacs-lisp
  (cl-eval-when (compile load eval)
   (defconst leader-key ",")
   (defconst alt-leader "SPC"))

  (general-create-definer leader-key-def
    :prefix leader-key)

  (general-create-definer alt-leader-key-def
    :prefix alt-leader-key)
#+END_SRC

then some helper functions to create functions to create subleader
keybindings through ~general-create-definer~. Key-based replacements are
also generated for [[#which-key][ ~which-key~ ]].
#+NAME: leader-helpers
#+BEGIN_SRC emacs-lisp
  (cl-defun leader-prefix (str &optional (prefix leader-key))
    "Append a leader key to the given string"
    (concat prefix " " str))

  (cl-defmacro define--subleader (key name general-definer-name &key (leader leader-key))
    "Both create a general definer, and a which-key replacement for the given subleader."
    `(progn
       (which-key-add-key-based-replacements
         (leader-prefix ,key ,leader) ,name)
       (general-create-definer ,general-definer-name
         :prefix (leader-prefix ,key ,leader))))

  ;; the format for the input of this function is inspired by general's
  ;; easy to use functions.
  (cl-defmacro define-subleader (&rest args &key (leader leader-key) &allow-other-keys)
    "Both create a general definer, and a which-key replacement for
  the given subleader. Accepts arguments in threes with no
  delimiter."
    `(progn ,@(mapcar (lambda (elt)
                        `(define--subleader ,@elt :leader ,leader))
                      (seq-partition (remove-keyword-args args) 3))))
#+END_SRC
Usage:
#+NAME: subleaders
#+BEGIN_SRC emacs-lisp
  (define-subleader
    "e" "eval" eval-key-def
    "s" "start" start-key-def
    "x" "xpand" xpand-key-def
    "p" "project" project-key-def)
#+END_SRC
*** Normal Mode
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal
    "q" 'actually-kill-this-buffer              ; ",q" to kill buffer not window.
    "w" 'evil-delete-buffer              ; ",w" to kill buffer and window. equivalent of :bd<cr>.
    "b" 'helm-mini                     ; ",b" to switch buffers.
    "f" 'helm-find-files               ; ",f" to find file (replace :e)
    "d" 'fzf-directory-from-home
    "h" 'help
    "o" 'occur 
    "i" 'imenu
    "RET" (kbd ":noh"))
#+END_SRC
*** Visual Mode
#+BEGIN_SRC emacs-lisp
(leader-key-def 'visual
  "c" 'comment-or-uncomment-region)
#+END_SRC
** Other Commands
A command to configure my operating system
#+BEGIN_SRC emacs-lisp
  (defun nixconf () (interactive) (find-file (concat me/nixos-directory "configuration.nix")))
#+END_SRC

A command to configure emacs
#+BEGIN_SRC emacs-lisp
  (defun econf () (interactive) (find-file (dotfiles "emacs/emacs.org")))
#+END_SRC
* User interface preferences
These are settings related to the basic user interface of Emacs.
** Startup screen
I disable the default startup screen and splash message.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil)
#+END_SRC
*** Scratch buffer
Set the initial mode in the scratch buffer to emacs.
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'emacs-lisp-mode)(setq initial-major-mode 'emacs-lisp-mode)
#+END_SRC
** Mode line
The mode line is the line at the bottom of each buffer. It contains
useful information.
*** Delight
Delight is a package which is used to hide unnecessary mode-line
blurbs.
#+BEGIN_SRC emacs-lisp
  (use-package delight :quelpa (:stable t)
    :config
    (delight '((eldoc-mode nil "eldoc")
               (auto-revert-mode nil "autorevert")
               (org-src-mode nil "org-src")
               (org-indent-mode nil "org"))))
#+END_SRC
*** Display information
Display time and battery in the mode line
#+BEGIN_SRC emacs-lisp
  (display-battery-mode)
  (display-time-mode)
#+END_SRC
** Helm
~helm~ is a framework for incremental narrowing searching interfaces
which integrates well across Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :delight
    :bind (("M-x" . helm-M-x))
    :config
    (helm-mode t)

    ;; Do not create a new frame with helm completion.
    (setq helm-show-completion-display-function
          #'helm-show-completion-default-display-function))
#+END_SRC
*** COMMENT Helper functions
#+BEGIN_SRC emacs-lisp
  (defun helm-rec-find-directory-old (&optional starting-directory)
    (interactive)
    (let ((default-directory (or starting-directory default-directory)))
      (find-file
       (helm :sources (helm-build-sync-source "directories"
                        :candidates (lambda ()
                                      (split-string
                                        (shell-command-to-string "find . -type d -not -path '*/\.*'") "\n" t))
                        :fuzzy-match t)
             :prompt "Open directory: "
             :buffer "*helm find directory*"))))

  (defun rec-find-directory (&optional starting-directory)
    (interactive)
    (let ((default-directory (or starting-directory default-directory)))
      (find-file
       (completing-read "Open directory: "
                        (split-string (shell-command-to-string "find . -type d") "\n" t)))))

  (defun helm-rec-find-directory ()
    (interactive)
    (helm-find (list "-type d -not -path '*/\.*'")))
#+END_SRC
** Hideshow
~hideshow~ mode provides vim-like folds (but not as good).
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'hs-minor-mode)
(delight 'hs-minor-mode nil "hideshow")
#+END_SRC
** Unnecessary UI elements
Emacs comes with such useless features as a tool bar. Turn them off.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
(add-to-list 'default-frame-alist
             '(vertical-scroll-bars . nil))
#+END_SRC
** Line and Column numbers
Display them both on the side of the buffer and in the mode line.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
(display-line-numbers-mode 1)

(setq column-number-mode t)
#+END_SRC
** Line wrap
Do not truncate lines.
#+BEGIN_SRC emacs-lisp
  (setq truncate-lines nil)
#+END_SRC
** Start frame maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Confirmation
Type =y= or =n=, not =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Clipboard
Enable vim-like clipboard.
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard nil)
#+END_SRC

** Delimiters
*** Electric pair mode
Close delimiters automatically as I write.
#+BEGIN_SRC emacs-lisp
(electric-pair-mode nil)
#+END_SRC
*** Matching parens
Highlight the parentheis whose pair is under the point.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-delay 0)
  (setq show-paren-style 'parenthesis)
#+END_SRC
*** Highlight parentheses
Highlight the nearest outer parentheses. Thanks to [[https://stackoverflow.com/questions/34846531/show-parentheses-when-inside-them-emacs][this]] thread.
#+BEGIN_SRC emacs-lisp
  (define-advice show-paren-function (:around (fn) fix)
    "Highlight enclosing parens."
    (cond ((looking-at-p "\\s(") (funcall fn))
          (t (save-excursion
               (ignore-errors (backward-up-list))
               (funcall fn)))))
#+END_SRC

** Which-key
This plugin shows the available keys after a partially completed
key press. ~which-key~ key replacements are generated [[#leader][here]].
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight
    :config
    (which-key-mode t))
#+END_SRC
** Ediff
Don't make a new frame for ediff.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
* Dired
Some dired configuration
#+BEGIN_SRC emacs-lisp
  ;; Use atool for compression and extraction
  (use-package dired-atool
    :config
    (leader-key-def normal dired-mode-map
      "z" #'dired-atool-do-unpack
      "Z" #'dired-atool-do-pack))
#+END_SRC
* Shell
** Eshell
~eshell~ is a shell that operates entirely within emacs. It is my
primary shell.
#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-smart)
#+END_SRC
*** Configuration
#+BEGIN_SRC emacs-lisp
  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)
  ;;(add-to-list 'eshell-visual-commands "rlwrap")

  ;; Eshell modules
  (require 'esh-module)
  (add-to-list 'eshell-modules-list 'eshell-tramp)

  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 3600) ; for one hour (time in secs)
#+END_SRC
*** Commands
~eshell~ commands
#+BEGIN_SRC emacs-lisp
  (defun eshell/e (args)
    "Open the given files"
    (if (listp args)
        (dolist (file args) (find-file file t))
      (find-file args)))

  (defun eshell/ee (args)
    "Open the given files in new windows"
    (if (listp args)
        (dolist (file args) (find-file file t))
      (find-file-other-window args)))

  (defun eshell/fd (&optional from-directory)
    "Run fzf to open a directory in dired"
    (fzf-directory-from (if from-directory
                            from-directory
                          default-directory)))

  (defun eshell/fh ()
    (eshell/fd "~"))

  (defun eshell/econf () (econf))
  (defun eshell/nixconf () (nixconf))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key [f1] 'eshell)
  (global-set-key [f2] 'eshell-new)
  ;; Let me use C-j/k
  (add-hook 'eshell-mode-hook ; needs to be in a hook because eshell is dumb
            (lambda ()
              (general-define-key :states 'normal :keymaps 'eshell-mode-map
                                  "C-j" 'evil-window-down
                                  "C-k" 'evil-window-up)))
#+END_SRC
*** Helm support
~helm~ can be used for ~eshell~ completions with the following code.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (eshell-cmpl-initialize)
              (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)))
#+END_SRC
*** Disable Company
While company mode is widely useful, helm does better for eshell.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda () (company-mode -1)))
#+END_SRC
*** Start Function
Function for making a new Eshell instance. From [[https://www.emacswiki.org/emacs/EshellMultipleEshellBuffers][this]] thread.
#+BEGIN_SRC emacs-lisp
(defun eshell-new()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC
*** Properly Protect Prompt
~eshell~ doesn't play with ~evil~ with commands such as ~dd~ which target
tej whole line. This code (inspired by spacemacs shell layer) solves
that problem.
#+BEGIN_SRC emacs-lisp
  (defun protect-eshell-prompt ()
    (let ((inhibit-field-text-motion t)
          (inhibit-read-only t))
      (add-text-properties
       (point-at-bol)
       (point)
       '(rear-nonsticky t
                        inhibit-line-move-fiold-capture t
                        field output
                        read-only t
                        front-sticky (field inhibit-line-move-field-capture)))))

  (add-hook 'eshell-after-prompt-hook 'protect-eshell-prompt)
#+END_SRC
*** COMMENT Attempted prompt fixes
This code is the sum of failed attempts to get the above feature working.
#+BEGIN_SRC emacs-lisp
  (defun eshell/clear ()
    (interactive)
    (let ((inhibit-read-only t))
      (erase-buffer))
    (eshell-send-input))

  (defun restrict-bol (string)
    (propertize string
                'inhibit-line-move-field-capture t
                'rear-nonsticky t
                'field 'output
                'read-only t
                'front-sticky '(field inhibit-line-move-field-capture)))
  (defun protected-eshell-prompt (old-eshell-prompt &rest args)
    (restrict-bol (apply old-eshell-prompt args)))
  (advice-add 'eshell-prompt-functio)



  (setq eshell-prompt-regexp (regexp-quote "^\b$")
        eshell-prompt-function
        (lambda nil ""))

  (setq old-eshell-prompt-function (lambda nil (eshell-prompt-function)))
  (setq old-eshell-prompt-function (symbol-value 'eshell-prompt-function))
  (setq eshell-prompt-function
        (lambda nil
          (restrict-bol (old-eshell-prompt-function))))
  (setq eshell-prompt-function
        (lambda nil
          (restrict-bol (concat
                     (eshell/pwd)
                     " $ "))))
#+END_SRC

** Comint Mode
~comint mode~ is a generalized mode for repl-like interfaces.
#+BEGIN_SRC emacs-lisp
(setq comint-prompt-read-only t ; Don't let me delete the comint prompt duh
      comint-move-point-for-output nil ; reduce frequent redisplays
      comint-scroll-show-maximum-output nil)
#+END_SRC

** Shell
I prefer ~shell-mode~ to ~ansi-term~ because ~comint-mode~, the mode which
~shell-mode~ is based on, plays well with ~evil~.
#+BEGIN_SRC emacs-lisp
  (general-define-key :states 'normal :keymaps 'shell-mode-map
     "C-j" 'evil-window-down
     "C-k" 'evil-window-up)
#+END_SRC
I prefer ~shell-mode~ to open its buffers in the same window (like eshell does)
#+BEGIN_SRC emacs-lisp
  (push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)
#+END_SRC
** Term mode
Because terminal text cannot be edited with emacs ~evil mode~, bind ~C-g~ to escape.
#+BEGIN_SRC emacs-lisp
  (general-define-key :states 'insert
                      :keymaps 'term-raw-map
                      "C-g" 'term-send-esc)
#+END_SRC
*** COMMENT Protect Prompt
This code was the restult of a bad misunderstanding of the function of ~ansi-term~.
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook (lambda () (setq-local term-prompt-regexp "\\[.*\\]\\$ [\n]*")))

  (defun protect-term-prompt ()
    (interactive)
    (when (string-match (condition-case nil 
                            (symbol-value 'term-prompt-regexp) 
                          (void-variable "")) 
                        (thing-at-point 'line t))
      (let ((inhibit-field-text-motion t)
            (inhibit-read-only t))
        (add-text-properties
         (point-at-bol)
         (point-at-eol)
         '(rear-nonsticky t
                          inhibit-line-move-fiold-capture t
                          field output
                          read-only t
                          front-sticky (field inhibit-line-move-field-capture))))))

  (advice-add 'term-send-input #'protect-term-prompt)
#+END_SRC

** Multi-Term
If for some reason I need ~ansi-term~ instead of ~shell-mode~, and for some
reason I need multiple, I have this plugin.
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :config
  ;; (global-set-key [f1] 'multi-term)
  ;; access shift arrow keys
  (define-key global-map "\eO2D" (kbd "S-<left>"))
  (define-key global-map "\eO2C" (kbd "S-<right>"))
  ;; term movement
  (general-define-key
   :states 'normal
   :keymaps 'term-mode-map
   "S-<right>" 'multi-term-next
   "S-<left>" 'multi-term-prev
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC

* Tramp
~tramp~ is a truly one of the great gems of Emacs. It allows me to
access remote files as if they were part of my filesystem within
Emacs.
#+BEGIN_SRC emacs-lisp
  (defun connect-to-serenity ()
    (eshell-at me/serenity-path))
#+END_SRC
* Emacs client/server settings
One of the personal breakthroughs I made when starting with Emacs was
realizing that I didn't have to wait for emacs to start every time I
wanted to edit a file. By running Emacs as a daemon, frames could be
opened instantaneously. Of course at this point I almost never close
my Emacs frame in the first place.
#+BEGIN_SRC emacs-lisp
;; easily restart emacs daemon
(use-package restart-emacs)

;; focus any new frames
(add-to-list 'after-make-frame-functions 'select-frame-set-input-focus)
#+END_SRC
** Daemon Management
I wrote this code to help manage daemons. It is usually fine to
operate within a single daemon, but when I need to have more than one
it's nice to be able to manage them as inferior processes.
#+BEGIN_SRC emacs-lisp
  (cl-defun make-daemon-frame (socket-name &rest args)
    "Make a new emacs frame for the daemon with the given socket name."
    (interactive "M" "Socket name: ")
    (apply 'start-process
           (concat socket-name "-frame")
           nil
           "emacsclient" "--create-frame" (concat "--socket-name=" socket-name)
           args))

  (cl-defun make-daemon (socket-name &key (create-buffer t) before after (theme 'doom-nord-light))
    "Make a new emacs daemon with the given socket name."
    (interactive "M" "Socket name: ")
    (message "Loading inferior emacs")
    (let ((daemon-name (concat socket-name "-daemon")))
      (start-process-shell-command
       daemon-name (when create-buffer daemon-name)
       (concat before
               "emacs --daemon=" socket-name
               ;; "--execute \"(load-theme '"
               ;; (symbol-name theme)
               ;; " t)\""
               ";"
               after))))
#+END_SRC

I wrote some other ugly but useful functions to spawn daemons within a
given Nix environment.
#+BEGIN_SRC emacs-lisp
  (cl-defun nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; nix-shell starts daemosn in /run/user/
    (interactive)
    (let ((running? (file-exists-p (concat "/run/user/1000/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun non-nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was NOT started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; daemons started outside of nix-shell exist in /tmp/
    (interactive)
    (let ((running? (file-exists-p (concat "/tmp/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun nix-daemon (&optional (theme 'doom-nord-light))
    "Start a daemon and frame in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let* ((default-directory (file-name-directory (nix-current-sandbox)))
               (socket-name (file-name-directory default-directory))
               (daemon-name (concat socket-name "-daemon")))
          (if (nix-daemon-running-p socket-name) 
              (nix-daemon-frame)
            (message "Loading inferior nix emacs")
            (start-process-shell-command
             daemon-name daemon-name
             (concat "nix-shell --command \""
                       "emacs --daemon=" socket-name
                       " --execute \\\"
                         (load-theme '"
                         (symbol-name theme)
                         " t)\\\""
                       "; "
                       "emacsclient --create-frame "
                       (concat "--socket-name=" socket-name)
                     "; "
                     "return"
                     "\""))))
      (error "No nix environment was found")))

  (defun nix-daemon-frame ()
    "Start a frame from the relevant nix Emacs daemon in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let ((default-directory (file-name-directory (nix-current-sandbox)))
              (socket-name (elt (nreverse (split-string default-directory "/")) 1)))
          (unless (nix-daemon-running-p socket-name)
            (error "The daemon is not active"))
          (start-process-shell-command
           (concat socket-name "-frame") nil
           (concat "nix-shell --command "
                   (concat "\"emacsclient --create-frame --socket-name=" socket-name "\""))))
      (error "No nix environment was found")))
#+END_SRC

* Colors, Themes, Fonts, and other aesthetic settings
** Doom Themes
Doom Emacs looks good. I want those themes.
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  ;; flash mode line when emacs bell rings
  (doom-themes-visual-bell-config))
#+END_SRC
** Poet Theme
I also use the ~poet~ theme, but I install it through the built-in
package manager rather than through ~use-package~ due to a bug.
** Theme
#+BEGIN_SRC emacs-lisp
  (defun disable-all-themes ()
    (interactive)
    (mapcar #'disable-theme custom-enabled-themes))

  (switch-theme 'tango-dark)
  ;; (if (display-graphic-p)
  ;;     (load-theme 'badwolf t)
  ;;   (disable-all-themes))

#+END_SRC
*** COMMENT time-based theme
The theme loaded depends upon time of day. Causes slight face issues.
#+NAME: themes
#+BEGIN_SRC emacs-lisp
  (use-package theme-changer
    :after doom-themes
    :config
    (setq calendar-location-name me/calendar-location-name)
    (setq calendar-latitude me/calendar-latitude)
    (setq calendar-longitude me/calendar-longitude)
    (change-theme 'doom-one-light 'doom-one))
#+END_SRC
* Text, tab and indent related
I use 4 spaces by default.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              indent-tabs-mode nil)
#+END_SRC
* Moving around, buffers, windows and splits
** Winner Mode
~winner-mode~ lets me switch between window configurations with emacs-like undo capabilities.
I abbreviate the command with ~hydra~.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)

  (defhydra hydra-winner (global-map "C-c")
    "Window configuration history"
    ("u" winner-undo)
    ("r" winner-redo))
#+END_SRC
** Projects
*** Projectile
~projectile~ is a powerful package which facilitates navigation within a
project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :delight " P"
    :after general
    :config
    (general-define-key
     :states 'normal
     :keymaps 'override
   "C-p" 'helm-projectile-find-file)
    (project-key-def 'normal 'projectile-mode-map
      "p" 'projectile-switch-project)
    (projectile-mode +1))

  ;; use helm for projectile
  (use-package helm-projectile
    :config
    (helm-projectile-on))
#+END_SRC
*** Skeletor
~skeletor~ is a project skeleton package which helps me get off the ground faster.
#+BEGIN_SRC emacs-lisp
  (use-package skeletor
    :config
    (setq skeletor-project-directory "~/code/") ; by default, put the
                                          ; project in the ~/code
                                          ; directory.
    (setq skeletor-user-directory (dotfiles "emacs/skeletor/"))

    (defun skeletor-create-project-here ()
      "Create a skeletor project in the current directory."
      (interactive)
      (let ((skeletor-project-directory default-directory))
        (call-interactively 'skeletor-create-project)))

    ;; global substitutions
    (add-to-list 'skeletor-global-substitutions
                 '("__AUTHOR__" . "Adrian Fullmer"))

    (defun setup--lorri (dir)
      (let ((default-directory dir))
        (skeletor-shell-command "direnv allow")
        (projectile-lorri-watch)))

    ;; Custom project types
    (skeletor-define-template "generic"
      :title "Generic Project"
      :substitutions
      '(("__PACKAGES__" . (lambda () (read-string "Packages to use: "))))
      :after-creation setup--lorri)

    (skeletor-define-template "common-lisp"
      :title "Common Lisp Project"
      :substitutions
      '(("__DESCRIPTION__" . (lambda () (read-string "Description: "))))
      :after-creation setup--lorri)

    (skeletor-define-template "python"
      :title "Python Library"
      :substitutions
      '(("__PACKAGES__" . (lambda () (read-string "Packages: "))))
      :after-creation setup--lorri)

    (skeletor-define-template "haskell"
      :title "Haskell Project"
      :substitutions
      '(("__HASKELL-PACKAGES__" . (lambda () (read-string "Haskell packages: ")))
        ("__PACKAGES__" . (lambda () (read-string "Other packages: "))))
      :after-creation setup--lorri)

    ;;keybindings
    (project-key-def 'normal
      "s" 'skeletor-create-project-here))
#+END_SRC
** FZF
As powerful as ~projectile~ is, ~fzf~ still takes the cake on
speed of recursive search.
#+BEGIN_SRC emacs-lisp
  (use-package fzf)
#+END_SRC

This function opens a directory using ~fzf/start~.
#+BEGIN_SRC emacs-lisp
  (defun fzf-directory-from-home () (interactive)
         (fzf/start "~/" "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null"))

  (defun fzf-directory-from (directory) (interactive "D")
         (fzf/start directory "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null"))
#+END_SRC
** File navigation
I prefer to follow symbolic links under version control.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC

*** COMMENT Buffer rotating
I bind tab and shift-tab to functions which switch to the previous and
next buffer with content respectively.
#+BEGIN_SRC emacs-lisp
  (defun content-buffer-p (buffer))
  (general-define-key :states 'normal :keymaps 'override
                      "<tab>" 'previous-buffer
                      "<backtab>" 'next-buffer)
#+END_SRC
*** Buffer toggling
This is a keybinding for toggling between 2
buffers. Faster than ~,-b\r~.
#+BEGIN_SRC emacs-lisp
  (general-define-key :states 'normal ; :keymaps 'override
                      "<tab>" 'evil-buffer)
#+END_SRC
* Programming tools and settings
** Autocompletion
I, like many others, use ~company~.
#+BEGIN_SRC emacs-lisp
    (use-package company
      :delight
      :config
      (add-to-list 'company-frontends 'company-tng-frontend) ; test this vs evil collection
      (add-to-list 'completion-styles 'initials t)
      ;;(add-to-list 'completion-styles 'substring t)
      (define-key company-active-map (kbd "M-.") 'company-show-location)
      (define-key company-active-map (kbd "\C-d") 'company-show-doc-buffer)
      ;;(setq company-dabbrev-downcase 0)
      (setq company-minimum-prefix-length 2)
      (setq company-idle-delay 0)
      (add-hook 'sly-mode-hook (lambda () (progn (setq company-idle-delay 0.5)
                                                 (setq company-minimum-prefix-length 3))))
      (global-company-mode nil))
#+END_SRC
** Linting
I also, like many others, use ~flycheck~.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (setq flycheck-global-modes '(not c-mode c++-mode)))
#+END_SRC
** Git
I also also, like many others, use ~magit~, a very nice Git interface.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
With ~evil~ friendly keybindings.
#+BEGIN_SRC emacs-lisp
(use-package evil-magit)
#+END_SRC
and a leader shortcut.
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal
  "m" 'magit)
#+END_SRC
** COMMENT Snippets
~yasnippet~ allows the creation of snippets to automate repetitive typing.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :delight yas-minor-mode
    :config
    (yas-global-mode t)
    (setq yas-snippet-dirs
          (list (dotfiles "emacs/snippets") yasnippet-snippets-dir))
    (yas-reload-all))
#+END_SRC
A large collection of snippets is found in the ~yasnippet-snippets~ package.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :quelpa (:stable t))
#+END_SRC
~yasnippet~ can be used as a backend for ~company~.
#+BEGIN_SRC emacs-lisp
  ;; https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")

  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))

  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+END_SRC
** Language client features
The language server protocol can provide IDE-like features for many
languages. ~lsp-mode~ also serves as a backend for ~company~ and ~flycheck~ / ~flymake~.
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp
    :config
    (setq lsp-prefer-flymake nil))

  (use-package lsp-ui :commands lsp-ui-mode) ; adds flycheck support
  (use-package company-lsp :commands company-lsp) ; links with company
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
#+END_SRC
** Compilation
I wrote this function to run ~make~ on a recursive upward
search. Inspired by [[https://emacs.stackexchange.com/questions/7475/recursively-go-up-to-find-makefile-and-compile][this]].
#+BEGIN_SRC emacs-lisp
(cl-defun compile-rec (&key (filename "Makefile") (command "make -k"))
  "Traveling up the path, find a Makefile and `compile'."
  (interactive)
  (let ((makefile-dir (locate-dominating-file default-directory filename)))
    (when makefile-dir
      (with-temp-buffer
        (cd makefile-dir)
        (compile command)))))
#+END_SRC
** Documentation
A keybinding to access documentation.
#+BEGIN_SRC emacs-lisp
  (global-set-key [f3] (lambda () (interactive) (manual-entry (current-word))))
#+END_SRC
** Direnv and Lorri
Direnv allows Emacs to automatically set environment variables on a
per-buffer basis. Direnv integrates with Nix sandboxes through Lorri.
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :delight
    :after projectile ; I integrate projectile with direnv here
    :config
    (direnv-mode)

    ;; Keybindings to direnv refresh and lorri watch

    (cl-defun projectile-lorri-watch (&optional (project-directory (projectile-project-root)))
      "Begin an inferior process to watch the current projectile
  project with lorri."
      (interactive)
      (let* ((project-name (file-name-directory project-directory))
             (process-name (concat "Lorri [" project-name "]"))
             (default-directory project-directory))
        (if (file-exists-p "shell.nix")
            (if (not (get-process process-name))
                (progn
                  ;; (start-process-shell-command
                  ;;  (concat "direnv-" process-name) nil
                  ;;  "direnv-allow")
                  (start-process-shell-command
                   process-name (earmuffs process-name)
                   "lorri watch")
                  (message (concat "Lorri watching " project-name)))
              (error (concat "Lorri is already watching " project-name)))
          (error (concat "There is no shell.nix for " project-name)))))

    (project-key-def 'normal
      "d" 'direnv-update-directory-environment
      "l" 'projectile-lorri-watch)

    ;; Lorri watch the given project when switching to a new project.
    (add-hook 'projectile-after-switch-project-hook
              (lambda () (ignore-errors (projectile-lorri-watch))))

    ;; Non-file modes which should also be synched with direnv
    (defmacro add-direnv-non-file-modes (&rest body)
      `(mapcar (lambda (mode) (add-to-list 'direnv-non-file-modes mode)) (list ,@body)))

    (add-direnv-non-file-modes
     'sly-mode
     'eshell-mode
     'comint-mode
     'term-mode
     'prolog-mode
     'inferior-python-mode
     'haskell-mode))
#+END_SRC
** COMMENT Polymode
This is a very cool package that provides support for multiple major
modes in the same buffer. It seems to crash sometimes when editing org
files.
#+BEGIN_SRC emacs-lisp
(use-package polymode)
(use-package poly-org)
#+END_SRC
* Language specific tools and settings
** Lisps
*** Lispy/ville
~lispy~ is my S-expr editing tool of choice. It integrates with ~evil~
through ~lispyville~ minor mode.
#+BEGIN_SRC emacs-lisp
(use-package lispyville
  :delight
  :hook ((emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode) . lispyville-mode)
  :config
   (lispyville-set-key-theme
    '(operators
      ;; atom-motions
      prettify
      wrap
      slurp-cp
      barf-cp
      c-w
      (escape insert)
      (additional-movement normal visual motion))))
#+END_SRC
*** Rainbow delimiters
While ~rainbow-delimeters-mode~ is active each depth of delimiter is given a different color.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :delight)
#+END_SRC
** Emacs lisp
*** Keybindings
#+BEGIN_SRC emacs-lisp
(eval-key-def 'normal emacs-lisp-mode-map
  "b" 'eval-buffer
  "f" 'eval-defun)
(eval-key-def 'visual emacs-lisp-mode-map
  "r" 'eval-region)
#+END_SRC
** Common Lisp
*** Sly
~sly~ is a Common Lisp IDE for Emacs and a featureful fork of ~slime~.
#+BEGIN_SRC emacs-lisp
  (use-package sly
    ;; :quelpa (:stable t)
    ;; :load-path "~/code/elisp/sly"
    :after evil
    :config

    ;; make functions for using specific lisp implementations.
    (defmacro define-sly-lisp (name command)
      `(defun ,name ()  (interactive)  (sly ,command)))

    (defmacro define-sly-lisp-defun (name fn)
      `(defun ,name ()  (interactive)  (sly (funcall ,fn))))

    ;;(define-sly-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
    (define-sly-lisp sbcl "sbcl")
    (define-sly-lisp ecl "ecl --load /home/adrian/quicklisp/setup.lisp")
    (define-sly-lisp ccl "ccl")
    (define-sly-lisp clisp "clisp")

    (setq inferior-lisp-program "sbcl")
    ;; Open sly debug buffers in emacs state, rather than evil state.
    (add-to-list 'evil-emacs-state-modes 'sly-db-mode)
    (add-to-list 'helm-completing-read-handlers-alist
                 '(sly-read-symbol-name . nil))
    ;; Avoid using helm when bugget at sly-read-symbol-name functions
    (add-to-list 'helm-completing-read-handlers-alist
                 '(sly-describe-symbol . nil)
                 '(sly-describe-function . nil)))
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal sly-mode-map
  "z" 'sly-switch-to-output-buffer
  "c" 'sly-compile-file
  "l" 'sly-load-file)

(start-key-def 'normal sly-mode-map
  "s" 'sly
  "c" 'sly-connect)

(eval-key-def 'normal sly-mode-map
  "b" 'sly-eval-buffer
  "f" 'sly-eval-defun)
(eval-key-def 'visual 'sly-mode-map
  "r" 'sly-eval-region)
#+END_SRC
** Clojure
A popular lisp on the JVM.
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC
*** Cider
It's like ~slime~ for Clojure! Kinda.
#+BEGIN_SRC emacs-lisp
(use-package cider
  :config
  (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
  (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion))

;; some visual flare
(use-package spinner :quelpa (:stable t))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal clojure-mode-map
  "s" 'cider-jack-in
  "z" 'cider-switch-to-repl-buffer
  "a" 'cider-close-ancillary-buffers)

(eval-key-def 'normal clojure-mode-map
  "b" 'cider-eval-buffer
  "f" 'cider-eval-defun-at-point)
#+END_SRC
** Scheme
*** Geiser
It's like ~slime~ for Scheme. Kinda.
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :config
  (setq geiser-active-implementations '(racket))
  ;; geiser keybindings
  (leader-key-def 'normal geiser-mode-map
    "z" 'geiser-mode-switch-to-repl
    "c" 'geiser-compile-file
    "l" 'geiser-load-file)
  
  (start-key-def 'normal geiser-mode-map
    "s" 'geiser
    "c" 'geiser-connect)
  
  (eval-key-def 'normal geiser-mode-map
    "b" 'geiser-eval-buffer
    "f" 'geiser-eval-definition)
  (eval-key-def 'visual 'geiser-mode-map
    "r" 'geiser-eval-region)
  (general-define-key
   :states 'normal
   :keymaps 'geiser-repl-mode-map
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC
** Python
*** COMMENT Linting
Python support is built in to ~flycheck~.
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'python-mode-hook #'flycheck-mode)
#+END_SRC
*** Language Server
Python support is built in to ~lsp-mode~.
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'python-mode-hook #'lsp)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal python-mode-map
    "z" 'python-shell-switch-to-shell)

  (start-key-def 'normal python-mode-map
    "s" 'run-python)

  (eval-key-def 'normal python-mode-map
    "b" 'python-shell-send-buffer
    "f" 'python-shell-send-defun)

  (eval-key-def 'visual 'python-mode-map
    "r" 'python-shell-send-region)
#+END_SRC
** Shen
An intriguing and small language that runs on Common Lisp and other
things.
#+BEGIN_SRC emacs-lisp
(use-package shen-mode)

(leader-key-def 'normal shen-mode-map
  "z" 'switch-to-shen
  "c" 'shen-compile-file
  "l" 'shen-load-file)

(start-key-def 'normal shen-mode-map
  "s" 'run-shen)

(eval-key-def 'normal shen-mode-map
  "b" 'shen-eval-buffer
  "f" 'shen-eval-defun)

(eval-key-def 'visual 'shen-mode-map
  "r" 'shen-eval-region)
#+END_SRC
** Prolog
I use the built-in prolog mode.
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal prolog-mode-map
    "z" 'switch-to-prolog
    "c" 'prolog-compile-buffer)

  (start-key-def 'normal prolog-mode-map
    "s" 'run-swi-prolog)

  (eval-key-def 'normal prolog-mode-map
    "b" 'prolog-consult-buffer
    "f" 'prolog-consult-predicate)

  (eval-key-def 'visual 'prolog-mode-map
    "r" 'prolog-consult-region)
#+END_SRC
*** Helper functions
#+BEGIN_SRC emacs-lisp
  (defun run-swi-prolog ()
    (interactive)
    (let ((prolog-program-name "swipl"))
      (call-interactively 'run-prolog)))
#+END_SRC
** C/C++/CPP/Cpp/Sepples
*** COMMENT CQuery
A language server back end for C/++
#+BEGIN_SRC emacs-lisp
(use-package cquery
  :after projectile
  :init
  (add-hook 'c-mode-hook #'cquery//enable)
  (add-hook 'c++-mode-hook #'cquery//enable)
  :config
  (defun cquery//enable ()
    (condition-case nil
        (lsp)
      (user-error nil)))
  (setq cquery-executable "cquery")
  (setq cquery-extra-init-params '(:cacheFormat "msgpack"))
  (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".cquery")
                projectile-project-root-files-top-down-recurring)))
#+END_SRC
*** Font lock
Corrects font lock for modern C++.
#+BEGIN_SRC emacs-lisp
(use-package modern-cpp-font-lock
  :config
  (modern-c++-font-lock-global-mode t))
#+END_SRC
*** Linting
Enable ~flycheck~
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'flycheck-mode)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal c-mode-base-map
    "s" 'projectile-find-other-file
    "c" 'compile-rec
    "r" '(lambda () (interactive) (compile-rec :command "make run")))
#+END_SRC
*** Style
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4
              c-default-style "linux")
#+END_SRC
** Julia
#+BEGIN_SRC emacs-lisp
(use-package julia-repl
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :config
  ;; allows capf and dabbrev backends while using haskell
  (add-hook 'haskell-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   (append '((company-capf company-dabbrev-code))
                           company-backends)))))
#+END_SRC
** Elm
#+BEGIN_SRC emacs-lisp
(use-package flycheck-elm
  :config
  (add-hook 'flycheck-mode-hook 'flycheck-elm-setup))
  
(use-package elm-mode)
#+END_SRC
** Org
~org-mode~ is a markup mode with many features, including creating
literate source files like this one.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :delight org-indent-mode
    ;; :hook (org-mode ((lambda nil (load-theme-buffer-local 'tsdh-light (current-buffer)))))
    :config
    (setq header-line-format " ")
    ;;(add-hook 'org-mode-hook '(load-theme-buffer-local 'tsdh-light (current-buffer)))
    ;; (lambda () (progn
    ;;              (setq left-margin-width 2)
    ;;              (setq right-margin-width 2)
    ;;              (set-window-buffer nil (current-buffer))))
    ;;(setq line-spacing 0.1)
    (setq org-startup-indented t
          ;;org-bullets-bullet-list '(" ") ;; no bullets, needs org-bullets package
          ;;org-ellipsis "  " ;; folding symbol
          org-pretty-entities t
          org-hide-emphasis-markers t
          ;; show actually italicized text instead of /italicized text/
          ;;;org-agenda-block-separator ""
          org-fontify-whole-heading-line t
          org-fontify-done-headline t
          org-fontify-quote-and-verse-blocks t
          org-src-ask-before-returning-to-edit-buffer nil)
    (general-define-key :states 'normal :mode 'org-mode-map
                        "C-`" 'org-edit-special)

                        ;; "C-j" 'evil-window-down
                        ;; "C-k" 'evil-window-up
    ;; (define-key org-mode-map (kbd "<C-j>") nil)
    ;; (define-key org-mode-map (kbd "<C-k>") nil)
    (leader-key-def 'normal org-src-mode-map
      "w" 'org-edit-src-exit)
    (add-hook 'org-mode-hook (lambda ()
                               (general-define-key :states 'normal :mode 'org-mode-map
                                                   "C-j" 'evil-window-down
                                                   "C-k" 'evil-window-up))))
#+END_SRC
A hydra to jump between org-babel source blocks:
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-org-babel-source-block-jump (org-mode-map "C-c C-v")
      "Jump between org babel source blocks"
      ("n" org-babel-next-src-block)
      ("p" org-babel-previous-src-block))
#+END_SRC
Create a table of contents without exporting.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :config
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC
** Nix
These are tools for dealing with NixOS, my operating system.
*** COMMENT Sandbox
Features for dealing with nix-shell in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package nix-sandbox)
#+END_SRC
*** Nix language support
#+BEGIN_SRC emacs-lisp
  (use-package company-nixos-options
    :hook (nix-mode-hook . (lambda () (add-to-list 'company-backends 'company-nixos-options))))

  (use-package nix-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
    (add-hook 'nix-mode-hook
              (lambda ()
                (setq tab-always-indent nil)
                (setq indent-tabs-mode t))))

#+END_SRC
** Bash
#+BEGIN_COMMENT 
I use a zero width space here to escape the underscore 
#+END_COMMENT
Enter mode for bash on .profile, .bash_aliases, and .inputrc
#+BEGIN_SRC emacs-lisp
  (auto-mode-add 'shell-script-mode
                 ".profile\\'"
                 ".bash_aliases\\'"
                 ".inputrc\\'")
#+END_SRC
*** Auto Mode
Enter ~common-lisp-mode~ in the following files
#+BEGIN_SRC emacs-lisp
  (auto-mode-add 'common-lisp-mode
       ".sbclrc\\'"
       ".lisprc\\'"
       ".otherlisprc\\'")
#+END_SRC
* Excessive Nonsense
** COMMENT Spotify
Control spotify running on any device from Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package spot4e :load-path "~/code/elisp/spot4e"
    :after general
    :requires helm url json
    :config
    (setq spot4e-refresh-token me/spotify-refresh-token)
    (run-with-timer 0 (* 60 59) 'spot4e-refresh)

    (define-subleader :leader alt-leader
      "s" "spotify" spotify-key-def)
    (spotify-key-def 'normal emacs-lisp-mode-map
      "b" 'spot4e-helm-search-user-tracks
      "r" 'spot4e-helm-search-recommendations-track
      "s" 'spot4e-player-pause
      "p" 'spot4e-player-play
      "n" 'spot4e-player-next
      "N" 'spot4e-player-previous))
#+END_SRC
** Emacs window manager
*** Main Package
Call emacsclient with ~-f exwm-enable~ in order to start exwm.
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :config
    (fringe-mode 1)
    (require 'exwm-config)
    (add-hook 'exwm-update-class-hook
              (lambda ()
                (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-title))))
    (general-define-key :keymaps 'exwm-mode-map
                        "C-c C-f" 'exwm-layout-toggle-fullscreen
                        "C-c C-l" 'exwm-floating-toggle-floating)

    (setq exwm-input-global-keys
          `(;; Bind "s-r" to exit char-mode and fullscreen mode.
            ([?\s-r] . exwm-reset)

            ;; Bind f11 to toggle full screen
            ([f11] . exwm-layout-toggle-fullscreen)

            ;; Bind "s- " to launch exteral commands
            ([?\s- ] . helm-run-external-command)

            ;;workspaces
            ([?\s-m] . make-workspace)
            ([?\s-d] . delete-workspace)

            ([?\s-n] . next-workspace)
            ([?\s-p] . previous-workspace)

            ([s-tab] . switch-workspace)

            ;; bind "s-[direction] to switch windows"
            ([?\s-h] . windmove-left)
            ([?\s-j] . windmove-down)
            ([?\s-k] . windmove-up)
            ([?\s-l] . windmove-right)

            ;; bind "s-arrow" to move, "maximize" or "minimize" a window
            ([s-right] . windows-right)
            ([s-down] . evil-quit)
            ([s-up] . delete-other-windows)
            ([s-left] . windows-left)
            ;; bind "s-[v and s] to split vertical and horizontal"
            ([?\s-v] . evil-window-vsplit)
            ([?\s-s] . evil-window-split)
            ;; bind "s-z" to M-x
            ([?\s-z] . helm-M-x)
            ;; bind "s-;" to ex mode
            ([?\s-\;] . evil-ex)
            ;; bind "s-b" to buffer switching
            ([?\s-b] . helm-mini)
            ;; bind "s-f" to file switching
            ([?\s-f] . helm-find-files) 
            ;; bind "s-q" to kill this buffer, closing the current
            ;; program, and "s-w" to kill the current buffer AND window
            ([?\s-q] . actually-kill-this-buffer)
            ([?\s-w] . evil-delete-buffer)
            ;; bind "s-g" to keyboard-quit
            ([?\s-g] . keyboard-quit)))

    ;; start in char mode by default
    (setq exwm-manage-configurations '((t char-mode t)))

    ;; sys tray
    (require 'exwm-systemtray)
    (exwm-systemtray-enable)

    ;; set prefix keys
    (setq my-exwm-prefix-keys (list
                               ?\: ; evil ex mode
                               ?\, ; leader key
                               ?\M-x ; M-x
                              ?\C-w)) ; window options

    (setq exwm-input-prefix-keys (nconc exwm-input-prefix-keys my-exwm-prefix-keys))

    ;; Allow pulling a window between workspaces by switching to its buffer
    ;; to see x windows on other workspaces, do C-c a
    (setq exwm-workspace-show-all-buffers t)
    (setq exwm-layout-show-all-buffers t)

    ;; Redefine function to fix global-display-line-numbers-mode bug
    ;; regarding the exwm "frame" not having the 'client parameter
    (defun display-line-numbers--turn-on ()
      "Turn on `display-line-numbers-mode'."
      (unless (or (minibufferp)
                  ;; taken from linum.el
                  nil
                  ;; (and (daemonp) (null (frame-parameter nil 'client)))
                  )
        (display-line-numbers-mode))))
#+END_SRC
*** Workspaces
#+BEGIN_SRC emacs-lisp
  (defconst default-workspace-name  "default-workspace")
  (defvar workspace--names (list default-workspace-name)
    "List of names of workspaces, nil for unnamed.")
  (defvar workspace--history (list 0)
    "List of all workspace indicies. Earliest in this list is
    most recently visited")

  (setq exwm-workspace-index-map
        (lambda (index)
          (or (workspace--index-to-name index)
              (number-to-string index))))

  (defun workspace-index-names ()
    (mapcar exwm-workspace-index-map
            (number-sequence 0 (1- (exwm-workspace--count)))))

  (defun current-workspace-index ()
    (exwm-workspace--position (selected-frame)))

  (defun current-workspace-name ()
    (workspace--index-to-name (current-workspace-index)))

  (cl-defun select-workspace (&key prompt without-default-workspace order)
    (let* ((workspace-list (if without-default-workspace
                               (remove default-workspace-name
                                       (workspace-index-names))
                             (workspace-index-names)))
           (ordered-workspace-list (cond ((equal order :last-visited)
                                          (mapcar exwm-workspace-index-map workspace--history))
                                         ((equal order :last-visited-current-last)
                                          (mapcar exwm-workspace-index-map (append (remove (current-workspace-index)
                                                                                           workspace--history)
                                                                                   (list (current-workspace-index)))))
                                         ((equal order :newest-first) (reverse workspace-list))
                                         ((equal order :oldest-first) workspace-list)
                                         (t workspace-list))))
      (completing-read (if prompt prompt (format "Select Workspace (current: [%s]): "
                                                 (current-workspace-name)))
                       ordered-workspace-list)))

  (cl-defun switch--to-workspace (name-or-index &key (update-history t))
    (unless (workspace-handle-valid-p
             name-or-index)
      (error (format "Workspace %s does not exist" name-or-index)))
    (exwm-workspace-switch (workspace--name-to-index name-or-index))
    (when update-history
      (setq workspace--history
            (remove (workspace--name-to-index name-or-index) workspace--history))
      (add-to-list 'workspace--history (workspace--name-to-index name-or-index))))

  (defun switch-workspace ()
    (interactive)
    (switch--to-workspace (select-workspace :order :last-visited-current-last)))

  (cl-defun make--workspace (&optional (name nil))
    (cond ((string-to-integer-or-nil name)
           (error "Cannot use a number as the workspace name"))
          ((find-if (lambda (s) (string= s name)) workspace--names)
           (error (format "The workspace name '%s' is already in use" name)))
          (t (exwm-workspace-switch 0)
             (exwm-workspace-add)
             (add-to-list 'workspace--history (current-workspace-index))
             (add-to-list 'workspace--names name t))))

  (defun make-workspace ()
    (interactive)
    (make--workspace (read-string "Workspace Name: ")))

  (defun delete--workspace (name-or-index)
    (cond
     ((not (workspace-handle-valid-p name-or-index))
      (error (format "Workspace %s does not exist" name-or-index)))
     ((or (when (stringp name-or-index)
            (string= name-or-index default-workspace-name))
          (when (numberp name-or-index)
            (= name-or-index 0)))
      (error "Cannot delete the default workspace."))
     (t
      (if (equal (workspace--name-to-index name-or-index)
                 (current-workspace-index))
          (switch--to-workspace (second workspace--history)))
      (setq workspace--history
            (remove (workspace--name-to-index name-or-index) workspace--history))
      (setq workspace--names
            (remove-if (lambda (s)
                         (string= s (workspace--index-to-name name-or-index)))
                       workspace--names))
      (exwm-workspace-delete (workspace--name-to-index name-or-index)))))

  (defun delete-workspace ()
    (interactive)
    (delete--workspace (select-workspace :without-default-workspace t
                                         :order :newest-first)))

  (defun next-workspace ()
    "Switch to the next workspace in order of creation"
    (interactive)
    (switch--to-workspace (1+ (current-workspace-index)))
    (message (format "Current Workspace: [%s]" (current-workspace-name))))

  (defun previous-workspace ()
    "Switch to the previous workspace in order of creation"
    (interactive)
    (switch--to-workspace (1- (current-workspace-index)))
    (message (format "Current Workspace: [%s]" (current-workspace-name))))

  (defun workspace--index-to-name (name-or-index)
    (if (numberp name-or-index)
        (nth name-or-index workspace--names)
      name-or-index))

  (defun workspace--name-to-index (name-or-index)
    (if (numberp name-or-index)
        name-or-index
      (or (string-to-integer-or-nil name-or-index)
          (position-if (lambda (s) (string= s name-or-index))
                       workspace--names))))

  (defun workspace-handle-valid-p (name-or-index)
    (if (numberp name-or-index)
        (> (exwm-workspace--count) name-or-index)
      (find-if (lambda (s) (string= s name-or-index))
               (workspace-index-names))))
#+END_SRC
*** COMMENT Launcher
My implementation of an equivalent of dmenu and the ".desktop" file
system for launching and switching between programs quickly
#+BEGIN_SRC emacs-lisp

#+END_SRC
*** Symon system monitor
#+BEGIN_SRC emacs-lisp
  (use-package symon
    :config
    (symon-mode))
#+END_SRC
*** Helm EXWM
~Helm-EXWM~ defines helm sources for exwm buffers
#+BEGIN_SRC emacs-lisp
  (use-package helm-exwm)
#+END_SRC
*** Desktop Environment
~desktop-environment~ is a package which provides keybindings for tasks such as changing volume.
#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :delight
    :config
    (desktop-environment-mode))
#+END_SRC
*** EXWM firefox
#+BEGIN_SRC emacs-lisp
  (use-package exwm-firefox-core)

  (use-package exwm-firefox-evil)

  (setq browse-url-generic-program "firefox")
#+END_SRC
*** COMMENT Network Manager
Emacs interface to network manager. Buggy
#+BEGIN_SRC emacs-lisp
  (quelpa '(nm :fetcher github :repo "Kodkollektivet/emacs-nm"))
#+END_SRC
*** Helpful commands
#+BEGIN_SRC emacs-lisp
  ;; logout function
  (defun logout ()
    (interactive)
    (recentf-save-list)
    (save-some-buffers)
    (start-process-shell-command "logout" nil "lxsession-logout"))

  (defun bluetooth ()
    (interactive)
    (split-window-vertically)
    (other-window 1)
    (start-process-shell-command "blueman-manager" nil "blueman-manager"))

  (defmacro define-shell-function (name command)
    `(defun ,name ()
       (interactive)
       (start-process-shell-command ,(symbol-name name)
                                    nil
                                    ,command)))

  (create-multi-macro--old define-shell-functions define-shell-function 2)

  (define-shell-functions
    wifi "cool-retro-term -e nmtui"
    spotify "spotify --force-device-scale-factor=2")
#+END_SRC
* Files and backups
Don't make backups.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC
Save cursor position in a file between sessions.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
* COMMENT After startup
Load themes after everything else because it seems that the faces are
incorrect otherwise.
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<themes>>
#+END_SRC
* Helper functions
Various small functions which are evaluated before anything else in the file.
#+NAME: helper-functions
#+BEGIN_SRC emacs-lisp
  (defun auto-mode-add (mode &rest filenames)
    "Add a number of file name patterns to the given mode in
    auto-mode-alist"
    (mapcar (lambda (name)
              (add-to-list 'auto-mode-alist
                           `(,name . ,mode)))
            filenames))

  (defun remove-keyword-args (list)
    "Remove keyword arguments from the given list"
    (car (general--remove-keyword-args list)))

  (defun earmuffs (string)
    "Add *earmuffs* to the given string. This represents the name
      of a buffer which is not associated with a file."
    (concat "*" string "*"))

  (defun reload-init-file ()
    "Load all elisp from 'user-init-file'."
    (interactive)
    (load-file user-init-file))

  (defun move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (forward-line -2)
    (indent-according-to-mode))

  (defun move-line-down ()
    "Move down the current line."
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)
    (indent-according-to-mode))

  (defun reboot ()
    (interactive)
    (shell-command "reboot"))

  (defun dotfiles (path)
    "Return path relative to the dotfiles directory"
    (concat me/dotfiles path))

  (defun actually-kill-this-buffer ()
    "Kills the current buffer, unlike ~kill-this-buffer~ which does
    not always do that."
    (interactive)
    (kill-buffer (current-buffer)))

  (defun windows-right ()
    (interactive)
    (if (> (length (window-list)) 1)
        (evil-window-move-far-right)
      (progn
        (split-window-right)
        (evil-window-move-far-right)
        (other-window 1)
        (next-buffer)
        (other-window 1))))

  (defun windows-left ()
    (interactive)
    (if (> (length (window-list)) 1)
        (funcall-interactively
         #'evil-window-move-far-left)
      (progn
        (split-window-right)
        (other-window 1)
        (next-buffer)
        (other-window 1))))

  (defun eshell-new ()
    "Open a new instance of eshell."
    (interactive)
    (eshell 'N))

  (defun eshell-at (directory)
    "Open a new instance of eshell in a new directory."
    (let ((default-directory directory))
      (eshell-new)))

  (defun disable-most-recent-theme ()
    (interactive)
    (disable-theme (first custom-enabled-themes)))

  (defun switch-theme (theme)
    "load a theme interactively while disabling the current one."
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapcar 'symbol-name
                                       (custom-available-themes))))))
    (disable-most-recent-theme)
    (load-theme theme t))

  (defun string-represents-integer-p (string)
    "Truthy if string is a representation of an integer (leading
  zeroes allowed), nil otherwise."
    (string-match-p "\\`[0-9][0-9]*\\'" string))

  (defun string-to-integer-or-nil (string)
    "If the string represents an integer, return that integer,
  otherwise return nil."
    (when (string-represents-integer-p string)
      (string-to-number string)))

  (defun circular (list)
    "Return a copy of the given list where the last element points
  to the first, rather than to nil."
    (when list
      (let ((new-list (copy-list list)))
         (setf (cdr (last new-list))
                  new-list))))

  (defmacro create-multi-macro--old (name macro num-parameters)
    `(defmacro ,name (&rest args)
       `(progn ,@(mapcar (lambda (elt)
                           `(,',macro ,@elt))
                         (seq-partition args ,num-parameters)))))

  (defmacro create-multi-macro (name macro num-parameters &key kwargs)
    "kwargs is a list of keyword arguments to be accepted by macro"
    `(cl-defmacro ,name ,(append `(&rest args) (when kwargs (append `(&key) kwargs `(&allow-other-keys))))
       `(progn ,@(mapcar (lambda (elt)
                           ,(let ((result (list (quote backquote) (list macro ',@elt))))
                                 (dolist (kwarg kwargs)
                                   (setf (cadr result) (append (cadr result)
                                                        (list (make-symbol
                                                               (concat ":"
                                                                       (symbol-name kwarg)))
                                                              (list
                                                               (quote \,)
                                                               kwarg)))))
                                 result))
                         (seq-partition (remove-keyword-args args) ,num-parameters)))))
#+END_SRC
