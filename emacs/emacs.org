#+TITLE: Emacs Configuration



Emacs is a truly fantastic piece of software. Part REPL, part
with Emacs, slowly carving it into the perfect interface for allmost
everything my computer has to offer; and yet I feel as if I have only
just begun to scratch the surface. With that said, the remainder of
this file constitutes my emacs configuration. Please enjoy!

* Table of contents                                                     :TOC:
- [[#startup][Startup]]
  - [[#lexical-scope][Lexical Scope]]
  - [[#garbage-collector-threshold][Garbage Collector Threshold]]
  - [[#filename-handlers][Filename Handlers]]
- [[#packages][Packages]]
  - [[#package-initialization][Package Initialization]]
  - [[#use-package][Use-Package]]
  - [[#quelpa][Quelpa]]
- [[#evil][Evil]]
  - [[#evil-collection][Evil collection]]
  - [[#evil-easymotion][Evil easymotion]]
  - [[#evil-surround][Evil surround]]
  - [[#the-creation-of-text-objects][The creation of text objects]]
- [[#keybindings-and-commands][Keybindings and commands]]
  - [[#generalel][General.el]]
  - [[#commands][Commands]]
  - [[#normal-mode][Normal Mode]]
  - [[#visual-mode][Visual Mode]]
  - [[#leader][Leader]]
- [[#user-interface-preferences][User interface preferences]]
  - [[#startup-screen][Startup screen]]
  - [[#mode-line][Mode line]]
  - [[#helm][Helm]]
  - [[#hideshow][Hideshow]]
  - [[#unnecessary-ui-elements][Unnecessary UI elements]]
  - [[#line-and-column-numbers][Line and Column numbers]]
  - [[#start-frame-maximized][Start frame maximized]]
  - [[#confirmation][Confirmation]]
  - [[#clipboard][Clipboard]]
  - [[#delimiters][Delimiters]]
  - [[#mouse-settings][Mouse settings]]
  - [[#which-key][Which-key]]
- [[#shell][Shell]]
  - [[#eshell][Eshell]]
  - [[#comint-mode][Comint Mode]]
  - [[#shell-1][Shell]]
  - [[#multi-term][Multi-Term]]
- [[#tramp][Tramp]]
- [[#emacs-clientserver-settings][Emacs client/server settings]]
  - [[#daemon-management][Daemon Management]]
- [[#colors-themes-fonts-and-other-aesthetic-settings][Colors, Themes, Fonts, and other aesthetic settings]]
  - [[#doom-themes][Doom Themes]]
  - [[#poet-theme][Poet Theme]]
  - [[#theme][Theme]]
- [[#text-tab-and-indent-related][Text, tab and indent related]]
- [[#moving-around-buffers-windows-and-splits][Moving around, buffers, windows and splits]]
  - [[#winner-mode][Winner Mode]]
  - [[#projectile][Projectile]]
  - [[#fzf][FZF]]
  - [[#file-navigation][File navigation]]
- [[#programming-tools-and-settings][Programming tools and settings]]
  - [[#autocompletion][Autocompletion]]
  - [[#linting][Linting]]
  - [[#git][Git]]
  - [[#language-client-features][Language client features]]
  - [[#compilation][Compilation]]
- [[#language-specific-tools-and-settings][Language specific tools and settings]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs lisp]]
  - [[#common-lisp][Common Lisp]]
  - [[#scheme][Scheme]]
  - [[#shen][Shen]]
  - [[#clojure][Clojure]]
  - [[#cccppcppsepples][C/C++/CPP/Cpp/Sepples]]
  - [[#julia][Julia]]
  - [[#haskell][Haskell]]
  - [[#elm][Elm]]
  - [[#org][Org]]
  - [[#nix][Nix]]
  - [[#bash][Bash]]
- [[#excessive-bs][Excessive BS]]
  - [[#spotify][Spotify]]
  - [[#emacs-window-manager][Emacs window manager]]
- [[#files-and-backups][Files and backups]]
- [[#helper-functions][Helper functions]]

* Startup
** Lexical Scope
My first move is to enable lexical scope. This not only improves
execution time, but also allows lexical techniques such as closure to
be used. This declaration is contained within a comment because
lexical scope was only introduced to Emacs in version 24.1
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC

** Garbage Collector Threshold
In search of faster startup times, I discovered a technique that
involves increasing the garbage collection threshold during starup. I
got this idea from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]]. Look there for more advice for
improving startup time.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6)

(add-hook 'emacs-startup-hook
  (setq gc-cons-threshold 16777216
        gc-cons-percentage 0.1))
#+END_SRC

** Filename Handlers
Similarly to the garbage collector, startup time can be improved by
disabling the ~file-name-handler-alist~, as it will not be needed during
startup. This trick also comes from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]].
#+BEGIN_SRC emacs-lisp
(defvar temp-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

(add-hook 'emacs-startup-hook
  (setq file-name-handler-alist temp-file-name-handler-alist))
#+END_SRC

* Packages
** Package Initialization
Before I can install packages I must first initialize package sources
and installation tools. Here I source Elpa and Melpa.
#+BEGIN_SRC emacs-lisp

(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl (warn "\
Your version of Emacs does not support SSL connections,
which is unsafe because it allows man-in-the-middle attacks.
There are two things you can do about this warning:
1. Install an Emacs version that does support SSL and be safe.
2. Remove this warning from your init file so you won't see it again."))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+END_SRC

** Use-Package
I use the ever-popular package-using facility ~use-package~. It is
installed automatically by a nix expression in my dotfiles. This line
causes ~use-package~ expressions to be automatically downloaded.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

** Quelpa
Quelpa is a package installation facility that allows packages to be
installed from arbitrary sources. This is convenient for getting
bleeding edge versions of packages which have yet to reach Melpa.
#+BEGIN_SRC emacs-lisp
(use-package quelpa)

(setq quelpa-upgrade-p nil)

(use-package quelpa-use-package)

(quelpa-use-package-activate-advice)
#+END_SRC

** COMMENT Automatic Upgrades
I decided that I prefer stability, but I could evaluate the following code to enable it.
#+BEGIN_SRC emacs-lisp
(setq quelpa-upgrade-p t)

(package-refresh-contents)

(use-package auto-package-update
  :config
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+END_SRC
* Evil
These are settings for the emulation of Vim in Emacs. I would not be
using emacs today if it were not for Evil mode. I really do love Vim.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  ;; highlight all search results
  (setq evil-search-module 'evil-search)
  ;; settings for evil-collection integration
  (setq evil-want-keybinding nil)
  (setq evil-want-integration t)
  :config
  (evil-mode 1)
  ;; The undo tree sometimes deletes undo data, I prefer to just disable it.
  (global-undo-tree-mode -1))
#+END_SRC
** Evil collection
This provides Evil-friendly keybindings for a variety of modes.
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :init
  (setq evil-want-keybinding nil)
  :after evil
  :config
  (evil-collection-minibuffer-setup)
  (evil-collection-init))
#+END_SRC


** Evil easymotion
This package helps with the issue of not knowing how many times to
repeat an evil motion by providing jumpable tags at the location of
each possible motion result.
#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :config
  (evilem-default-keybindings "SPC"))
#+END_SRC
** Evil surround
This solves the tricky issue of surrounding a block of text with
delimiters when they automatically close.
#+BEGIN_SRC emacs-lisp
(use-package "evil-surround"
  :config
  (global-evil-surround-mode 1))
#+END_SRC
** COMMENT Evil snipe
At one point I used ~evil-snipe~, a tool for jumping to pairs of characters.
#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :after evil-easymotion
  :config
  (evilem-define (kbd "SPC s") 'evil-snipe-s))
#+END_SRC
** The creation of text objects
This macro was copied from [[https://stackoverflow.com/a/22418983/4921402][this]] Stackoverflow thread, and facilitates
the creation of Evil text objects.
#+BEGIN_SRC emacs-lisp
(defmacro define-and-bind-quoted-text-object (name key start-regex end-regex)
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-a-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count t))
       (define-key evil-inner-text-objects-map ,key #',inner-name)
       (define-key evil-outer-text-objects-map ,key #',outer-name))))

(defalias 'textobj 'define-and-bind-quoted-text-object)
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
(textobj "pipe" "|" "|" "|")
(textobj "slash" "/" "/" "/")
#+END_SRC
* Keybindings and commands
** General.el
I mainly use the the package General to define keybindings and
commands. It integrates well with evil.
#+BEGIN_SRC emacs-lisp
(use-package general)
(general-evil-setup)
#+END_SRC
** Commands
I don't have too much use for Evil commands, but early on I created a
couple.
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "Src" 'reload-init-file)
(evil-ex-define-cmd "Restart" 'restart-emacs)
#+END_SRC
** Normal Mode
These are normal mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-nmap
  "C-h" 'evil-window-left
  "C-j" 'evil-window-down
  "C-k" 'evil-window-up
  "C-l" 'evil-window-right
  "s-h" 'evil-window-left
  "s-j" 'evil-window-down
  "s-k" 'evil-window-up
  "s-l" 'evil-window-right
  "s-H" 'evil-window-move-far-left
  "s-J" 'evil-window-move-very-bottom
  "s-K" 'evil-window-move-very-top
  "s-L" 'evil-window-move-far-right
  "C--" 'helm-projectile-grep
  ;; Move a line of text using ALT+[jk]
  "M-j" (kbd ":move + RET")
  "M-k" (kbd ":move .-2 RET")
  "M-j" 'move-line-down
  "M-k" 'move-line-up)
#+END_SRC
** Visual Mode
These are visual mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-vmap
  ;; Move a visual block of text using ALT+[jk]
  "M-k" (kbd ":move '< -2 RET `> my `< mz gv`yo`z"))
#+END_SRC
** Leader
The leader key is an old technique common among Vim users. A number of
sequential key commands for various purposes are hidden behind a
single key. For those who are familiar with Hydra.el, this is a
similar concept.
*** Definitions
#+BEGIN_SRC emacs-lisp
(defconst leader-key ",")
(defconst alt-leader "SPC")

(general-create-definer leader-key-def
  :prefix leader-key)

(general-create-definer eval-key-def
  :prefix (concat leader-key " e"))

(general-create-definer xpand-key-def
  :prefix (concat leader-key " x"))

(general-create-definer start-key-def
  :prefix (concat leader-key " s"))
#+END_SRC
*** Normal Mode
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal
  "q" 'kill-this-buffer              ; ",q" to kill buffer not window.
  "b" 'helm-mini                     ; ",b" to switch buffers.
  "f" 'helm-find-files               ; ",f" to find file (replace :e)
  "p" '(lambda () (interactive)
         ;; ",p" to fuzzy find directory from home directory
         (fzf/start "~/" "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null")) 
  "o" 'occur 
  "i" 'imenu
  "RET" (kbd ":noh"))
#+END_SRC
*** Visual Mode
#+BEGIN_SRC emacs-lisp
(leader-key-def 'visual
  "c" 'comment-or-uncomment-region)
#+END_SRC
* User interface preferences
These are settings related to the basic user interface of Emacs.
** Startup screen
I disable the default startup screen and splash message.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil)
#+END_SRC
*** Scratch buffer
In leiu of a startup screen
** Mode line
The mode line is the line at the bottom of each buffer. It contains
useful information.
*** Delight
Delight is a package which is used to hide unnecessary mode-line
blurbs.
#+BEGIN_SRC emacs-lisp
(use-package delight :quelpa (:stable t)
  :config
  (delight 'eldoc-mode nil "eldoc"))
#+END_SRC
** Helm
Helm is a framework for incremental narrowing searching interfaces
which integrates well across Emacs.
#+BEGIN_SRC emacs-lisp
(use-package helm
  :delight
  :bind (("M-x" . helm-M-x))
  :config (helm-mode t))
#+END_SRC
** Hideshow
Hideshow mode provides vim-like folds (but not as good).
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'hs-minor-mode)
(delight 'hs-minor-mode nil "hideshow")
#+END_SRC
** Unnecessary UI elements
Emacs comes with such useless features as a tool bar. Turn them off.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
(add-to-list 'default-frame-alist
             '(vertical-scroll-bars . nil))
#+END_SRC
** Line and Column numbers
Display them both on the side of the buffer and in the mode line.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
(display-line-numbers-mode 1)

(setq column-number-mode t)
#+END_SRC
** Start frame maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Confirmation
Type =y= or =n=, not =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Clipboard
Enable vim-like clipboard.
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard nil)
#+END_SRC

** Delimiters
*** Electric pair mode
Close delimiters automatically as I write.
#+BEGIN_SRC emacs-lisp
(electric-pair-mode nil)
#+END_SRC
*** Highlight parentheses
Highlight the nearest outer parentheses. Thanks to [[https://stackoverflow.com/questions/34846531/show-parentheses-when-inside-them-emacs][this]] thread.
#+BEGIN_SRC emacs-lisp
(define-advice show-paren-function (:around (fn) fix)
  "Highlight enclosing parens."
  (cond ((looking-at-p "\\s(") (funcall fn))
        (t (save-excursion
             (ignore-errors (backward-up-list))
             (funcall fn)))))
#+END_SRC

*** Matching parens
Thanks to the above code, I no longer need the following code to show
the matching parenthesis.
#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
(setq show-paren-delay 0)
(setq show-paren-style 'parenthesis)
#+END_SRC

** Mouse settings
Don't accelerate while mouse scrolling.
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-progressive-speed nil)
#+END_SRC
Scroll the window currently under the mouse
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-follow-mouse 't)
#+END_SRC
** Which-key
This plugin shows the available keys after a partially completed
key press.
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (which-key-add-prefix-title
    ", e" "eval"))
#+END_SRC
* Shell
** Eshell
Eshell is an Emacs Lisp shell. Very cool.
#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-smart)
#+END_SRC

*** Configuration
And configuration: 
#+BEGIN_SRC emacs-lisp
(setq eshell-where-to-jump 'begin)
(setq eshell-review-quick-commands nil)
(setq eshell-smart-space-goes-to-end t)
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key [f2] 'eshell)
;; Let me use C-j/k
(add-hook 'eshell-mode-hook ; needs to be in a hook because eshell is dumb
          (lambda ()
            (general-define-key :states 'normal :keymaps 'eshell-mode-map
                                "C-j" 'evil-window-down
                                "C-k" 'evil-window-up)))
#+END_SRC

*** Helper Function
Function for making a new Eshell instance. From [[https://www.emacswiki.org/emacs/EshellMultipleEshellBuffers][this]] thread.
#+BEGIN_SRC emacs-lisp
(defun eshell-new()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

*** COMMENT Beginning of line behavior
Eshell doesn't play with Evil regarding the beginning of line
behavior. This is some scratch code I wrote which attempts and fails
to fix the problem.
#+BEGIN_SRC emacs-lisp
(setq eshell-prompt-regexp (regexp-quote "^\b$")
      eshell-prompt-function
      (lambda nil ""))

(setq old-eshell-prompt-function (lambda nil (eshell-prompt-function)))
(setq old-eshell-prompt-function (symbol-value 'eshell-prompt-function))
(setq eshell-prompt-function
      (lambda nil
        (restrict-bol (old-eshell-prompt-function))))
(setq eshell-prompt-function
      (lambda nil
        (restrict-bol (concat
                   (eshell/pwd)
                   " $ "))))
#+END_SRC
** Comint Mode
Comint mode is a generalized mode for repl-like interfaces.
#+BEGIN_SRC emacs-lisp
(setq comint-prompt-read-only t ; Don't let me delete the comint prompt duh
      comint-move-point-for-output nil ; reduce frequent redisplays
      comint-scroll-show-maximum-output nil)
#+END_SRC
** Shell
I prefer Shell-Mode to any newer terminal emulator because
Comint-Mode, the mode which Shell-Mode is based on, plays well with
Evil.
#+BEGIN_SRC emacs-lisp
(global-set-key [f1] 'shell)
(general-define-key :states 'normal :keymaps 'shell-mode-map
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up)
#+END_SRC
** Multi-Term
If for some reason I need Ansi Term instead of Shell, and for some
reason I need multiple of them, I have this plugin.
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :config
  ;; (global-set-key [f1] 'multi-term)
  ;; access shift arrow keys
  (define-key global-map "\eO2D" (kbd "S-<left>"))
  (define-key global-map "\eO2C" (kbd "S-<right>"))
  ;; term movement
  (general-define-key
   :states 'normal
   :keymaps 'term-mode-map
   "S-<right>" 'multi-term-next
   "S-<left>" 'multi-term-prev
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC
* Tramp
Tramp is a truly one of the great gems of Emacs. It allows one to
access remote files as if they were part of your filesystem within
Emacs.
#+BEGIN_SRC emacs-lisp
(defun connect-to-serenity ()
  (interactive)
  (dired "/ssh:axf1557@serenity.ist.rit.edu:/home/MAIN/axf1557/"))
#+END_SRC
* Emacs client/server settings
One of the personal breakthroughs I made when starting with Emacs was
realizing that I didn't have to wait 500 years every time I wanted to
edit a file. By running Emacs as a daemon, frames could be opened
instantaneously. Of course at this point I almost never close my Emacs
frame in the first place.
#+BEGIN_SRC emacs-lisp
;; run as server
(server-mode 1)

;; easily restart emacs daemon
(use-package restart-emacs)

;; focus any new frames
(add-to-list 'after-make-frame-functions 'select-frame-set-input-focus)
#+END_SRC
** Daemon Management
I wrote this code to help manage daemons. It is usually fine to
operate within a single daemon, but when I need to have more than one
it's nice to be able to manage them as inferior processes.
#+BEGIN_SRC emacs-lisp
(cl-defun make-daemon-frame (socket-name &rest args)
  "Make a new emacs frame for the daemon with the given socket name."
  (apply 'start-process
         (concat socket-name "-frame")
         nil
         "emacsclient" "--create-frame" (concat "--socket-name=" socket-name)
         args))

(cl-defun make-daemon (socket-name &key (create-buffer t) before after (theme 'doom-nord-light))
  "Make a new emacs daemon with the given socket name."
  (message "Loading inferior emacs")
  (let ((daemon-name (concat socket-name "-daemon")))
    (start-process-shell-command
     daemon-name (when create-buffer daemon-name)
     (concat before
             "emacs --daemon=" socket-name
             ;; "--execute \"(load-theme '"
             ;; (symbol-name theme)
             ;; " t)\""
             ";"
             after))))
#+END_SRC

I wrote some other ugly but useful functions to spawn daemons within a
given Nix environment.
#+BEGIN_SRC emacs-lisp
(defun nix-daemon ()
  "Start a daemon and frame in the current nix project."
  (interactive)
  (if (nix-current-sandbox)
      (let ((default-directory (nix-current-sandbox))
            (daemon-name (elt (nreverse (split-string (nix-current-sandbox) "/")) 1)))
        (if (get-buffer-process (get-buffer (concat daemon-name "-daemon")))
            (nix-daemon-frame)
          (make-daemon daemon-name
                     ;; :create-buffer nil
                     :theme 'doom-opera
                     :before "nix-shell --command \""
                     :after (concat "emacsclient --create-frame "
                                    (concat "--socket-name=" daemon-name)
                                    "\""))))
    (error "No nix environment was found")))

(defun nix-daemon-frame ()
  "Start a daemon and frame in the current nix project."
  (interactive)
  (if (nix-current-sandbox)
      (let ((default-directory (nix-current-sandbox))
            (daemon-name (elt (nreverse (split-string (nix-current-sandbox) "/")) 1)))
        (unless (get-buffer-process (get-buffer (concat daemon-name "-daemon")))
          (error "The daemon is not active"))
        (start-process-shell-command
         (concat daemon-name "-frame") nil
         (concat "nix-shell --command "
                 (concat "\"emacsclient --create-frame --socket-name=" daemon-name "\""))))
    (error "No nix environment was found")))
#+END_SRC
* Colors, Themes, Fonts, and other aesthetic settings
Style is very important to me. If I'm going to be working in this text
editor as often as I am, I want it to look good.
** Doom Themes
Doom Emacs looks good. I want those themes.
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  ;; flash mode line when emacs bell rings
  (doom-themes-visual-bell-config))
#+END_SRC
** Poet Theme
I also use the poet theme, but I install it through the built-in
package manager due to a bug.
** Theme
The theme loaded depends upon time of day.
#+BEGIN_SRC emacs-lisp
(unless (display-graphic-p)
  (mapcar #'disable-theme custom-enabled-themes))

(use-package theme-changer
:after doom-themes
:config
(setq calendar-location-name "Rochester, NY")
(setq calendar-latitude 43.16103)
(setq calendar-longitude -77.6109219)
(change-theme 'doom-one-light 'doom-one))
#+END_SRC
* Text, tab and indent related
I use 4 spaces by default.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              indent-tabs-mode nil)
#+END_SRC
* Moving around, buffers, windows and splits
** Winner Mode
Winner mode lets me switch between window configurations with C-c left and right.
#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC
** Projectile
Projectile is a powerful package which facilitates navigation within a
project.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :delight "P"
  :after general
  :config
  (general-define-key
   :states 'normal
   :keymaps 'override
 "C-p" 'helm-projectile-find-file)
  (projectile-mode +1))

;; use helm for projectile
(use-package helm-projectile
  :config
  (helm-projectile-on))
#+END_SRC
** FZF
As powerful as Projectile and Helm are, FZF still takes the cake on
speed of recursive search.
#+BEGIN_SRC emacs-lisp
(use-package fzf)
#+END_SRC
** File navigation
I prefer to always follow symbolic links under version control.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC
This is a function and keybinding for toggling between 2
buffers. Quite faster than =,-b\r=. From [[https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/][here]].
#+BEGIN_SRC emacs-lisp
(defun er-switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(general-define-key :states 'normal :keymaps 'override
                    "<tab>" 'er-switch-to-previous-buffer)
#+END_SRC
* Programming tools and settings
** Autocompletion
I, like many others, use Company.
#+BEGIN_SRC emacs-lisp
(use-package company
  :delight
  :config
  (add-to-list 'company-frontends 'company-tng-frontend) ; test this vs evil collection
  (add-to-list 'completion-styles 'initials t)
  ;;(add-to-list 'completion-styles 'substring t)
  (define-key company-active-map (kbd "M-.") 'company-show-location)
  (define-key company-active-map (kbd "\C-d") 'company-show-doc-buffer)
  ;;(setq company-dabbrev-downcase 0)
  (setq company-minimum-prefix-length 2)
  (setq company-idle-delay 0)
  (add-hook 'sly-mode-hook (lambda () (progn (setq company-idle-delay 0.5)
                                             (setq company-minimum-prefix-length 3))))
  (global-company-mode nil))
#+END_SRC
** Linting
I also, like many others, use Flycheck.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (setq flycheck-global-modes '(not c-mode c++-mode)))
#+END_SRC
** Git
I also also, like many others, use Magit, a very nice Git interface.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
And Evil-friendly keybindings
#+BEGIN_SRC emacs-lisp
(use-package evil-magit)
#+END_SRC
And a leader shortcut
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal
  "m" 'magit)
#+END_SRC
** Language client features
The language server protocol can provide IDE feature backends for many languages.
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
  :config
  (setq lsp-prefer-flymake nil))

(use-package lsp-ui :commands lsp-ui-mode)
(use-package company-lsp :commands company-lsp)

(add-hook 'lsp-mode-hook 'lsp-ui-mode)
#+END_SRC
** Compilation
I wrote this function to run ~make~ on a recursive upward
search. Inspired by [[https://emacs.stackexchange.com/questions/7475/recursively-go-up-to-find-makefile-and-compile][this]].
#+BEGIN_SRC emacs-lisp
(cl-defun compile-rec (&key (filename "Makefile") (command "make -k"))
  "Traveling up the path, find a Makefile and `compile'."
  (interactive)
  (let ((makefile-dir (locate-dominating-file default-directory filename)))
    (when makefile-dir
      (with-temp-buffer
        (cd makefile-dir)
        (compile command)))))
#+END_SRC
** COMMENT Polymode
This is a very cool package that provides support for multiple major
modes in the same buffer. Sadly I had frequent crashes while using it,
so I will leave it commented out.
#+BEGIN_SRC emacs-lisp
(use-package polymode)
(use-package poly-org)
#+END_SRC
* Language specific tools and settings
** Lisps
*** Lispy/ville
~lispy~ is my S-expr editing tool of choice. It integrates with Evil
through ~lispyville~.
minor mode.
#+BEGIN_SRC emacs-lisp
(use-package lispyville
  :delight
  :hook ((emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode) . lispyville-mode)
  :config
   (lispyville-set-key-theme
    '(operators
      ;; atom-motions
      prettify
      wrap
      slurp-cp
      barf-cp
      c-w
      (escape insert)
      (additional-movement normal visual motion))))
#+END_SRC
*** Rainbow delimiters
Each depth layer of delimiter is given a different color.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :delight)
#+END_SRC
** Emacs lisp
*** Keybindings
#+BEGIN_SRC emacs-lisp
(eval-key-def 'normal emacs-lisp-mode-map
  "b" 'eval-buffer
  "f" 'eval-defun)
(eval-key-def 'visual emacs-lisp-mode-map
  "r" 'eval-region)
#+END_SRC
** Common Lisp
*** Sly
Sly is a Common Lisp IDE for Emacs and a featureful fork of SLIME.
#+BEGIN_SRC emacs-lisp
(use-package sly
  :quelpa (:stable t)
  :after evil
  :config

  ;; make functions for using specific lisp implementations.
  (defmacro define-sly-lisp (name command)
    `(defun ,name ()  (interactive)  (sly ,command)))

  (defmacro define-sly-lisp-defun (name fn)
    `(defun ,name ()  (interactive)  (sly (funcall ,fn))))

  ;;(define-sly-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
  (define-sly-lisp sbcl "sbcl")
  (define-sly-lisp ecl "ecl --load /home/adrian/quicklisp/setup.lisp")
  (define-sly-lisp ccl "ccl")
  (define-sly-lisp clisp "clisp")

  (setq inferior-lisp-program "sbcl")
  ;; Open sly debug buffers in emacs state, rather than evil state.
  (add-to-list 'evil-emacs-state-modes 'sly-db-mode))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal sly-mode-map
  "z" 'sly-switch-to-output-buffer
  "c" 'sly-compile-file
  "l" 'sly-load-file)

(start-key-def 'normal sly-mode-map
  "s" 'sly
  "c" 'sly-connect)

(eval-key-def 'normal sly-mode-map
  "b" 'sly-eval-buffer
  "f" 'sly-eval-defun)
(eval-key-def 'visual 'sly-mode-map
  "r" 'sly-eval-region)
#+END_SRC
** Scheme
*** Geiser
It's like SLIME for Scheme. Kinda.
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :config
  (setq geiser-active-implementations '(racket))
  ;; geiser keybindings
  (leader-key-def 'normal geiser-mode-map
    "z" 'geiser-mode-switch-to-repl
    "c" 'geiser-compile-file
    "l" 'geiser-load-file)
  
  (start-key-def 'normal geiser-mode-map
    "s" 'geiser
    "c" 'geiser-connect)
  
  (eval-key-def 'normal geiser-mode-map
    "b" 'geiser-eval-buffer
    "f" 'geiser-eval-definition)
  (eval-key-def 'visual 'geiser-mode-map
    "r" 'geiser-eval-region)
  (general-define-key
   :states 'normal
   :keymaps 'geiser-repl-mode-map
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC
** Shen
An intriguing and small language that runs on Common Lisp and other
things.
#+BEGIN_SRC emacs-lisp
(use-package shen-mode)

(leader-key-def 'normal shen-mode-map
  "z" 'switch-to-shen
  "c" 'shen-compile-file
  "l" 'shen-load-file)

(start-key-def 'normal shen-mode-map
  "s" 'run-shen)

(eval-key-def 'normal shen-mode-map
  "b" 'shen-eval-buffer
  "f" 'shen-eval-defun)

(eval-key-def 'visual 'shen-mode-map
  "r" 'shen-eval-region)
#+END_SRC
** Clojure
A popular lisp? Blasphemy.
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC
*** Cider
It's like SLIME for Clojure! Kinda.
#+BEGIN_SRC emacs-lisp
(use-package cider
  :config
  (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
  (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion))

;; some visual flare
(use-package spinner :quelpa (:stable t))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal clojure-mode-map
  "s" 'cider-jack-in
  "z" 'cider-switch-to-repl-buffer
  "a" 'cider-close-ancillary-buffers)

(eval-key-def 'normal clojure-mode-map
  "b" 'cider-eval-buffer
  "f" 'cider-eval-defun-at-point)
#+END_SRC
** C/C++/CPP/Cpp/Sepples
*** Query
A language server back end for C/++
#+BEGIN_SRC emacs-lisp
(use-package cquery
  :after projectile
  :init
  (add-hook 'c-mode-hook #'cquery//enable)
  (add-hook 'c++-mode-hook #'cquery//enable)
  :config
  (defun cquery//enable ()
    (condition-case nil
        (lsp)
      (user-error nil)))
  (setq cquery-executable "cquery")
  (setq cquery-extra-init-params '(:cacheFormat "msgpack"))
  (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".cquery")
                projectile-project-root-files-top-down-recurring)))
#+END_SRC
*** Font lock
Font lock for modern C++
#+BEGIN_SRC emacs-lisp
(use-package modern-cpp-font-lock
  :config
  (modern-c++-font-lock-global-mode t))
#+END_SRC
*** Linting
Enable Flycheck
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'flycheck-mode)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal c-mode-base-map
  "s" 'ff-find-other-file
  "c" 'compile-rec
  "r" '(lambda () (interactive) (compile-rec :command "make run")))
#+END_SRC
*** Style
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4
              c-default-style "linux")
#+END_SRC
** Julia
#+BEGIN_SRC emacs-lisp
(use-package julia-repl
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :config
  ;; allows capf and dabbrev backends while using haskell
  (add-hook 'haskell-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   (append '((company-capf company-dabbrev-code))
                           company-backends)))))
#+END_SRC
** Elm
#+BEGIN_SRC emacs-lisp
(use-package flycheck-elm
  :config
  (add-hook 'flycheck-mode-hook 'flycheck-elm-setup))
  
(use-package elm-mode)
#+END_SRC
** Org
Organize your life.
#+BEGIN_SRC emacs-lisp
(use-package org
  ;; :hook (org-mode ((lambda nil (load-theme-buffer-local 'tsdh-light (current-buffer)))))
  :config
  (setq header-line-format " ")
  ;;(add-hook 'org-mode-hook '(load-theme-buffer-local 'tsdh-light (current-buffer)))
  ;; (lambda () (progn
  ;;              (setq left-margin-width 2)
  ;;              (setq right-margin-width 2)
  ;;              (set-window-buffer nil (current-buffer))))
  ;;(setq line-spacing 0.1)
  (setq org-startup-indented t
        ;;org-bullets-bullet-list '(" ") ;; no bullets, needs org-bullets package
        ;;org-ellipsis "  " ;; folding symbol
        org-pretty-entities t
        org-hide-emphasis-markers t
        ;; show actually italicized text instead of /italicized text/
        ;;;org-agenda-block-separator ""
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t))
#+END_SRC
*** TIC
Create a table of contents without exporting.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :config
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC
** Nix
My OS.
*** Sandbox
Features for dealing with nix-shell in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package nix-sandbox)
#+END_SRC
*** Language support
For the Nix configuration language.
#+BEGIN_SRC emacs-lisp
(use-package company-nixos-options
  :hook (nix-mode-hook . (lambda () (add-to-list 'company-backends 'company-nixos-options))))

(use-package nix-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
  (add-hook 'nix-mode-hook
            (lambda ()
              (setq tab-always-indent nil)
              (setq indent-tabs-mode t))))

#+END_SRC
** Bash
Enter mode for bash on .profile, .bash_aliases, and .inputrc
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '(".profile\\'" . shell-script-mode))
(add-to-list 'auto-mode-alist '(".bash_aliases\\'" . shell-script-mode))
(add-to-list 'auto-mode-alist '(".inputrc\\'" . shell-script-mode))
#+END_SRC
* Excessive BS
Ok, now we've gone a bit too far.
** Spotify
Control spotify running on any device from Emacs.
#+BEGIN_SRC emacs-lisp
(use-package spot4e :load-path "~/code/elisp/spot4e"
  :after general
  :requires helm url json
  :config
  (setq spot4e-refresh-token "AQCOzkgs6cLWmIWZ-ucPLPwMoEOC6HCRfeqhs7DIRMVmmCeG6g5hi7EGR7Dvms5kZf925jH0UzhhQ8xYdiCPLt3Nw-lW4A8_eDlN1rKrr9FEAHv4MhaasQn6-ai9wiC12Ex4XA")
  (run-with-timer 0 (* 60 59) 'spot4e-refresh)
  (general-create-definer spotify-key-def
    :prefix (concat alt-leader " s"))
  (spotify-key-def 'normal
                   "b" 'spot4e-helm-search-user-tracks
                   "r" 'spot4e-helm-search-recommendations-track
                   "s" 'spot4e-player-pause
                   "p" 'spot4e-player-play
                   "n" 'spot4e-player-next
                   "N" 'spot4e-player-previous))
#+END_SRC
** Emacs window manager
Yep. No, I don't currently use it.
#+BEGIN_SRC emacs-lisp
(use-package exwm
  :config
  (fringe-mode 1)
  (require 'exwm-config)
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (not exwm-instance-name)
                        (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
  (setq exwm-input-global-keys
        `(
          ;; Bind "s-r" to exit char-mode and fullscreen mode.
          ([?\s-r] . exwm-reset)
          ;; Bind "s-c" to enter char mode
          ([?\s-c] . exwm-input-release-keyboard)
          ;; Bind "s-w" to switch workspace interactively.
          ([?\s-w] . exwm-workspace-switch)
          ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))
          ;; Bind "s- " to launch applications
          ([?\s- ] . (lambda (command)
		               (interactive (list (read-shell-command "$ ")))
		               (start-process-shell-command command nil command)))
          ;; Bind "s-<f2>" to "slock", a simple X display locker.
          ;; ([s-f2] . (lambda ()
		  ;;             (interactive)
		  ;;             (start-process "" nil "/usr/bin/slock")))
          ))
  ;; logout function
  (defun exwm-logout ()
    (interactive)
    (recentf-save-list)
    (save-some-buffers)
    (start-process-shell-command "logout" nil "lxsession-logout"))
  ;; start in char mode by default
  ;; (setq exwm-manage-configurations '((t char-mode t)))
  ;; sys tray with network
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
  (shell-command "nm-applet")
  ;; set prefix keys
  (setq my-exwm-prefix-keys (list ?\s-f ?\s-h ?\s-j ?\s-k ?\s-l ?\s-H ?\s-J ?\s-K ?\s-L ?\: ?\,))
  (setq exwm-input-prefix-keys (nconc exwm-input-prefix-keys my-exwm-prefix-keys)))
#+END_SRC
* Files and backups
Don't make backups.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC
Save cursor position in a file between sessions.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
* Helper functions
Various small functions.
#+BEGIN_SRC emacs-lisp
(defun reload-init-file ()
  "Load all elisp from 'user-init-file'."
  (interactive)
  (load-file user-init-file))

(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))
#+END_SRC
