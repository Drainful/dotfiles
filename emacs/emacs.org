#+TITLE: Emacs Configuration

Emacs is a truly fantastic piece of software. Part REPL, part
with Emacs, slowly carving it into the perfect interface for allmost
everything my computer has to offer; and yet I feel as if I have only
just begun to scratch the surface. With that said, the remainder of
this file constitutes my emacs configuration. Please enjoy!

* Table of contents                                                     :TOC:
- [[#startup][Startup]]
  - [[#lexical-scope][Lexical Scope]]
  - [[#garbage-collector-threshold][Garbage Collector Threshold]]
  - [[#filename-handlers][Filename Handlers]]
  - [[#load-helper-functions][Load helper functions]]
  - [[#load-secrets][Load secrets]]
- [[#packages][Packages]]
  - [[#package-initialization][Package Initialization]]
  - [[#use-package][Use-Package]]
  - [[#quelpa][Quelpa]]
- [[#evil][Evil]]
  - [[#evil-collection][Evil collection]]
  - [[#evil-easymotion][Evil easymotion]]
  - [[#evil-surround][Evil surround]]
  - [[#the-creation-of-text-objects][The creation of text objects]]
- [[#keybindings-and-commands][Keybindings and commands]]
  - [[#generalel][General.el]]
  - [[#commands][Commands]]
  - [[#normal-mode][Normal Mode]]
  - [[#visual-mode][Visual Mode]]
  - [[#leader][Leader]]
- [[#user-interface-preferences][User interface preferences]]
  - [[#startup-screen][Startup screen]]
  - [[#mode-line][Mode line]]
  - [[#helm][Helm]]
  - [[#hideshow][Hideshow]]
  - [[#unnecessary-ui-elements][Unnecessary UI elements]]
  - [[#line-and-column-numbers][Line and Column numbers]]
  - [[#start-frame-maximized][Start frame maximized]]
  - [[#confirmation][Confirmation]]
  - [[#clipboard][Clipboard]]
  - [[#delimiters][Delimiters]]
  - [[#which-key][Which-key]]
- [[#shell][Shell]]
  - [[#eshell][Eshell]]
  - [[#comint-mode][Comint Mode]]
  - [[#shell-1][Shell]]
  - [[#multi-term][Multi-Term]]
- [[#tramp][Tramp]]
- [[#emacs-clientserver-settings][Emacs client/server settings]]
  - [[#daemon-management][Daemon Management]]
- [[#colors-themes-fonts-and-other-aesthetic-settings][Colors, Themes, Fonts, and other aesthetic settings]]
  - [[#doom-themes][Doom Themes]]
  - [[#poet-theme][Poet Theme]]
  - [[#theme][Theme]]
- [[#text-tab-and-indent-related][Text, tab and indent related]]
- [[#moving-around-buffers-windows-and-splits][Moving around, buffers, windows and splits]]
  - [[#winner-mode][Winner Mode]]
  - [[#projectile][Projectile]]
  - [[#fzf][FZF]]
  - [[#file-navigation][File navigation]]
- [[#programming-tools-and-settings][Programming tools and settings]]
  - [[#autocompletion][Autocompletion]]
  - [[#linting][Linting]]
  - [[#git][Git]]
  - [[#snippets][Snippets]]
  - [[#language-client-features][Language client features]]
  - [[#compilation][Compilation]]
  - [[#documentation][Documentation]]
- [[#language-specific-tools-and-settings][Language specific tools and settings]]
  - [[#lisps][Lisps]]
  - [[#emacs-lisp][Emacs lisp]]
  - [[#common-lisp][Common Lisp]]
  - [[#scheme][Scheme]]
  - [[#shen][Shen]]
  - [[#clojure][Clojure]]
  - [[#cccppcppsepples][C/C++/CPP/Cpp/Sepples]]
  - [[#julia][Julia]]
  - [[#haskell][Haskell]]
  - [[#elm][Elm]]
  - [[#org][Org]]
  - [[#nix][Nix]]
  - [[#bash][Bash]]
- [[#excessive-bs][Excessive BS]]
  - [[#spotify][Spotify]]
  - [[#emacs-window-manager][Emacs window manager]]
- [[#files-and-backups][Files and backups]]
- [[#after-startup][After startup]]
- [[#helper-functions][Helper functions]]

* Startup
** Lexical Scope
My first move is to enable lexical scope. This not only improves
execution time, but also allows lexical techniques such as closure to
be used. This declaration is contained within a comment because
lexical scope was only introduced to Emacs in version 24.1
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-
#+END_SRC

** Garbage Collector Threshold
In search of faster startup times, I discovered a technique that
involves increasing the garbage collection threshold during starup. I
got this idea from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]]. Look there for more advice for
improving startup time.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6)

(add-hook 'emacs-startup-hook
  (setq gc-cons-threshold 16777216
        gc-cons-percentage 0.1))
#+END_SRC

** Filename Handlers
Similarly to the garbage collector, startup time can be improved by
disabling the ~file-name-handler-alist~, as it will not be needed during
startup. This trick also comes from [[https://github.com/hlissner/doom-emacs/wiki/FAQ][Doom Emacs]].
#+BEGIN_SRC emacs-lisp
(defvar temp-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

(add-hook 'emacs-startup-hook
  (setq file-name-handler-alist temp-file-name-handler-alist))
#+END_SRC

** Load helper functions
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<helper-functions>>
#+END_SRC
** Load secrets
Secrets are stored in ~~/.emacs.d/.secrets.el~.
#+BEGIN_SRC emacs-lisp
  (let ((secret.el (expand-file-name ".secrets.el" user-emacs-directory)))
    (when (file-exists-p secret.el)
      (load secret.el)))
#+END_SRC
* Packages
** Package Initialization
Before I can install packages I must first initialize package sources
and installation tools. Here I source ~elpa~ and ~melpa~.
#+BEGIN_SRC emacs-lisp

(require 'package)
(let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                    (not (gnutls-available-p))))
       (proto (if no-ssl "http" "https")))
  (when no-ssl (warn "\
Your version of Emacs does not support SSL connections,
which is unsafe because it allows man-in-the-middle attacks.
There are two things you can do about this warning:
1. Install an Emacs version that does support SSL and be safe.
2. Remove this warning from your init file so you won't see it again."))
  ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
  (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
  (add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives (cons "gnu" (concat proto "://elpa.gnu.org/packages/")))))

(package-initialize)
#+END_SRC

** Use-Package
I use the ever-popular package-using facility ~use-package~. It is
installed automatically by a nix expression in my dotfiles. This line
causes ~use-package~ expressions to be automatically downloaded.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

** Quelpa
~quelpa~ is a package installation facility that allows packages to be
installed from arbitrary sources. This is convenient for getting
bleeding edge versions of packages which have yet to reach ~melpa~.
#+BEGIN_SRC emacs-lisp
(use-package quelpa)

(setq quelpa-upgrade-p nil)

(use-package quelpa-use-package)

(quelpa-use-package-activate-advice)
#+END_SRC

** COMMENT Automatic Upgrades
This code enables automatic package upgrades.
#+BEGIN_SRC emacs-lisp
(setq quelpa-upgrade-p t)

(package-refresh-contents)

(use-package auto-package-update
  :config
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-hide-results t)
  (auto-package-update-maybe))
#+END_SRC
* Evil
These are settings for the emulation of Vim in Emacs. I would not be
using emacs today if it were not for ~evil-mode~. I really love Vim.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  ;; highlight all search results
  (setq evil-search-module 'evil-search)
  ;; settings for evil-collection integration
  (setq evil-want-keybinding nil)
  (setq evil-want-integration t)
  :config
  (evil-mode 1)
  ;; The undo tree sometimes deletes undo data, I prefer to just disable it.
  (global-undo-tree-mode -1))
#+END_SRC
** Evil collection
This provides ~evil~ friendly keybindings for a variety of modes.
#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :init
  (setq evil-want-keybinding nil)
  :after evil
  :config
  (evil-collection-minibuffer-setup)
  (evil-collection-init))
#+END_SRC


** Evil easymotion
This package helps with the issue of not knowing how many times to
repeat an ~evil~ motion by providing a tag at the location of
each possible motion result.
#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion
  :config
  (evilem-default-keybindings "SPC"))
#+END_SRC
** Evil surround
This solves the tricky issue of surrounding a block of text with
delimiters when they automatically close.
#+BEGIN_SRC emacs-lisp
(use-package "evil-surround"
  :config
  (global-evil-surround-mode 1))
#+END_SRC
** COMMENT Evil snipe
At one point I used ~evil-snipe~, a tool for jumping to pairs of characters.
#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :after evil-easymotion
  :config
  (evilem-define (kbd "SPC s") 'evil-snipe-s))
#+END_SRC
** The creation of text objects
This macro was copied from [[https://stackoverflow.com/a/22418983/4921402][this]] Stackoverflow thread, and facilitates
the creation of ~evil~ text objects.
#+BEGIN_SRC emacs-lisp
(defmacro define-and-bind-quoted-text-object (name key start-regex end-regex)
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-a-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count t))
       (define-key evil-inner-text-objects-map ,key #',inner-name)
       (define-key evil-outer-text-objects-map ,key #',outer-name))))

(defalias 'textobj 'define-and-bind-quoted-text-object)
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
(textobj "pipe" "|" "|" "|")
(textobj "slash" "/" "/" "/")
#+END_SRC
* Keybindings and commands
** General.el
I mainly use the the package ~general~ to define keybindings and
commands. It integrates well with ~evil~.
#+BEGIN_SRC emacs-lisp
(use-package general)
(general-evil-setup)
#+END_SRC
** Commands
I don't have too much use for ~evil~ commands, but early on I created a
couple.
#+BEGIN_SRC emacs-lisp
(evil-ex-define-cmd "Src" 'reload-init-file)
(evil-ex-define-cmd "Restart" 'restart-emacs)
#+END_SRC
** Normal Mode
These are normal mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-nmap
  "C-h" 'evil-window-left
  "C-j" 'evil-window-down
  "C-k" 'evil-window-up
  "C-l" 'evil-window-right
  "s-h" 'evil-window-left
  "s-j" 'evil-window-down
  "s-k" 'evil-window-up
  "s-l" 'evil-window-right
  "s-H" 'evil-window-move-far-left
  "s-J" 'evil-window-move-very-bottom
  "s-K" 'evil-window-move-very-top
  "s-L" 'evil-window-move-far-right
  "C--" 'helm-projectile-grep
  ;; Move a line of text using ALT+[jk]
  "M-j" (kbd ":move + RET")
  "M-k" (kbd ":move .-2 RET")
  "M-j" 'move-line-down
  "M-k" 'move-line-up)
#+END_SRC
** Visual Mode
And these are visual mode mappings not specific to any major mode.
#+BEGIN_SRC emacs-lisp
(general-vmap
  ;; Move a visual block of text using ALT+[jk]
  "M-k" (kbd ":move '< -2 RET `> my `< mz gv`yo`z"))
#+END_SRC
** Leader
The leader key is an old technique common among Vim users. A number of
sequential key commands are hidden behind a single key. For those who
are familiar with ~hydra~, this is a similar concept.
*** Definitions
First I define the leader keys,
#+BEGIN_SRC emacs-lisp
(defconst leader-key ",")
(defconst alt-leader "SPC")

(general-create-definer leader-key-def
  :prefix leader-key)

(general-create-definer alt-leader-key-def
  :prefix alt-leader-key)
#+END_SRC

then some helper functions to create functions to create subleader
keybindings through ~general-create-definer~. Key-based replacements are
also generated for [[#which-key][ ~which-key~ ]].
#+BEGIN_SRC emacs-lisp
(cl-defun leader-prefix (str &optional (prefix leader-key))
  "Append a leader key to the given string"
  (concat prefix " " str))

(cl-defmacro define--subleader (key name general-definer-name &key (leader leader-key))
  "Both create a general definer, and a which-key replacement for the given subleader."
  `(progn
     (which-key-add-key-based-replacements
       (leader-prefix ,key ,leader) ,name)
     (general-create-definer ,general-definer-name
       :prefix (leader-prefix ,key ,leader))))

;; the format for the input of this function is inspired by general's
;; easy to use functions.
(cl-defmacro define-subleader (&rest args &key (leader leader-key) &allow-other-keys)
  "Both create a general definer, and a which-key replacement for
the given subleader. Accepts arguments in threes with no
delimiter."
  `(progn ,@(mapcar '(lambda (elt)
                       `(define--subleader ,@elt :leader ,leader))
                    (seq-partition (remove-keyword-args args) 3))))
#+END_SRC
Usage:
#+BEGIN_SRC emacs-lisp
(define-subleader
  "e" "eval" eval-key-def
  "s" "start" start-key-def
  "x" "xpand" xpand-key-def)
#+END_SRC
*** Normal Mode
#+BEGIN_SRC emacs-lisp
  (leader-key-def 'normal
    "q" 'kill-this-buffer              ; ",q" to kill buffer not window.
    "w" 'evil-delete-buffer              ; ",Q" to kill buffer and window. equivalent of :bd<cr>.
    "b" 'helm-mini                     ; ",b" to switch buffers.
    "f" 'helm-find-files               ; ",f" to find file (replace :e)
    "p" '(lambda () (interactive)
           ;; ",p" to fuzzy find directory from home directory
           (fzf/start "~/" "find ${1:-.} -path '*/\\.*' -prune \ -o -type d -print 2> /dev/null")) 
    "o" 'occur 
    "i" 'imenu
    "RET" (kbd ":noh"))
#+END_SRC
*** Visual Mode
#+BEGIN_SRC emacs-lisp
(leader-key-def 'visual
  "c" 'comment-or-uncomment-region)
#+END_SRC
* User interface preferences
These are settings related to the basic user interface of Emacs.
** Startup screen
I disable the default startup screen and splash message.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil)
#+END_SRC
*** Scratch buffer
Set the initial mode in the scratch buffer to emacs.
#+BEGIN_SRC emacs-lisp
(setq initial-major-mode 'emacs-lisp-mode)(setq initial-major-mode 'emacs-lisp-mode)
#+END_SRC
** Mode line
The mode line is the line at the bottom of each buffer. It contains
useful information.
*** Delight
Delight is a package which is used to hide unnecessary mode-line
blurbs.
#+BEGIN_SRC emacs-lisp
(use-package delight :quelpa (:stable t)
  :config
  (delight 'eldoc-mode nil "eldoc"))
#+END_SRC
** Helm
~helm~ is a framework for incremental narrowing searching interfaces
which integrates well across Emacs.
#+BEGIN_SRC emacs-lisp
(use-package helm
  :delight
  :bind (("M-x" . helm-M-x))
  :config (helm-mode t))
#+END_SRC
** Hideshow
~hideshow~ mode provides vim-like folds (but not as good).
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'hs-minor-mode)
(delight 'hs-minor-mode nil "hideshow")
#+END_SRC
** Unnecessary UI elements
Emacs comes with such useless features as a tool bar. Turn them off.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
(add-to-list 'default-frame-alist
             '(vertical-scroll-bars . nil))
#+END_SRC
** Line and Column numbers
Display them both on the side of the buffer and in the mode line.
#+BEGIN_SRC emacs-lisp
(global-display-line-numbers-mode 1)
(display-line-numbers-mode 1)

(setq column-number-mode t)
#+END_SRC
** Start frame maximized
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Confirmation
Type =y= or =n=, not =yes= or =no=.
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Clipboard
Enable vim-like clipboard.
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard nil)
#+END_SRC

** Delimiters
*** Electric pair mode
Close delimiters automatically as I write.
#+BEGIN_SRC emacs-lisp
(electric-pair-mode nil)
#+END_SRC
*** Highlight parentheses
Highlight the nearest outer parentheses. Thanks to [[https://stackoverflow.com/questions/34846531/show-parentheses-when-inside-them-emacs][this]] thread.
#+BEGIN_SRC emacs-lisp
  (define-advice show-paren-function (:around (fn) fix)
    "Highlight enclosing parens."
    (cond ((looking-at-p "\\s(") (funcall fn))
          (t (save-excursion
               (ignore-errors (backward-up-list))
               (funcall fn)))))
#+END_SRC

*** Matching parens
Highlight the parentheis whose pair is under the point.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-delay 0)
  (setq show-paren-style 'parenthesis)
#+END_SRC
** Which-key
This plugin shows the available keys after a partially completed
key press. ~which-key~ key replacements are generated [[#leader][here]].
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (which-key-mode t))
#+END_SRC
* Shell
** Eshell
~eshell~ is an Emacs Lisp shell. Very cool.
#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-smart)
#+END_SRC

*** Configuration
And configuration: 
#+BEGIN_SRC emacs-lisp
(setq eshell-where-to-jump 'begin)
(setq eshell-review-quick-commands nil)
(setq eshell-smart-space-goes-to-end t)
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key [f2] 'eshell)
  ;; Let me use C-j/k
  (add-hook 'eshell-mode-hook ; needs to be in a hook because eshell is dumb
            (lambda ()
              (general-define-key :states 'normal :keymaps 'eshell-mode-map
                                  "C-j" 'evil-window-down
                                  "C-k" 'evil-window-up)))
#+END_SRC

*** Helper Function
Function for making a new Eshell instance. From [[https://www.emacswiki.org/emacs/EshellMultipleEshellBuffers][this]] thread.
#+BEGIN_SRC emacs-lisp
(defun eshell-new()
  "Open a new instance of eshell."
  (interactive)
  (eshell 'N))
#+END_SRC

*** COMMENT Beginning of line behavior
~eshell~ doesn't play with ~evil~ regarding the beginning of line
behavior. This is some scratch code I wrote which attempts and fails
to fix the problem.
#+BEGIN_SRC emacs-lisp
(setq eshell-prompt-regexp (regexp-quote "^\b$")
      eshell-prompt-function
      (lambda nil ""))

(setq old-eshell-prompt-function (lambda nil (eshell-prompt-function)))
(setq old-eshell-prompt-function (symbol-value 'eshell-prompt-function))
(setq eshell-prompt-function
      (lambda nil
        (restrict-bol (old-eshell-prompt-function))))
(setq eshell-prompt-function
      (lambda nil
        (restrict-bol (concat
                   (eshell/pwd)
                   " $ "))))
#+END_SRC
** Comint Mode
~comint mode~ is a generalized mode for repl-like interfaces.
#+BEGIN_SRC emacs-lisp
(setq comint-prompt-read-only t ; Don't let me delete the comint prompt duh
      comint-move-point-for-output nil ; reduce frequent redisplays
      comint-scroll-show-maximum-output nil)
#+END_SRC
** Shell
I prefer ~shell-mode~ to any newer terminal emulator because
~comint-mode~, the mode which ~shell-mode~ is based on, plays well with
~evil~.
#+BEGIN_SRC emacs-lisp
  (global-set-key [f1] 'shell)
  (general-define-key :states 'normal :keymaps 'shell-mode-map
     "C-j" 'evil-window-down
     "C-k" 'evil-window-up)
#+END_SRC
** Multi-Term
If for some reason I need ~ansi-term~ instead of ~shell-mode~, and for some
reason I need multiple, I have this plugin.
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :config
  ;; (global-set-key [f1] 'multi-term)
  ;; access shift arrow keys
  (define-key global-map "\eO2D" (kbd "S-<left>"))
  (define-key global-map "\eO2C" (kbd "S-<right>"))
  ;; term movement
  (general-define-key
   :states 'normal
   :keymaps 'term-mode-map
   "S-<right>" 'multi-term-next
   "S-<left>" 'multi-term-prev
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC
* Tramp
~tramp~ is a truly one of the great gems of Emacs. It allows me to
access remote files as if they were part of my filesystem within
Emacs.
#+BEGIN_SRC emacs-lisp
  (defun connect-to-serenity ()
    (interactive)
    (dired me/serenity-path))
#+END_SRC
* Emacs client/server settings
One of the personal breakthroughs I made when starting with Emacs was
realizing that I didn't have to wait for emacs to start every time I
wanted to edit a file. By running Emacs as a daemon, frames could be
opened instantaneously. Of course at this point I almost never close
my Emacs frame in the first place.
#+BEGIN_SRC emacs-lisp
;; easily restart emacs daemon
(use-package restart-emacs)

;; focus any new frames
(add-to-list 'after-make-frame-functions 'select-frame-set-input-focus)
#+END_SRC
** Daemon Management
I wrote this code to help manage daemons. It is usually fine to
operate within a single daemon, but when I need to have more than one
it's nice to be able to manage them as inferior processes.
#+BEGIN_SRC emacs-lisp
  (cl-defun make-daemon-frame (socket-name &rest args)
    "Make a new emacs frame for the daemon with the given socket name."
    (apply 'start-process
           (concat socket-name "-frame")
           nil
           "emacsclient" "--create-frame" (concat "--socket-name=" socket-name)
           args))

  (cl-defun make-daemon (socket-name &key (create-buffer t) before after (theme 'doom-nord-light))
    "Make a new emacs daemon with the given socket name."
    (message "Loading inferior emacs")
    (let ((daemon-name (concat socket-name "-daemon")))
      (start-process-shell-command
       daemon-name (when create-buffer daemon-name)
       (concat before
               "emacs --daemon=" socket-name
               ;; "--execute \"(load-theme '"
               ;; (symbol-name theme)
               ;; " t)\""
               ";"
               after))))
#+END_SRC

I wrote some other ugly but useful functions to spawn daemons within a
given Nix environment.
#+BEGIN_SRC emacs-lisp
  (cl-defun nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; nix-shell starts daemosn in /run/user/
    (interactive)
    (let ((running? (file-exists-p (concat "/run/user/1000/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun non-nix-daemon-running-p (&optional (socket "server"))
    "Check if a daemon which was NOT started from nix-shell is running
  on the given socket. Default unnamed socket."
    ;; daemons started outside of nix-shell exist in /tmp/
    (interactive)
    (let ((running? (file-exists-p (concat "/tmp/emacs1000/" socket))))
      (when (interactive-p) (message (if running? "yes" "no")))
      running?))

  (cl-defun nix-daemon (&optional (theme 'doom-opera))
    "Start a daemon and frame in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let* ((default-directory (nix-current-sandbox))
               (socket-name (elt (nreverse (split-string (nix-current-sandbox) "/")) 1))
               (daemon-name (concat socket-name "-daemon")))
          (if (nix-daemon-running-p socket-name) 
              (nix-daemon-frame)
            (message "Loading inferior nix emacs")
            (start-process-shell-command
             daemon-name daemon-name
             (concat "nix-shell --command \""
                       "emacs --daemon=" socket-name
                       " --execute \\\"
                         (load-theme '"
                         (symbol-name theme)
                         " t)\\\""
                       "; "
                       "emacsclient --create-frame "
                       (concat "--socket-name=" socket-name)
                     "; "
                     "return"
                     "\""))))
      (error "No nix environment was found")))

  (defun nix-daemon-frame ()
    "Start a frame from the relevant nix Emacs daemon in the current nix project."
    (interactive)
    (if (nix-current-sandbox)
        (let ((default-directory (nix-current-sandbox))
              (socket-name (elt (nreverse (split-string (nix-current-sandbox) "/")) 1)))
          (unless (nix-daemon-running-p socket-name)
            (error "The daemon is not active"))
          (start-process-shell-command
           (concat socket-name "-frame") nil
           (concat "nix-shell --command "
                   (concat "\"emacsclient --create-frame --socket-name=" socket-name "\""))))
      (error "No nix environment was found")))
#+END_SRC
* Colors, Themes, Fonts, and other aesthetic settings
** Doom Themes
Doom Emacs looks good. I want those themes.
#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  ;; flash mode line when emacs bell rings
  (doom-themes-visual-bell-config))
#+END_SRC
** Poet Theme
I also use the ~poet~ theme, but I install it through the built-in
package manager rather than through ~use-package~ due to a bug.
** Theme
The theme loaded depends upon time of day.
#+NAME: themes
#+BEGIN_SRC emacs-lisp
  (unless (display-graphic-p)
      (mapcar #'disable-theme custom-enabled-themes))

  (use-package theme-changer
    :after doom-themes
    :config
    (setq calendar-location-name me/calendar-location-name)
    (setq calendar-latitude me/calendar-latitude)
    (setq calendar-longitude me/calendar-longitude)
    (change-theme 'doom-one-light 'doom-one))
#+END_SRC
* Text, tab and indent related
I use 4 spaces by default.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4
              indent-tabs-mode nil)
#+END_SRC
* Moving around, buffers, windows and splits
** Winner Mode
~winner-mode~ lets me switch between window configurations with C-c left and right.
#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC
** Projectile
~projectile~ is a powerful package which facilitates navigation within a
project.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :delight "P"
  :after general
  :config
  (general-define-key
   :states 'normal
   :keymaps 'override
 "C-p" 'helm-projectile-find-file)
  (projectile-mode +1))

;; use helm for projectile
(use-package helm-projectile
  :config
  (helm-projectile-on))
#+END_SRC
** FZF
As powerful as ~projectile~ and ~helm~ are, ~fzf~ still takes the cake on
speed of recursive search.
#+BEGIN_SRC emacs-lisp
(use-package fzf)
#+END_SRC
** File navigation
I prefer to follow symbolic links under version control.
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC
This is a function and keybinding for toggling between 2
buffers. Faster than ~,-b\r~. From [[https://emacsredux.com/blog/2013/04/28/switch-to-previous-buffer/][here]].
#+BEGIN_SRC emacs-lisp
(defun er-switch-to-previous-buffer ()
  "Switch to previously open buffer.
Repeated invocations toggle between the two most recently open buffers."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(general-define-key :states 'normal :keymaps 'override
                    "<tab>" 'er-switch-to-previous-buffer)
#+END_SRC
* Programming tools and settings
** Autocompletion
I, like many others, use ~company~.
#+BEGIN_SRC emacs-lisp
(use-package company
  :delight
  :config
  (add-to-list 'company-frontends 'company-tng-frontend) ; test this vs evil collection
  (add-to-list 'completion-styles 'initials t)
  ;;(add-to-list 'completion-styles 'substring t)
  (define-key company-active-map (kbd "M-.") 'company-show-location)
  (define-key company-active-map (kbd "\C-d") 'company-show-doc-buffer)
  ;;(setq company-dabbrev-downcase 0)
  (setq company-minimum-prefix-length 2)
  (setq company-idle-delay 0)
  (add-hook 'sly-mode-hook (lambda () (progn (setq company-idle-delay 0.5)
                                             (setq company-minimum-prefix-length 3))))
  (global-company-mode nil))
#+END_SRC
** Linting
I also, like many others, use ~flycheck~.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
  (setq flycheck-global-modes '(not c-mode c++-mode)))
#+END_SRC
** Git
I also also, like many others, use ~magit~, a very nice Git interface.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+END_SRC
With ~evil~ friendly keybindings.
#+BEGIN_SRC emacs-lisp
(use-package evil-magit)
#+END_SRC
and a leader shortcut.
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal
  "m" 'magit)
#+END_SRC
** Snippets
~yasnippet~ allows the creation of snippets to automate repetitive typing.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :config
  (yas-global-mode t)
  ;; (setq yas-snippet-dirs
  ;;       '("~/.dotfiles/emacs/snippets"))
  ;; (general-define-key :keymap 'yas-minor-mode-map
  ;;                     "<tab>" nil
  ;;                     "TAB" nil)
  ;; (general-define-key :states 'insert
  ;;                     :keymap 'yas-minor-mode-map
  ;;                     "<C-return>" #'yas-expand)
  ;; (general-define-key :keymap 'yas-keymap
  ;;                     "<tab>" nil
  ;;                     "TAB" nil
  ;;                     "<backtab>" nil
  ;;                     "<shift tab>" nil) 
  ;; (general-define-key :states 'insert
  ;;                      :keymap 'yas-keymap
  ;;                      "C-n" 'yas-next-field-or-maybe-expand
  ;;                      "C-p" 'yas-prev-field)
  )
#+END_SRC
A large collection of snippets is found in the ~yasnippet-snippets~ package.
#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :quelpa (:stable t))
#+END_SRC
** Language client features
The language server protocol can provide IDE-like features for many
languages. ~lsp-mode~ also serves as a backend for ~company~ and ~flycheck~.
#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :commands lsp
  :config
  (setq lsp-prefer-flymake nil))

(use-package lsp-ui :commands lsp-ui-mode) ; adds flycheck support
(use-package company-lsp :commands company-lsp) ; links with company

(add-hook 'lsp-mode-hook 'lsp-ui-mode)
#+END_SRC
** Compilation
I wrote this function to run ~make~ on a recursive upward
search. Inspired by [[https://emacs.stackexchange.com/questions/7475/recursively-go-up-to-find-makefile-and-compile][this]].
#+BEGIN_SRC emacs-lisp
(cl-defun compile-rec (&key (filename "Makefile") (command "make -k"))
  "Traveling up the path, find a Makefile and `compile'."
  (interactive)
  (let ((makefile-dir (locate-dominating-file default-directory filename)))
    (when makefile-dir
      (with-temp-buffer
        (cd makefile-dir)
        (compile command)))))
#+END_SRC
** Documentation
A keybinding to access documentation.
#+BEGIN_SRC emacs-lisp
  (global-set-key [f3] (lambda () (interactive) (manual-entry (current-word))))
#+END_SRC
** COMMENT Polymode
This is a very cool package that provides support for multiple major
modes in the same buffer. It seems to crash sometimes when editing org
files.
#+BEGIN_SRC emacs-lisp
(use-package polymode)
(use-package poly-org)
#+END_SRC
* Language specific tools and settings
** Lisps
*** Lispy/ville
~lispy~ is my S-expr editing tool of choice. It integrates with ~evil~
through ~lispyville~ minor mode.
#+BEGIN_SRC emacs-lisp
(use-package lispyville
  :delight
  :hook ((emacs-lisp-mode lisp-mode lispy-mode clojure-mode shen-mode) . lispyville-mode)
  :config
   (lispyville-set-key-theme
    '(operators
      ;; atom-motions
      prettify
      wrap
      slurp-cp
      barf-cp
      c-w
      (escape insert)
      (additional-movement normal visual motion))))
#+END_SRC
*** Rainbow delimiters
While ~rainbow-delimeters-mode~ is active each depth of delimiter is given a different color.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :delight)
#+END_SRC
** Emacs lisp
*** Keybindings
#+BEGIN_SRC emacs-lisp
(eval-key-def 'normal emacs-lisp-mode-map
  "b" 'eval-buffer
  "f" 'eval-defun)
(eval-key-def 'visual emacs-lisp-mode-map
  "r" 'eval-region)
#+END_SRC
** Common Lisp
*** Sly
~sly~ is a Common Lisp IDE for Emacs and a featureful fork of ~slime~.
#+BEGIN_SRC emacs-lisp
(use-package sly
  :quelpa (:stable t)
  :after evil
  :config

  ;; make functions for using specific lisp implementations.
  (defmacro define-sly-lisp (name command)
    `(defun ,name ()  (interactive)  (sly ,command)))

  (defmacro define-sly-lisp-defun (name fn)
    `(defun ,name ()  (interactive)  (sly (funcall ,fn))))

  ;;(define-sly-lisp-defun sbcl (lambda () (nix-executable-find (nix-current-sandbox) "sbcl")))
  (define-sly-lisp sbcl "sbcl")
  (define-sly-lisp ecl "ecl --load /home/adrian/quicklisp/setup.lisp")
  (define-sly-lisp ccl "ccl")
  (define-sly-lisp clisp "clisp")

  (setq inferior-lisp-program "sbcl")
  ;; Open sly debug buffers in emacs state, rather than evil state.
  (add-to-list 'evil-emacs-state-modes 'sly-db-mode))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal sly-mode-map
  "z" 'sly-switch-to-output-buffer
  "c" 'sly-compile-file
  "l" 'sly-load-file)

(start-key-def 'normal sly-mode-map
  "s" 'sly
  "c" 'sly-connect)

(eval-key-def 'normal sly-mode-map
  "b" 'sly-eval-buffer
  "f" 'sly-eval-defun)
(eval-key-def 'visual 'sly-mode-map
  "r" 'sly-eval-region)
#+END_SRC
** Scheme
*** Geiser
It's like ~slime~ for Scheme. Kinda.
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :config
  (setq geiser-active-implementations '(racket))
  ;; geiser keybindings
  (leader-key-def 'normal geiser-mode-map
    "z" 'geiser-mode-switch-to-repl
    "c" 'geiser-compile-file
    "l" 'geiser-load-file)
  
  (start-key-def 'normal geiser-mode-map
    "s" 'geiser
    "c" 'geiser-connect)
  
  (eval-key-def 'normal geiser-mode-map
    "b" 'geiser-eval-buffer
    "f" 'geiser-eval-definition)
  (eval-key-def 'visual 'geiser-mode-map
    "r" 'geiser-eval-region)
  (general-define-key
   :states 'normal
   :keymaps 'geiser-repl-mode-map
   ;; was overridden
   "C-j" 'evil-window-down
   "C-k" 'evil-window-up))
#+END_SRC
** Shen
An intriguing and small language that runs on Common Lisp and other
things.
#+BEGIN_SRC emacs-lisp
(use-package shen-mode)

(leader-key-def 'normal shen-mode-map
  "z" 'switch-to-shen
  "c" 'shen-compile-file
  "l" 'shen-load-file)

(start-key-def 'normal shen-mode-map
  "s" 'run-shen)

(eval-key-def 'normal shen-mode-map
  "b" 'shen-eval-buffer
  "f" 'shen-eval-defun)

(eval-key-def 'visual 'shen-mode-map
  "r" 'shen-eval-region)
#+END_SRC
** Clojure
A popular lisp on the JVM.
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode)
#+END_SRC
*** Cider
It's like ~slime~ for Clojure! Kinda.
#+BEGIN_SRC emacs-lisp
(use-package cider
  :config
  (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
  (add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion))

;; some visual flare
(use-package spinner :quelpa (:stable t))
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal clojure-mode-map
  "s" 'cider-jack-in
  "z" 'cider-switch-to-repl-buffer
  "a" 'cider-close-ancillary-buffers)

(eval-key-def 'normal clojure-mode-map
  "b" 'cider-eval-buffer
  "f" 'cider-eval-defun-at-point)
#+END_SRC
** C/C++/CPP/Cpp/Sepples
*** CQuery
A language server back end for C/++
#+BEGIN_SRC emacs-lisp
(use-package cquery
  :after projectile
  :init
  (add-hook 'c-mode-hook #'cquery//enable)
  (add-hook 'c++-mode-hook #'cquery//enable)
  :config
  (defun cquery//enable ()
    (condition-case nil
        (lsp)
      (user-error nil)))
  (setq cquery-executable "cquery")
  (setq cquery-extra-init-params '(:cacheFormat "msgpack"))
  (setq projectile-project-root-files-top-down-recurring
        (append '("compile_commands.json"
                  ".cquery")
                projectile-project-root-files-top-down-recurring)))
#+END_SRC
*** Font lock
Corrects font lock for modern C++.
#+BEGIN_SRC emacs-lisp
(use-package modern-cpp-font-lock
  :config
  (modern-c++-font-lock-global-mode t))
#+END_SRC
*** Linting
Enable ~flycheck~
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'flycheck-mode)
#+END_SRC
*** Keybindings
#+BEGIN_SRC emacs-lisp
(leader-key-def 'normal c-mode-base-map
  "s" 'ff-find-other-file
  "c" 'compile-rec
  "r" '(lambda () (interactive) (compile-rec :command "make run")))
#+END_SRC
*** Style
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4
              c-default-style "linux")
#+END_SRC
** Julia
#+BEGIN_SRC emacs-lisp
(use-package julia-repl
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :config
  ;; allows capf and dabbrev backends while using haskell
  (add-hook 'haskell-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends)
                   (append '((company-capf company-dabbrev-code))
                           company-backends)))))
#+END_SRC
** Elm
#+BEGIN_SRC emacs-lisp
(use-package flycheck-elm
  :config
  (add-hook 'flycheck-mode-hook 'flycheck-elm-setup))
  
(use-package elm-mode)
#+END_SRC
** Org
~org-mode~ is a markup mode with many features, including creating
literate source files like this one.
#+BEGIN_SRC emacs-lisp
  (use-package org
    ;; :hook (org-mode ((lambda nil (load-theme-buffer-local 'tsdh-light (current-buffer)))))
    :config
    (setq header-line-format " ")
    ;;(add-hook 'org-mode-hook '(load-theme-buffer-local 'tsdh-light (current-buffer)))
    ;; (lambda () (progn
    ;;              (setq left-margin-width 2)
    ;;              (setq right-margin-width 2)
    ;;              (set-window-buffer nil (current-buffer))))
    ;;(setq line-spacing 0.1)
    (setq org-startup-indented t
          ;;org-bullets-bullet-list '(" ") ;; no bullets, needs org-bullets package
          ;;org-ellipsis "  " ;; folding symbol
          org-pretty-entities t
          org-hide-emphasis-markers t
          ;; show actually italicized text instead of /italicized text/
          ;;;org-agenda-block-separator ""
          org-fontify-whole-heading-line t
          org-fontify-done-headline t
          org-fontify-quote-and-verse-blocks t
          org-src-ask-before-returning-to-edit-buffer nil)
    (general-define-key :states 'normal :mode 'org-mode-map
                        "C-`" 'org-edit-special)
    (leader-key-def 'normal org-src-mode-map
      "w" 'org-edit-src-exit))
#+END_SRC
Create a table of contents without exporting.
#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :config
  (add-hook 'org-mode-hook 'toc-org-mode))
#+END_SRC
** Nix
These are tools for dealing with NixOS, my operating system.
*** Sandbox
Features for dealing with nix-shell in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package nix-sandbox)
#+END_SRC
*** Nix language support
#+BEGIN_SRC emacs-lisp
  (use-package company-nixos-options
    :hook (nix-mode-hook . (lambda () (add-to-list 'company-backends 'company-nixos-options))))

  (use-package nix-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode))
    (add-hook 'nix-mode-hook
              (lambda ()
                (setq tab-always-indent nil)
                (setq indent-tabs-mode t))))

#+END_SRC
** Bash
#+BEGIN_COMMENT 
I use a zero width space here to escape the underscore 
#+END_COMMENT
Enter mode for bash on .profile, .bash_​aliases, and .inputrc
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '(".profile\\'" . shell-script-mode))
(add-to-list 'auto-mode-alist '(".bash_aliases\\'" . shell-script-mode))
(add-to-list 'auto-mode-alist '(".inputrc\\'" . shell-script-mode))
#+END_SRC
* Excessive BS
** Spotify
Control spotify running on any device from Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package spot4e :load-path "~/code/elisp/spot4e"
    :after general
    :requires helm url json
    :config
    (setq spot4e-refresh-token me/spotify-refresh-token)
    (run-with-timer 0 (* 60 59) 'spot4e-refresh)

    (define-subleader :leader alt-leader
      "s" "spotify" spotify-key-def)
    (spotify-key-def 'normal emacs-lisp-mode-map
      "b" 'spot4e-helm-search-user-tracks
      "r" 'spot4e-helm-search-recommendations-track
      "s" 'spot4e-player-pause
      "p" 'spot4e-player-play
      "n" 'spot4e-player-next
      "N" 'spot4e-player-previous))
#+END_SRC
** Emacs window manager
Yep. No, I don't currently use it.
#+BEGIN_SRC emacs-lisp
(use-package exwm
  :config
  (fringe-mode 1)
  (require 'exwm-config)
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (not exwm-instance-name)
                        (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                (exwm-workspace-rename-buffer exwm-title))))
  (setq exwm-input-global-keys
        `(
          ;; Bind "s-r" to exit char-mode and fullscreen mode.
          ([?\s-r] . exwm-reset)
          ;; Bind "s-c" to enter char mode
          ([?\s-c] . exwm-input-release-keyboard)
          ;; Bind "s-w" to switch workspace interactively.
          ([?\s-w] . exwm-workspace-switch)
          ;; Bind "s-0" to "s-9" to switch to a workspace by its index.
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i))))
                    (number-sequence 0 9))
          ;; Bind "s- " to launch applications
          ([?\s- ] . (lambda (command)
		               (interactive (list (read-shell-command "$ ")))
		               (start-process-shell-command command nil command)))
          ;; Bind "s-<f2>" to "slock", a simple X display locker.
          ;; ([s-f2] . (lambda ()
		  ;;             (interactive)
		  ;;             (start-process "" nil "/usr/bin/slock")))
          ))
  ;; logout function
  (defun exwm-logout ()
    (interactive)
    (recentf-save-list)
    (save-some-buffers)
    (start-process-shell-command "logout" nil "lxsession-logout"))
  ;; start in char mode by default
  ;; (setq exwm-manage-configurations '((t char-mode t)))
  ;; sys tray with network
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
  (shell-command "nm-applet")
  ;; set prefix keys
  (setq my-exwm-prefix-keys (list ?\s-f ?\s-h ?\s-j ?\s-k ?\s-l ?\s-H ?\s-J ?\s-K ?\s-L ?\: ?\,))
  (setq exwm-input-prefix-keys (nconc exwm-input-prefix-keys my-exwm-prefix-keys)))
#+END_SRC
* Files and backups
Don't make backups.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC
Save cursor position in a file between sessions.
#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC
* After startup
Load themes after everything else because it seems that the faces are
incorrect otherwise.
#+BEGIN_SRC emacs-lisp :noweb strip-export
<<themes>>
#+END_SRC
* Helper functions
Various small functions which are evaluated before anything else in the file.
#+NAME: helper-functions
#+BEGIN_SRC emacs-lisp
(defun remove-keyword-args (list)
  "Removes keyword arguments from the given list"
  (car (general--remove-keyword-args list)))

(defun reload-init-file ()
  "Load all elisp from 'user-init-file'."
  (interactive)
  (load-file user-init-file))

(defun move-line-up ()
  "Move up the current line."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode))

(defun move-line-down ()
  "Move down the current line."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode))
#+END_SRC
